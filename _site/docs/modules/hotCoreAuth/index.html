<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Hotplate - documentation: Framework to create multi-homed SaaS with NodeJs, Express" />

    <link rel="stylesheet" type="text/css" media="screen" href="/global/header.css">
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/stylesheet.css">

    <title>Hotplate documentation</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">

        <div class="main_menu">
             <span><a href="/">Home</a></span>
             <span><a href="/docs">Documentation</a></span>
        </div>

        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mercmobily/hotplate">View on GitHub</a>


          <h1 id="project_title">Hotplate documentation</h1>
          <h2 id="project_tagline">Framework to create multi-homed SaaS with NodeJs, Express</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mercmobily/hotplate/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mercmobily/hotplate/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

      <h1 id="hotcoreauth">hotCoreAuth</h1>

<p>This module provides authentication abilities to Hotplate, including password recovery, registration, login, credential management, and in-app resuming.</p>

<p>This module provides authentication abilities to your application by:</p>

<ul>
  <li>Defining authentication stores to be used in your app</li>
  <li>Creating authentication routes to handle authentication using Passport</li>
</ul>

<p>This module requires splugins (at the moment, <code>local</code> and <code>facebook</code>) for strategy-specific functionalities.</p>

<p>While most of other authentication systems are based on username/password, and then allow you to associate “extra” authentication methods to those username/password pairs (Oauth, etc.), in hotCoreAuth <em>each login method is the equal</em>. The user record only has the user’s ID. You might decide to sign up with your Facebook profile, and never bother with setting username/password or vice-versa.</p>

<h1 id="overview">Overview</h1>

<p>hotCoreAuth uses Passport to abstract how authentication works. Once you have configured hotCoreAuth, your application will have a fully functional authentication infrastructure that works with login/password pair as well as two-legged authentication systems (like Facebook).</p>

<p>hotCoreAut is powerful enough that can be in itself a good enough reason to use Hotplate.</p>

<p>Here are the terms you need to know so that you can configure it correctly for your application.</p>

<p><em>NOTE: <code>hotCoreAuth</code> uses passport for every authentication strategy, including <code>local</code>. This is done mainly for consistency: <code>local</code> is not a two-legged authentication, and it wouldn’t need Passport stricky speaking.</em></p>

<p>There are five <em>actions</em> connected to authentication:</p>

<ul>
  <li><code>signin</code> – will actually login using existing credentials</li>
  <li><code>resume</code> – will resume an existing session if authentication has expired</li>
  <li><code>register</code> – will register as a new user, and automatically assign a strategy to them</li>
  <li><code>manager</code> – will assign authentication strategies to existing users</li>
  <li><code>recover</code> – will reset credentials</li>
</ul>

<p>There are currently two implemented strategies (although it’s trivial to create more):</p>

<ul>
  <li><code>local</code> – using simply a combination of login and password. The credentials will consist of a login/password pair</li>
  <li><code>facebook</code> – using Facebook’s authentication scheme. The credentials will consist of the Facebook user ID</li>
</ul>

<p>hotCoreAuth will use plugins to create authentication URLs for the corresponding strategy; for example for <code>facebook</code>, the <code>facebook</code> module it will create:</p>

<ul>
  <li>GET <code>/auth/signin/facebook</code></li>
  <li>GET <code>/auth/register/facebook</code></li>
  <li>GET <code>/auth/recover/facebook</code></li>
  <li>GET <code>/auth/manager/facebook</code></li>
  <li>GET <code>/auth/resume/facebook</code></li>
</ul>

<p>For the <code>local</code> strategy, the <code>local</code> module will create:</p>

<ul>
  <li>POST <code>/auth/signin/local</code></li>
  <li>POST <code>/auth/register/local</code></li>
  <li>POST <code>/auth/recover/local</code></li>
  <li>POST <code>/auth/manager/local</code></li>
  <li>POST <code>/auth/resume/local</code></li>
</ul>

<p>These URLs are the ones clients will have to use to complete the required action. Note that while some URLs will require a payload (for example, <code>local</code> will require <code>login</code> and <code>password</code> in their POST payload), others will deal with authentication without any data (users will be redirected to Facebook’s login screen). The <a href="#docs-routes">routes</a> section explains in detail what routes are created and how to interact with them.</p>

<p>These routes are the only way to add an authentication strategy to a user via REST calls.</p>

<p>In hotCoreAuth, the <em>operation</em> that is about to be performed is defined by the pair <em>strategy-action</em> (for example <code>local-signin</code>, or <code>facebook-recover</code>, etc.).</p>

<p>The response from the server will depend on the <em>response type</em>, which is decided by the client by setting a cookie named after the operation’s name (for example <code>XXXX-signin</code>, <code>XXXX-recover</code>, <code>XXXX-register</code>, <code>XXXX-resume</code>, <code>XXXX-manager</code>, where <code>XXXX</code> can be <code>facebook</code>, <code>local</code>, or any other authentication strategy). For example:</p>

<ul>
  <li>
    <p>an ajax-based login screen based on local login will have something like this in code: <code>cookie( 'local-signin', 'ajax', { path: '/' } );</code>;</p>
  </li>
  <li>
    <p>a Facebook-based login screen will likely open a new window on <code>/auth/signin/facebook</code> to autenticate, and will want 1) that new window closed by the end of the authenticaton process 2) the parent window redirected to the application; so, it will have something like this in the code: <code>cookie( 'facebook-signin', 'redirect-opener', { path: '/' } );</code>;</p>
  </li>
  <li>
    <p>a simpler Facebook-based login screen might not open a new window, and simply link to the Faceook authentication page on <code>/auth/signin/facebook</code> to autenticate. In this case, after authentication the application should redirected to the main application’s URL; so, it will have something like this in the code: <code>cookie( 'facebook-signin', 'redirect', { path: '/' } );</code>;</p>
  </li>
</ul>

<p>The default action is <code>redirect</code>.</p>

<p>The response type will depend on how the login screen wants to happen.</p>

<p>Here is a list of possible <em>response types</em> (corresponding to the cookie’s value):</p>

<ul>
  <li>
    <p><code>content</code> – The function returned by <code>hotCoreAuth.contentResponsePage</code> is run with parameters <code>strategyId, action, user, profile</code>, and the result is then served to the client. The (redefinable) stock function will simply display an HTML page with the word “RESPONSE” in it; the page will close (thanks to a Javascript timer) after 5 seconds. If you use this response type, you ought to redefine <code>hotCoreAuth.contentResponsePage</code> to something more meaningful. This response type is useful when you want to create a very customized response page following your login.</p>
  </li>
  <li>
    <p><code>close</code> – The function returned by <code>hotCoreAuth.closeResponsePage</code> is run with parameters <code>strategyId, action, user, profile</code>, and the result is then served to the client. The (redefinable) stock function will work like this: if <code>user</code> is set (login successful): the window is closed immediately. If <code>user</code> isn’t set and <code>profile</code> has a <code>message</code> attribute, the message is displayed with a Javascript <code>alert()</code> and the window is then closed. This response type is useful when you are already logged in, and are adding a new strategy to an existing user.</p>
  </li>
  <li>
    <p><code>ajax</code> – If <code>user</code> is set, it returns a page with status 200, and – as contents – a JSON string like so: <code>{ user: user, profile: profile }</code>.  If <code>user</code> isn’t set, it returns a page with status <code>403</code> and a JSON string like so: <code>{ message: error }</code> NOTE: Setting <code>ajax</code> as a response type only makes sense for local authentication, since the ajax information will be returned after a redirect, which will basically result in an HTML page containing successful or unsuccesful JSON data. This response type is useful to the login/password strategy, that can have a response straight away.</p>
  </li>
  <li>
    <p><code>redirect-opener</code> – The function returned by <code>hotCoreAuth.redirectOpenerResponsePage</code> is run with parameters <code>strategyId, action, user, profile</code>, and the result is then served to the client. The (redefinable) stock function will work like this: if the user isn’t set (login failed) and <code>profile.message</code> is set, it will display <code>profile.message</code> in a Javascript alert coming from the opener; otherwise (login is successful), it will redirect the opener window by setting its location to  hotCoreAuth.redirectURLs.success[‘action’]. In any case, the current window will be closed. This response type is useful when a login page opens the authentication URL in a new window, and wants the opening window to be redirected to the application after authentication.</p>
  </li>
  <li>
    <p><code>redirect</code> – If <code>user</code> is set, the current window redirected to the URL set as <code>hotCoreAuth.redirectURLs.success['action']</code>. If <code>user</code> isn’t set, <code>req.session.messages</code> is pushed <code>{ type: 'error', message: profile.message }</code> and  the window is redirected to <code>hotCoreAuth.redirectURLs.fail['action']</code>. Note that the new page will have access to the message via the session. This response type is useful when a login page is simply a link to the authentication URL and wants to redirect to the application after authentication.</p>
  </li>
</ul>

<p>You can see the signatures of the <code>responsePage</code> functions in the <a href="#configuration">configuration section</a> of this document.</p>

<p>hotCoreAuth provide three stores that will hold the authentication data:</p>

<ul>
  <li>
    <p><code>authStrategies</code> A pseudo-store, basically containing the keys of the configuration object <code>hotCoreAuth.strategies</code>. It implements <code>get</code> and <code>getQuery</code>.</p>
  </li>
  <li>
    <p><code>users</code>. A simple store that contain just the IDs of the created users. <em>There is no username associated to a user!</em> A user is just an abstract entry: what really matters is the user ID.</p>
  </li>
  <li>
    <p><code>usersStrategies</code>. The list of strategies associated to a specific user. Basically, it defines how a user can actually login. It implements <code>get</code>, <code>getQuery</code> and <code>delete</code>; the store has a public URL so that existing users can see how they are allowed to login, and can delete a strategy if they wish. Each record contains the strategyId and four fields, which will contain strategy login information. For example the strategy <code>facebook</code> will have the Facebook’s userId as <code>field1</code>, whereas the <code>local</code> strategy will have the user’s login name in <code>field1</code> and the user’s password in <code>field3</code>. Note that <code>field3</code> and <code>field4</code> are considered ‘protected’ (which imply that they will not be returned by REST queries).</p>
  </li>
</ul>

<p>This document details the specifications of these <a href="#docs-stores">stores</a>.</p>

<h1 id="configuration">Configuration</h1>

<p>Once you are familiar with the concepts explained above, configuration of <code>hotCoreAuth</code> is very straightforward.</p>

<pre><code>hotplate.config.set('hotCoreAuth', {

  callbackURLBase: 'http://localhost:3000',

  recoverURLexpiry: 60*30, // Seconds for which the recover URL works for

  // Only local strategy enabled by default
  strategies: {
    local: { },
  },

  redirectURLs: {
    success: {
      signin: hotplate.prefix( '/auth/pick' ),
      recover: hotplate.prefix( '/auth/pick' ),
      register: hotplate.prefix( '/auth/pick' ),
      manager: hotplate.prefix( '/' ),
    },

    fail: {
      signin: hotplate.prefix( '/auth/welcome' ),
      recover: hotplate.prefix( '/auth/welcome' ),
      register: hotplate.prefix(  '/auth/welcome' ),
      manager: hotplate.prefix( '/' ),
    }
  },
  contentResponsePage: basicContentResponsePage,
  closeResponsePage: basicCloseResponsePage,
  redirectOpenerResponsePage: basicRedirectOpenerResponsePage,
});
</code></pre>

<p>Here is an explanation of each option:</p>

<ul>
  <li>
    <p><code>callbackURLBase</code>. It’s the host/port parts of the URL used as prefix for Oauth callbacks.
This should be changed to your server’s IP in production. This is necessary because two-legged authentication methods always end up redirecting to a specific URL.</p>
  </li>
  <li>
    <p><code>recoverURLexpiry</code>. The number of seconds the recover URL will work for</p>
  </li>
  <li>
    <p><code>strategies</code>. The login strategies available to your application. By default, it’s just <code>local</code> (which doesn’t need parameters). In your application you might have:</p>
  </li>
</ul>

<p><code>
    hotplate.config.set('hotCoreAuth.strategies', {
      facebook: {
        clientID: 'XXXXXXXXXXXXXXXXXX',
        clientSecret: 'YYYYYYYYYYYYYYYYYYYYYY',
      },
      local: {
      },
</code></p>

<ul>
  <li>
    <p><code>redirectURLs</code>. These URLs are used for the redirect and redirect-opener actions as well as <code>/recover/:recoverToken</code> (which will redirect to <code>hotCoreAuth.redirectURLs.success.recover</code>). Note that <code>hotplate.routeUrlsPrefix</code> prefixes are honoured thanks to the <code>hotplate.prefix()</code> call (as they should).</p>
  </li>
  <li>
    <p><code>contentResponsePage</code>. The function that will generate the page content in case the response type is set as <code>content</code>. Note that a basic <code>basicContentResponsePage</code> function is set as default and can be used as a template.</p>
  </li>
  <li>
    <p><code>closeResponsePage</code>. The function that will generate the page responsible of closing the current window in case the response type is <code>close</code>. Note that a basic <code>basicCloseResponsePage</code> function is set as default and can be used as a template.</p>
  </li>
  <li>
    <p><code>redirectOpenerResponsePage</code>. The function that will generate the page responsible of redirecting the opener to the appropriate URL. Note that a basic <code>basicRedirectOpenerResponsePage</code> function is set as default and can be used as a template</p>
  </li>
</ul>

<p>The signature for <code>contentResponsePage</code>, <code>closeResponsePage</code> and <code>redirectResponsePage</code> is the same: <code>function( strategyId, action, user, profile)</code>. For example you might write:</p>

<pre><code>hotplate.config.set('hotCoreAuth.contentResponsePage' ) = function( strategyId, action, user, profile ){
    ...
    return 'some response that will be sent over';
  }
</code></pre>

<p>If <code>user</code> is <code>false</code>, authentication failed. Note that these functions don’t have access to <code>res</code>: they simply return the page that will be returned to the client.</p>

<h1 id="writing-plugins-for-extra-strategies">Writing plugins for extra strategies</h1>

<p>Writing plugins for extra strategies requires you to know some of hotCoreAuth internals.</p>

<p>When it’s run, <code>hotCoreAuth</code> will scan the configuration object <code>hotCoreAuth.strategies</code>, an object where each key is a strategy name. The value associated to the key will be its configuraton. For example:</p>

<pre><code>facebook: {
  clientID: 'XXXXXXXXXXXX',
  clientSecret: 'XXXXXXXXXX',
}
</code></pre>

<p>Where <code>clientID</code> and <code>clientSecret</code> are provided by Facebook: to get them you will need to go to the <a href="https://developers.facebook.com/">Developers</a> section of Facebook, and click on My <code>Apps &gt; Add a new app</code>. The created app will have the required <em>App ID</em> and <em>App Secret</em> you need to fill in these fields;</p>

<p>There are two moments when strategies use their stragegy-specific plugins: during the event <code>setRoutes</code> and during the event <code>stores</code>.</p>

<h3 id="extra-routes-defined-by-plugins">Extra routes defined by plugins</h3>

<p>In Hotplate, a module defines routes by responding to the event <code>setRoutes</code>. However, the routes set by hotCoreAuth depend on the strategy plugins you have enabled. Strategy plugins export a function, <code>strategyRoutesMaker()</code>, which will be responsible of creating the necessary extra routes for that particular strategy.</p>

<p>When responding to <code>setRoutes</code>, hotCoreAuth will first set its own URLs (that is, the recover URL) and will then cyclically <code>require()</code> <em>all</em> modules defined in <code>hotCoreAuth.strategies</code>, appending <code>.js</code> to the strategy’s name; for example the module <code>auth/facebook.js</code> will be loaded, and the <code>strategyRoutesMaker</code> attribute of the module will be called (since it’s actually a function reponsible of creating the appropriate routes for the <code>facebook</code> strategy). <code>strategyRoutesMaker()</code> has the following signature:</p>

<pre><code>strategyRoutesMaker( app, strategyName, function( err ) { } );
</code></pre>

<p>In case of Facebook, the routes created are:</p>

<ul>
  <li>Manager: <code>GET /auth/manager/facebook</code>, <code>GET /auth/manager/facebook/callback</code></li>
  <li>Signin: <code>GET /auth/signin/facebook</code>, <code>GET /auth/manager/signin/callback</code></li>
  <li>Recover: <code>GET /auth/recover/facebook</code>, <code>GET /auth/manager/recover/callback</code></li>
  <li>Register: <code>GET /auth/register/facebook</code>, <code>GET /auth/manager/register/callback</code></li>
  <li>Resume: <code>GET /auth/resume/facebook</code>, <code>GET /auth/manager/resume/callback</code></li>
</ul>

<p>They do not need any parameters, as authentication will be fully handled by Facebook.</p>

<h3 id="extra-stores-defined-by-plugins">Extra stores defined by plugins</h3>

<p>In Hotplate, a module defines stores by responding to the event <code>stores</code>. However, the stores set by hotCoreAuth depend on the strategy plugins you have enabled. Strategy plugins export a function, <code>extraStores()</code>, which will be responsible of creating the necessary extra stores for that particular strategy.</p>

<p>When responding to <code>stores</code>, hotCoreAuth will first set its own URLs (that is, <code>authStrategies</code>, <code>users</code>, <code>usersStrategies</code>) and will then cyclically <code>require()</code> <em>all</em> modules defined in <code>hotCoreAuth.strategies</code>, appending <code>.js</code> to the strategy’s name; for example the module <code>auth/local.js</code> will be loaded, and the <code>extraStores</code> attribute of the module will be called (since it’s actually a function reponsible of creating the appropriate stores for the <code>local</code> strategy). <code>extraStores()</code> has the following signature:</p>

<pre><code>strategyRoutesMaker( stores, function( err ) { } );
</code></pre>

<p>In case of <code>local</code>, the extra store <code>logins</code> is created: that’s a read-only store that will allow users to check if a user name is already taken.</p>

<h2 id="hotcoreauths-routes-with-passport">hotCoreAuth’s routes with Passport</h2>

<p>The authentication routes are all managed by Passport, “the” powerful authentication module for Node.js.</p>

<p>Here is what happens for Facebook.</p>

<p>For <code>signin</code>, <code>facebook.js</code> will first define a <code>named strategy</code> called <code>facebook-signin</code>, as well as define two routes. Here is the full (but redacted for brevity) source code:</p>

<pre><code>// STRATEGY DEFINITION
strategyConfig = hotplate.config.get( 'hotCoreAuth.strategies.facebook' );
passport.use( 'facebook-signin', new FacebookStrategy({
  clientID: strategyConfig.clientID,
  clientSecret: strategyConfig.clientSecret,
  callbackURL: callbackURLBase + hotplate.prefix( "/auth/signin/facebook/callback" ),
  passReqToCallback: true,
},

// This will check if `profile` is registered and therefore allowed to login
function customAuthentication( req, accessToken, refreshToken, profile, done ) {
  // ...
  // This function will return either
  done( null, false, { message: "Facebook didn't return a profile ID, procedure aborted" } );
  // Or:
  done( null, false, { message: "Your Facebook user is not registered" } );
  // or:
  done( null, user, profile  );
}
));

// FIRST ROUTE
app.get('/auth/signin/facebook', passport.authenticate('facebook-signin'));

// SECOND ROUTE
app.get('/auth/signin/facebook/callback', function( req, res, next) {
  passport.authenticate('facebook-signin',  makeResponder( req, res, next, 'facebook', 'signin')  )(req, res, next);
});
</code></pre>

<p>Here is the breakdown of what happens.</p>

<h3 id="the-strategy-definition">The strategy definition</h3>

<pre><code>// STRATEGY DEFINITION
strategyConfig = hotplate.config.get( 'hotCoreAuth.strategies.facebook' );
passport.use( 'facebook-signin', new FacebookStrategy({
  clientID: strategyConfig.clientID,
  clientSecret: strategyConfig.clientSecret,
  callbackURL: callbackURLBase + hotplate.prefix( "/auth/signin/facebook/callback" ),
  passReqToCallback: true,
},
// This will check if `profile` is registered and therefore allowed to login
function customAuthentication( req, accessToken, refreshToken, profile, done ) {
  // ...
  // This function will return either
  done( null, false, { message: "Facebook didn't return a profile ID, procedure aborted" } );
  // Or:
  done( null, false, { message: "Your Facebook user is not registered" } );
  // or:
  done( null, user, profile  );
}
));
</code></pre>

<p>With this code you are registering a named strategy called <code>facebook-signin</code> with a bunch of facebook-specific parameters (<code>clientID</code>, <code>clientSecret</code>, etc.) and – most importantly – a callback used to check whether the <code>profile</code> returned by Facebook is actually allowed to sign in. This callback is called with the parameters <code>req</code>, <code>accessToken</code>, <code>refreshToken</code>, <code>profile</code>, <code>done</code>, and will need to call <code>done()</code> with the following parameters:</p>

<ul>
  <li><code>err</code> – as usual in node</li>
  <li><code>user</code> – if authentication was successful, the simple Hotplate user object; if it didn’t, ‘false’</li>
  <li><code>info</code> – if authentication was successful ( that is, <code>user !== false</code>), the Facebook profile information; if it didn’t, an object with a <code>message</code> attribute: <code>{ message: 'The authentication problem' }</code>.</li>
</ul>

<p>If successful, the custom authentication functon will also set <code>req.session.loggedIn</code> and <code>req.session.userId</code> (the default session variables for Hotplate)</p>

<h3 id="the-first-route">The first route</h3>

<p><code>
    // FIRST ROUTE
    app.get('/auth/signin/facebook', passport.authenticate('facebook-signin'));
</code></p>

<p>This route is managed completely by Passport (<code>passport.authenticate('facebook-signin')</code> returns a valid Express route function). This route, which will generally be opened in a new window in your client application, will redirect to facebook.com, passing on the <code>clientID</code>, <code>clientSecret</code> and <code>callbackURL</code>. At the end of the process, Facebook will then always redirect the user’s browser to <code>/auth/signin/facebook/callback</code> (the callback URL provided earlier to Facebook), passing along information relevant to authentication: namely whether it worked or not, and – if it did work – the profile information. This secound route is – needless to say – managed directly by Passport via the second route definition.</p>

<h3 id="the-second-route">The second route</h3>

<pre><code>// SECOND ROUTE
app.get('/auth/signin/facebook/callback', function( req, res, next) {
  passport.authenticate('facebook-signin',  makeResponder( req, res, next, 'facebook', 'signin')  )(req, res, next);
});
</code></pre>

<p>The scoping of this function can be a little confusing. A little simplification would make it read like so (since <code>makeResponder()</code> returns a function):</p>

<pre><code>app.get('/auth/signin/facebook/callback', function( req, res, next) {
  passport.authenticate('facebook-signin',  function responder( err, user, profile ){ ... }  )(req, res, next);
});
</code></pre>

<p>Considering that <code>passport.authenticate()</code> returns a function with the same signature (<code>req, res, next</code>), and it’s returning a function only so that Passport is framework-agnostic, for all intents and purposes, the second line could well read <code>passport.authenticate( req, res, next, 'facebook-signin',  function responder( err, user, profile ){ ... } );</code>.</p>

<p>So, it could be read (in a simplified form) as:</p>

<pre><code>app.get('/auth/signin/facebook/callback', function( req, res, next) {
  passport.authenticate(req, res, next, 'facebook-signin',  function responder( err, user, profile ){
    ...
  });
});
</code></pre>

<p>That’s much more readable.</p>

<p>Since <code>passport.authenticate()</code> has access to <code>req</code> and <code>res</code>, it has access to all of the information that came from Facebook (the <code>accessToken</code> and the <code>refreshToken</code>). So, <code>passport.authenticate()</code> is able to call the strategy authentication callback defined earlier, passing it the parameters <code>req, accessToken, refreshToken, profile, done</code>.  Using this callback, <code>passport.authenticate()</code> is able to know if the acquired user is actually allowed to access the site (it will receive back <code>user</code> and <code>profile</code> from the calllback). At this point, <code>passport.authenticate()</code> will call the responder with the right parameters <code>user</code> and <code>profile</code>.</p>

<p>Note that in hotCoreAuth, the responder is actually generated by the function <code>makeResponder()</code>, which will respond with <code>res.send()</code> in accordance with the cookie set by the client, following hotCoreAuth specifications.</p>

<h2 id="writing-your-own-strategy">Writing your own strategy</h2>

<p>To write your own strategy, take <code>facebook</code> as a starting point and change it so that it uses the right Passport backend. It’s only 300 lines of code, most of which you will be able to reuse.</p>

<p>Use the information in this section of the module’s manual to get the module right. It’s not essential to know <em>everything</em> I covered, but it will certainly help you understand the code you write.</p>

<h1 id="docs-events">Events</h1>

<h2 id="docs-pageElements"><a href="/docs/events#docs-pageElements">pageElements</a></h2>

<p>This event is used to make sure that each page defines the following Javascript variables:</p>

<ul>
  <li><code>strategyIds</code> – the available strategy IDs managed by the server. Taken from  <code>Object.keys( hotplate.config.get('hotCoreAuth.strategies')</code></li>
  <li><code>successURLs</code> – the URLs to use in case of success. Taken from <code>hotplate.config.get('hotCoreAuth.redirectURLs.success')</code>.</li>
  <li><code>failURLs</code> – the URLs to use in case of success. Taken from <code>hotplate.config.get('hotCoreAuth.redirectURLs.success')</code>.</li>
</ul>

<h2 id="docs-pageElements"><a href="/docs/events#docs-pageElements">pageElementsPerPage</a></h2>

<p>This event is used to make sure that if req.userId is set, then rendered pages will have:</p>

<ul>
  <li><code>userId</code> – The userId taken from <code>req.session.userId</code></li>
</ul>

<h2 id="docs-stores"><a href="/docs/events#docs-stores">stores</a></h2>

<p>The stores returned by this module are:</p>

<h3 id="docs-stores-authstrategies"><code>authStrategies</code></h3>

<p>The strategies available. This store is a pseudo-store (it doesn’t rely on data stored in a database, and it’s inherited from <code>JsonRestStores</code>+<code>JsonRestStores.HTTPMixin</code>). Its data is the keys of the configuration object <code>hotCoreAuth.strategies</code>, which is the data returned by the methods <code>get</code> and <code>getQuery</code>.</p>

<pre><code>var AuthStrategies = declare( JsonRestStores, JsonRestStores.HTTPMixin, {

  schema: new SimpleSchema({
    id:        { type: 'blob', isRequired: true, trim: 30 }  ,
  }),

  handleGet: true,
  handleGetQuery: true,

  storeName:  'authStrategies',

  publicURL: '/authstrategies/:id',
  hotExpose: true,

  // Fetch one strategy (if it's defined in hotCoreAuth.strategies)
  implementFetchOne: function( request, cb ){ },

  // Return the strategies, depending on `hotCoreAuth.strategies`'s keys
  implementQuery: function( request, cb ){ },
});

stores.authStrategies = new AuthStrategies();
</code></pre>

<h3 id="docs-stores-users"><code>users</code></h3>

<p>The list of users. Note that only very little information is stored about the user itself: this table only stores the <code>id</code>, the <code>recoverToken</code> and the <code>recoverTokenCreated</code> fields. It is not exposed to the client application at all: it’s only created to be accessible via API within Hotplate itself.</p>

<pre><code>var Users = declare( HotStore, {

  schema: new HotSchema({
    id                 : { type: 'id' },
    recoverToken       : { type: 'blob', searchable: true, notempty: true },
    recoverTokenCreated: { type: 'date', searchable: true, notempty: true },
  }),

  storeName:  'users',
  idProperty: 'id',
});
stores.users = new Users();
</code></pre>

<h3 id="docs-stores-usersstrategies"><code>usersStrategies</code></h3>

<p>This store contains the list of strategies associated to a specific user. It’s there so that users are able to delete unwanted strategies. Note that strategies are only ever added by the specific strategy layers (like <code>facebook</code> or <code>local</code>).</p>

<p>It implements <code>get</code>, <code>getQuery</code> and <code>delete</code>, and it only allows querying to the record owner (<code>session.userId</code> needs to match the query string’s <code>userId</code>, or it will return Unauthorized). It also doesn’t allow a user to delete their last remaining strategy (otherwise they won’t be allowed to log back in, nor to recover their access).</p>

<p>Note that <code>field3</code> and <code>field4</code> are used by hotCoreAuth to store sensitive information, as they are never returned by the store.</p>

<pre><code>var UsersStrategies = declare( HotStore, {

  schema: new HotSchema({
    strategyId:  { type: 'blob', searchable: true, required: true, trim: 30 }  ,
    field1:      { type: 'blob', searchable: true, required: false, trim: 255 } ,
    field2:      { type: 'blob', searchable: true, required: false, trim: 255 } ,
    field3:      { type: 'blob', searchable: true, required: false, trim: 255 } ,
    field4:      { type: 'blob', searchable: true, required: false, trim: 255 } ,
  }),

  // Nothing is searchable in usersStrategies by default
  onlineSearchSchema: new HotSchema({
  }),

  storeName:  'usersStrategies',

  publicURL: '/users/:userId/strategies/:id',
  hotExpose: true,

  preserveCacheOnReset: true,

  handleGet: true,
  handleGetQuery: true,
  handleDelete: true,

  // Users are only allowed to use `delete`, `get` and `getQuery` on their own strategies
  // Also, users are not allowed to `delete` a strategy if it's the last one remaining
  checkPermissions: function( request, method, cb ){ ... },

  // The field `field3` and `field4` are taken out of the equation, as they are "secret"
  extrapolateDoc: function( request, method, doc, cb ){ ... }
});
stores.usersStrategies = new UsersStrategies();
</code></pre>

<h3 id="stores-created-by-hotcoreauthlocal">Stores created by <code>hotCoreAuth/local</code></h3>

<h4 id="docs-stores-usersstrategies"><code>logins</code></h4>

<p>The strategies available. This store retis a pseudo-store (it doesn’t rely on data stored in a database, and it’s inherited from <code>JsonRestStores</code>+<code>JsonRestStores.HTTPMixin</code>). THe store takes its data from the <a href="#docs-stores-usersstrategies">userStrategies</a> store: the list of logins are the records where <code>strategyId</code> is <code>local</code>, and the login names are stores in <code>field1</code>).</p>

<p>Here is the definition:</p>

<pre><code>// This is used so that an applicaton can know in advance if a user login is already taken
var Logins = declare( JsonRestStores, JsonRestStores.HTTPMixin, {

  schema: new SimpleSchema({
    login     : { type: 'string', required: true, lowercase: true, trim: 30, searchable: true },
  }),

  storeName:  'logins',

  handleGetQuery: true,

  publicURL: '/logins/:id',
  hotExpose: true,

  // This is descriptive only
  queryConditions: {
    type: 'eq',
    args: [ 'login', '#login' ]
  },

  implementQuery: function( request, cb ){
    // return records from the `usersStrategies` store, filtering by `strategyId`
    // (needs to be `local`) and `field` (needs to match the `login` passed)
  },

});
stores.login = new Logins();
</code></pre>

<p>As you can see, the store only implements <code>handleGetQuery</code>, and in a very limited way. Note that <code>queryConditions</code> is defined, but it’s only there to let clients know how querying works.</p>

<h2 id="docs-routes"><a href="/docs/events#docs-routes">routes</a></h2>

<h3 id="get-recoverrecovertoken"><code>GET /recover/:recoverToken</code></h3>

<p>The URL that will validate recovery validation.</p>

<p>When a users completes the <code>recover</code> action (which might imply giving their user name, or verifying themselves via Facebook), the strategy plugin will actually creare a secret <code>recoveryToken</code> hash, and will associate it to the user’s record, and will emit a node event <code>hotCoreAuth/recover</code> (fire-and-forget); when that event is fired, the application will generally intercept it and send an email (or an SMS, or smoke signals) to the user with the “recovery URL”.</p>

<p><em>TODO: event is not fired yet. Still need to test procedure. Will do when “user invite” is done.</em></p>

<p>The “recovery URL” contains the <code>recoveryToken</code>: this route will check the database looking for a user with a matching <code>recoverToken</code> in the <code>users</code> table: if found, the user will be set as logged in and the user will be redirected to <code>hotCoreAuth.redirectURLs.success.recover</code>.</p>

<h3 id="routes-created-by-hotcoreauthauthfacebookjs">Routes created by <code>hotCoreAuth/auth/facebook.js</code></h3>

<p>The plugin <code>hotCoreAuth/facebook</code> will create the following “public” routes:</p>

<ul>
  <li>Manager: GET <code>/auth/manager/facebook</code></li>
  <li>Signin: GET <code>/auth/signin/facebook</code></li>
  <li>Recover: GET <code>/auth/recover/facebook</code></li>
  <li>Register: GET <code>/auth/register/facebook</code></li>
  <li>Resume: GET <code>/auth/resume/facebook</code></li>
</ul>

<p>These routes do not take any paramters. Your application should either just point there (in which case the <code>redirect</code> response type is recommended), or open a new window with them (usually using the <code>redirect-opener</code> response type).</p>

<p>It will also create the following “redirect” routes (not to be used directly by the application):</p>

<ul>
  <li>Manager: GET <code>/auth/manager/facebook/callback</code></li>
  <li>Signin: GET <code>/auth/signin/facebook.callback</code></li>
  <li>Recover: GET <code>/auth/recover/callback/facebook</code></li>
  <li>Register: GET <code>/auth/register/facebook/callback</code></li>
  <li>Resume: GET <code>/auth/resume/facebook/callback</code></li>
</ul>

<p>The public routes will always:</p>

<ol>
  <li>Redirect to Facebook, which will display the user a login/password screen.</li>
  <li>Operate on the database and manipulate the session variable if needed</li>
  <li>Return the information to the user; the response will depend on the <em>response type</em> cookie set by the login form (and, therefore, by the <em>ResponsePage</em> functions set by the user).</li>
</ol>

<p>A ‘successful login’ in <code>facebook</code> means that there is a record in <code>usersStrategies</code> where <code>strategyId</code> is <code>facebook</code>, and <code>field1</code> corresponds to the acquired Facebook ID.</p>

<p>The difference in these routes is in what they do in the second step. Here is the detail.</p>

<h4 id="get-authmanagerfacebook"><code>GET /auth/manager/facebook</code></h4>

<p>This route will only work if the user is already logged in (checked via the session variable <code>req.session.loggedIn</code>) since it’s meant to be used to <em>add</em> a new strategy to a logged in user.</p>

<p>In case of successful Facebook authenticaton, it will check whether <code>facebook</code> is already a login strategy associated to the user. If the user doesn’t yet have a <code>facebook</code> strategy associated to her, it will associate the Facebook profile ID with the user by adding a record to the store <code>usersStrategies</code>. The Facebook ID is stored in <code>field1</code> in the <code>userStrategies</code> store.</p>

<p>This operation will fail if either the user already has a <code>facebook</code> strategy associated to her, or if that Facebook ID is already associated to a different account.</p>

<p><em>Note</em>: the new strategy is added via a REST API call, like so: <code>usersStrategies.apiPost( { userId: req.session.userId, strategyId: 'facebook', field1: profile.id }</code> so that any notification mechanism (via comet) to existing users is actually triggered (e.g. the interface will be able to know that <code>login</code> is now a viable strategy).</p>

<h4 id="get-authsigninfacebook"><code>GET /auth/signin/facebook</code></h4>

<p>This route will only work if the user is <em>not</em> logged in (checked via the session variable <code>req.session.loggedIn</code>) since it’s meant to be used to actually login.</p>

<p>In case of successful login, it will set <code>req.session.loggedIn</code> and <code>req.session.userId</code>.</p>

<h4 id="get-authrecoverfacebook"><code>GET /auth/recover/facebook</code></h4>

<p>This route will only work if the user is <em>not</em> logged in (checked via the session variable <code>req.session.loggedIn</code>) since it’s meant to be used to recover access to the application.</p>

<p>In case of successful Facebook authentication, it will update the <code>users</code> table setting the fields <code>user.recoverToken</code> and <code>user.recoverTokenCreated</code>. The token is the same one used by the route <code>/recover/:recoverToken</code> to let the user back in. Also the signal XXXXXXXX (TODO: decide name and emit it!) is emitted, to notify the application which will, in turn, be responsible of sending the user the secret recovery URL (by SMS, email, smoke signals, etc.).</p>

<h4 id="get-authregisterfacebook"><code>GET /auth/register/facebook</code></h4>

<p>This route will only work if the user is not already logged in (checked via the session variable <code>req.session.loggedIn</code>).</p>

<p>In case of successful login, it will create a new entry in <code>users</code>, and a corresponding record in <code>usersStrategies</code> where <code>field1</code> has the acquired Facebook ID. It will also set <code>req.session.loggedIn</code> and <code>req.session.userId</code>.</p>

<p>This route will fail if that Facebook ID isn’t already used by another user in the application.</p>

<h4 id="get-authresumefacebook"><code>GET /auth/resume/facebook</code></h4>

<p>This route is totally equivalent to <code>/auth/signin/facebook</code>.</p>

<p>In terms of Hotplate, the difference is in the <em>response type</em>: since <code>signin</code> one is meant to be used from a login screen and <code>resume</code> is meant to be used within the application, the <em>response type</em> will definitely be different.</p>

<h3 id="routes-created-by-hotcoreauthauthlocaljs">Routes created by <code>hotCoreAuth/auth/local.js</code></h3>

<p>The plugin <code>hotCoreAuth/local</code> will create the following routes:</p>

<ul>
  <li>Manager: POST <code>/auth/manager/local</code></li>
  <li>Signin: POST<code>/auth/signin/local</code></li>
  <li>Recover: POST<code>/auth/recover/local</code></li>
  <li>Register: POST<code>/auth/register/local</code></li>
  <li>Resume: POST<code>/auth/resume/local</code></li>
</ul>

<p>This plugin is somewhat “atypical” in terms of hotCoreAuth and passport, because – unlike the others – it doesn’t require two-legged authentication: the response is provided by these URLs directly, rather than by a callback URL. This means that the <code>local</code> plugin is the only candidate for the <code>ajax</code> response type (although that’s not a must).</p>

<p>A ‘successful login’ for <code>local</code> means that there is a record in <code>usersStrategies</code> where <code>strategyId</code> is <code>local</code>, <code>field1</code> is <code>user</code> and (a hashed version of) <code>field2</code> is <code>password</code>.</p>

<p>Here is the description of each one.</p>

<h4 id="post-authmanagerlocal"><code>POST /auth/manager/local</code></h4>

<p>This route will only work if the user is already logged in (checked via the session variable <code>req.session.loggedIn</code>) since it’s meant to be used to <em>add</em> a new strategy to a logged in user.</p>

<p>Input:</p>

<ul>
  <li><code>login</code> – the login name to be changed</li>
  <li><code>password</code> – the password to be set for that login name. If the password is <code>*</code>, then it’s left unchanged. This is used when users want to change their login name without re-submitting the password</li>
</ul>

<p>This route will either add a new <code>local</code> strategy for the user (using given <code>login</code> and <code>password</code>), or it will update the existing <code>local</code> strategy information with the provided <code>login</code> and <code>password</code>. Note that it’s also possible to just update the username, without re-submitting the password, by setting the password as <code>*</code>. The record in <code>usersStrategies</code> will have <code>field1</code> set as the login name, and <code>field3</code> as a hashed version of the user’s password.</p>

<p>Ths route willl fail if the login is already in use by another user;</p>

<p><em>Note</em>: if <code>local</code> wasn’t an allowed strategy for the user (that is, a new record is being added to <code>usersStrategies</code>), the new strategy is added via a REST API call, like so: <code>usersStrategies.apiPost( { userId: req.session.userId, strategyId: 'local', field1: login.toLowerCase(), field3: password }</code> so that any notification mechanism (via comet) to existing users is actually triggered (e.g. the interface will be able to know that <code>login</code> is now a viable strategy).</p>

<h4 id="get-authsigninlocal"><code>GET /auth/signin/local</code></h4>

<p>This route will only work if the user is <em>not</em> logged in (checked via the session variable <code>req.session.loggedIn</code>) since it’s meant to be used to actually login.</p>

<p>In case of successful login, it will set <code>req.session.loggedIn</code> and <code>req.session.userId</code>.</p>

<p>Input:</p>

<ul>
  <li><code>login</code> – the login name used to sign in</li>
  <li><code>password</code> – the password</li>
</ul>

<h4 id="get-authrecoverlocal"><code>GET /auth/recover/local</code></h4>

<p>This route is exactly the same as Facebook’s equivalent <code>recover</code> route.</p>

<h4 id="get-authregisterlocal"><code>GET /auth/register/local</code></h4>

<p>This route will only work if the user is not already logged in (checked via the session variable <code>req.session.loggedIn</code>).</p>

<p>This route wll create a new empty user, as well as a corresponding record in <code>usersStrategies</code> which will have <code>field1</code> set as the login name, and <code>field3</code> as a hashed version of the user’s password. It will also set <code>req.session.loggedIn</code> and <code>req.session.userId</code>.</p>

<p>This route will fail if the username is already taken or it’s empty.</p>

<h4 id="get-authresumelocal"><code>GET /auth/resume/local</code></h4>

<p>This route is totally equivalent to <code>/auth/signin/local</code>.</p>

<p>In terms of Hotplate, the difference is in the <em>response type</em>: since <code>signin</code> one is meant to be used from a login screen and <code>resume</code> is meant to be used within the application, the <em>response type</em> will definitely be different.</p>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Hotplate - documentation maintained by <a href="https://github.com/mercmobily">mercmobily</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

  </body>
</html>
