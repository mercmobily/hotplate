{"name":"Hotplate - documentation","tagline":"Framework to create multi-homed SaaS with NodeJs, Express, MongoDB, Dojo","body":"hotplate\r\n========\r\n\r\nHotplate is a framework that allows you to create 201X software in no time.\r\nBy 201X software I mean software that:\r\n\r\n* allows you to log in using Facebook, Google, Twitter, Oauth1/2, or... well, login/password pair if you like\r\n* available anywhere with a Javascript runtime (see: any modern browser)\r\n* _feels like_ software, and not like a bunch of web pages\r\n* uses a smart client, and a smart server; the smart client is to display information is the most user-friendly possibly way, whereas the smart server is to provide a bunch of secure data-store that are JSON-REST compatible\r\n* handles errors (including, and in fact _especially_, network errors) properly. If anything really bad happens, the application must not stop. Instead, it will tell the user that something network-wise went wrong\r\n* has the ability to communicate to your users in different ways: email, SMS, and whatever the world throws at us\r\n* shows information **as it changes** to the user. If you have three tabs open, and change your user photo, from one tab, the other two tabs need to see the new photo as well\r\n\r\nI realise that in 202X (that is, 2020 to 2030) writing software will be different. What is cool now, will be taken 100% for granted in 2025. Or maybe Javascript will be dead. I don't know, and I frankly don't care. I wrote Hotplate because I felt that this is what software _should_ be in 201X -- which is now.\r\n\r\n## Status:\r\n\r\n* Authentication: DONE\r\n* General code cleanup, and hotCoreMessags: UPCOMING\r\n* Write a sample, small application: UPCOMING\r\n* Writing the messenging framework: UPCOMING\r\n* Wire up the messenging framework with sample application: UPCOMING\r\n\r\n# Hotplate: a practical introduction\r\n\r\nHotplate itself is essentially a module loader and a system to invoke (or emit) and listen to messages. In theory, this is easy, and possible, by using existing functions (EventEmitter comes to mind). However, Hotplate goes much further than this: it allows you to define `init()` and `run()` functions, and -- more importantly -- it allows you to define initialisation order depending on which module needs what.\r\n\r\nFor example if a module calls the hook `someHook`, Hotplate will make sure that _all_ modules which implement `someHook` will be initialised _before_ the one emitting it. When `someHook` is emitted, hotplate will run `someHook` in _all_ modules that implement it (which at that point have been initialised), and will return the results to the caller. \r\n\r\nAt a very basic level, Hotplate is a system to define configuration variables, register modules, work out their initialisation order, allow those modules to call other module's hooks and get their results as an array. Every module on top of Hotplate follows these concepts.\r\n\r\nSome of the modules are considered \"core\" -- they all start with `hotCoreXXX`. They provide basic functionality for any \"software as a service\". Other modules are not part of core: for example the `hotDojoXXX` modules offer functionalities to use Dojo within Hotplate.\r\n\r\n## A note on the shown examples\r\n\r\nMy main aim is to always show fully working applications every time I show something. So, when you see something like **[starting_point]**, what I actually mean is the branch named `starting_point` of the repository [hotplate-examples](https://github.com/mercmobily/hotplate-examples). You can easily checkout that branch using Git, or browse it from GitHub.\r\n\r\nOnce you've downloaded the code, you will need to do the usual:\r\n\r\n    npm install\r\n\r\nAnd everything should work fine.\r\n\r\n## Getting started with Hotplate\r\n\r\nFirst of all, checkout **[starting_point]**. That's the basic, straight \"expressJS\" application that comes out of creating an application using the command `express`. The application's source code is pretty basic:\r\n\r\n    /**\r\n     * Module dependencies.\r\n     */\r\n\r\n    var express = require('express');\r\n    var http = require('http');\r\n    var path = require('path');\r\n\r\n    var app = express();\r\n\r\n    // all environments\r\n    app.set('port', process.env.PORT || 3000);\r\n    app.set('views', __dirname + '/views');\r\n    app.set('view engine', 'jade');\r\n    app.use(express.favicon());\r\n    app.use(express.logger('dev'));\r\n    app.use(express.bodyParser());\r\n    app.use(express.methodOverride());\r\n    app.use(app.router);\r\n    app.use(express.static(path.join(__dirname, 'public')));\r\n\r\n    // development only\r\n    if ('development' == app.get('env')) {\r\n      app.use(express.errorHandler());\r\n    }\r\n\r\n    http.createServer(app).listen(app.get('port'), function(){\r\n      console.log('Express server listening on port ' + app.get('port'));\r\n    });\r\n\r\nBasically, all of the template-oriented parts of Express (see: Jade) has been taken out. While you might still want to use Jade (that is, it's not forbidden to do so), keep in mind that Hotplate aims at creating one page, rich applications. So, chances are that you won't actually need to create \"pages\" as such in your application -- or, at least that's the hope.\r\n\r\nSo, now start integrating hotplate into your world.\r\n\r\n## Your first Hotplate module\r\n\r\nThe most important bit to add to your app.js file is the code that registers, initialises and runs Hotplate modules. That's easily done:\r\n(See **[first_hotplate]**)\r\n\r\n    // ** app.js\r\n\r\n    /**\r\n     * Module dependencies.\r\n     */\r\n\r\n    var express = require('express');\r\n    var http = require('http');\r\n    var path = require('path');\r\n    var hotplate = require('hotplate');\r\n    \r\n    var app = express();\r\n    \r\n    // Associate \"app\" to hotplate\r\n    hotplate.setApp( app );\r\n    \r\n    // Register Hotplate modules\r\n    // Uncomment the following two lines to add the two extra example modules\r\n\r\n    //hotplate.registerModule( 'module3', require('module3') );\r\n    //hotplate.registerModule( 'module2', require('module2') );\r\n    hotplate.registerModule( 'module1', require('module1') );\r\n \r\n    // Initialise the modules. Once done, continue with node's usual rock&roll\r\n    hotplate.initModules( function() {\r\n\r\n      // all environments\r\n      app.set('port', process.env.PORT || 3000);\r\n      app.use(express.logger('dev'));\r\n      app.use(express.bodyParser());\r\n      app.use(express.methodOverride());\r\n      app.use(app.router);\r\n\r\n      // development only\r\n      if ('development' == app.get('env')) {\r\n        app.use(express.errorHandler());\r\n      }\r\n    \r\n      // Run the modules. This will call `run` of each module. `run` can do all sorts\r\n      // of fancy things, like setting routes etc.\r\n      hotplate.runModules( function() {\r\n    \r\n        http.createServer(app).listen(app.get('port'), function(){\r\n          console.log('Express server listening on port ' + app.get('port'));\r\n        });\r\n      });\r\n    \r\n    }) // End of the rock&roll\r\n\r\n\r\nThere are five extra lines underneath `var app = express();`.\r\n\r\nThe first line (`setApp`) will store Express' `app` variable into Hotplate. This way, any module requiring Hotplate will also have access to `app` -- which means that they can do things like set routes etc.\r\n\r\nThe second line sets a Hotplate-wide variable, which will be available to any hotplate modules. I will explain this more in depth shortly.\r\n\r\nThe third line registers `module1` as a Hotplate module. For now, leave `module2` and `module2` out of the equation. They will be explained shortly.\r\n\r\nThe fourth line calls `hotplate.initModules()` which will run `init()` for every registered module. Since `init()` functions are asynchronous, a callback is called once all modules are initialised: that function will actually be the one continuing Express' initialisation (the usual bunch of `app.use()` etc.).\r\n\r\nFifth line: once all of the Express setting is out of the way, it's time to run `hotplate.runModules()` which will call the `run()` function in all registered modules.\r\n\r\nThe output from the server is interesting; it will look like this:\r\n\r\n    $ node app.js \r\n    Adding module1 to the full list of modules to initialise\r\n    FULL LIST OF MODULES TO INITIALISE IS: module1\r\n\r\n       Adding module1\r\n       Module module1's init() doesn't invoke anything and doesn't have any `after` list, it can be added right away\r\n       Called actuallyAdd() on module1\r\n       initStatus on module1 is: NOT_ADDED\r\n       Initialising module module1, since it hadn't been initialised yet\r\n       Module module1 set as 'ADDED'\r\n    ORDERED LIST: module1\r\n    Calling init call for module module1\r\n    The module 'module1' was initialised\r\n    Running hook \"run\" for module1\r\n    The module 'module1' was run\r\n    Express server listening on port 3000\r\n\r\nThe lines `The module 'module1' was initialised` and `The module 'module1' was run` actually came from the module's code, which is really simple:\r\n\r\n    // ** module1.js\r\n\r\n    // Require hotplate\r\n    var hotplate = require('hotplate');\r\n\r\n    // The `hooks` array defines this module's hooks\r\n    var hooks = exports.hotHooks = {};\r\n\r\n    hooks.init = function( done ){\r\n      console.log(\"The module 'module1' was initialised\");\r\n      done( null );\r\n    };\r\n\r\n    hooks.run = function( done ){\r\n      console.log(\"The module 'module1' was run\");\r\n      done( null );\r\n    }\r\n\r\n    hooks.something = function( passedValue, done ){\r\n      done( null,  {\r\n        returned: passedValue + 1\r\n      });\r\n\r\n    }\r\n\r\n## Making things more interesting: multiple modules\r\n\r\nThe main strength of Hotplate is the ability to register modules and define hooks. For example, you probably noticed that `module1` defines a hook called `something`, but no other module actually makes use of it at all. The hook is not very useful, but it will definitely help understand how Hotplate works.\r\n\r\nIn app.js, uncomment the line requiring and registering `module2`, which has the following code:\r\n\r\n    // ** module2.js\r\n\r\n    // Require hotplate\r\n    var hotplate = require('hotplate');\r\n    \r\n    // The `hooks` array defines this module's hooks\r\n    var hooks = exports.hotHooks = {};\r\n    \r\n    hooks.init = function( done ){\r\n      console.log(\"The module 'module2' was initialised\");\r\n    \r\n      var passedNumber = exports.passedNumber = 10;\r\n    \r\n      hotplate.invokeAll( 'something', passedNumber, function( err, results ){\r\n    \r\n        console.log( \"The variable results is: \" );\r\n        console.log( results );\r\n        done( null );\r\n      });\r\n    };\r\n    hooks.init.invokes = [ 'something' ];\r\n    \r\n    hooks.run = function( done ){\r\n    \r\n      console.log(\"The module 'module2' was run\");\r\n      done( null );\r\n    }\r\n\r\n\r\nAs you can see, a lot of interesting things are happening here. The second module has a more complex `init()` function, which will run `hotplate.invokeAll()` for the hook `something`. Also, the array `init.invokes` is defined as it's assigned an array containing `something` (the name of the hook). The `invokes` array is crucial to let Hotplate know that it will need to initialise all modules implementing the hook `something` _beforehand_  This will ensure that by the time `hook.something()` is called, every module is effectively fully initialised.\r\n\r\nThe output of `node app.js` is now very interesting:\r\n\r\n    $ node app.js \r\n    Adding module2 to the full list of modules to initialise\r\n    Adding module1 to the full list of modules to initialise\r\n    FULL LIST OF MODULES TO INITIALISE IS: module2,module1\r\n    \r\n       Adding module2\r\n       Module module2 calls invokeAll(something), checking which modules provide it, adding them first\r\n       ----Looking for modules that provide something...\r\n       Module module1 first then, checking if it has an init() function...\r\n       Module module1 DOES need to init(), considering adding it to the list of modules to load\r\n       ADDED!!! Adding module module1 to the sublist, its status was NOT_ADDED\r\n       LIST of dependencies for module2 is: [module1]. Reiterating self if necessary (intending in)\r\n    \r\n         Adding module1\r\n         Module module1's init() doesn't invoke anything and doesn't have any `after` list, it can be added right away\r\n         Called actuallyAdd() on module1\r\n         initStatus on module1 is: NOT_ADDED\r\n         Initialising module module1, since it hadn't been initialised yet\r\n         Module module1 set as 'ADDED'\r\n       THERE should be no un-init()ialised dependencies for module2 at this stage\r\n       Called actuallyAdd() on module2\r\n       initStatus on module2 is: NOT_ADDED\r\n       Initialising module module2, since it hadn't been initialised yet\r\n       Module module2 set as 'ADDED'\r\n    \r\n       Adding module1\r\n       Module module1's init() doesn't invoke anything and doesn't have any `after` list, it can be added right away\r\n       Called actuallyAdd() on module1\r\n       initStatus on module1 is: ADDED\r\n       Module module1 not initialised, as its status was ADDED, nothing to do!\r\n    ORDERED LIST: module1,module2\r\n    Calling init call for module module1\r\n    The module 'module1' was initialised\r\n    Calling init call for module module2\r\n    The module 'module2' was initialised\r\n    Running hook \"something\" for module1\r\n    The result of invokeAll('something') is:\r\n    [ { returned: 11 } ]\r\n    Running hook \"run\" for module2\r\n    The module 'module2' was run\r\n    Running hook \"run\" for module1\r\n    The module 'module1' was run\r\n\r\nThe module `module2` was registered _before_ `module1`. However, `module2`'s initialisation was delayed because of `init.invokes`, which had the hook `something`: this prompted Hotplate to load all modules implementing `something()` _first_ -- that is, `module1`.\r\n\r\n## One more way of setting priorities\r\n\r\nUsing `init.invokes` is very handy, as you don't have to worry much: you will know that all modulesthat implement a specific hook.\r\n\r\nThere is another way to set priorities: just define a `init.after` array, listing the list of modules that should be initialised before running your module's `init()` function.\r\n\r\nUncomment the line that requires and registers `module3` in your app.js file. Here is the code for `module3`:\r\n\r\n    // Require hotplate\r\n    var hotplate = require('hotplate');\r\n\r\n    // The `hooks` array defines this module's hooks\r\n    var hooks = exports.hotHooks = {};\r\n\r\n    hooks.init = function( done ){\r\n      console.log(\"The module 'module3' was initialised\");\r\n\r\n      var module2 = hotplate.getModule( 'module2' );\r\n      console.log( 'The module module2 has already been initialised, and exported passedNumber: ' + module2.passedNumber );\r\n      done( null );\r\n\r\n    };\r\n    hooks.init.after = [ 'module2' ];\r\n\r\n    hooks.run = function( done ){\r\n\r\n      console.log(\"The module 'module3' was run\");\r\n      done( null );\r\n    }\r\n\r\n\r\nHere you can see what's going on: `init.after` listed `module2`. So, `module2`'s `init()` function needs to be called before this module's `init()`. This module also uses the ` hotplate.getModule()` function, which is used to fetch a module previously registered in Hotplate.\r\n\r\nNote that the line `var module2 = hotplate.getModule( 'module2' );` wouldn't work reliably unless we know with _certainty_ that `module2` has been initialised -- and that's what that `init.after` is for.\r\n\r\nHere is what happens when you run the code:\r\n\r\n    $ node app.js \r\n    Adding module3 to the full list of modules to initialise\r\n    Adding module2 to the full list of modules to initialise\r\n    Adding module1 to the full list of modules to initialise\r\n    FULL LIST OF MODULES TO INITIALISE IS: module3,module2,module1\r\n    \r\n       Adding module3\r\n       Module module3 has a init.after list, honouring it: [ 'module2' ]\r\n       Module module2 first then, checking if it has an init() function...\r\n       Module module2 DOES need to init(), considering adding it to the list of modules to load\r\n       ADDED!!! Adding module module2 to the sublist, its status was NOT_ADDED\r\n       LIST of dependencies for module3 is: [module2]. Reiterating self if necessary (intending in)\r\n    \r\n         Adding module2\r\n         Module module2 calls invokeAll(something), checking which modules provide it, adding them first\r\n         ----Looking for modules that provide something...\r\n         Module module1 first then, checking if it has an init() function...\r\n         Module module1 DOES need to init(), considering adding it to the list of modules to load\r\n         ADDED!!! Adding module module1 to the sublist, its status was NOT_ADDED\r\n         LIST of dependencies for module2 is: [module1]. Reiterating self if necessary (intending in)\r\n    \r\n           Adding module1\r\n           Module module1's init() doesn't invoke anything and doesn't have any `after` list, it can be added right away\r\n           Called actuallyAdd() on module1\r\n           initStatus on module1 is: NOT_ADDED\r\n           Initialising module module1, since it hadn't been initialised yet\r\n           Module module1 set as 'ADDED'\r\n         THERE should be no un-init()ialised dependencies for module2 at this stage\r\n         Called actuallyAdd() on module2\r\n         initStatus on module2 is: NOT_ADDED\r\n         Initialising module module2, since it hadn't been initialised yet\r\n         Module module2 set as 'ADDED'\r\n       THERE should be no un-init()ialised dependencies for module3 at this stage\r\n       Called actuallyAdd() on module3\r\n       initStatus on module3 is: NOT_ADDED\r\n       Initialising module module3, since it hadn't been initialised yet\r\n       Module module3 set as 'ADDED'\r\n    \r\n       Adding module2\r\n       Module module2's not initialised as it's status is already ADDED, doing nothing\r\n    \r\n       Adding module1\r\n       Module module1's init() doesn't invoke anything and doesn't have any `after` list, it can be added right away\r\n       Called actuallyAdd() on module1\r\n       initStatus on module1 is: ADDED\r\n       Module module1 not initialised, as its status was ADDED, nothing to do!\r\n    ORDERED LIST: module1,module2,module3\r\n    Calling init call for module module1\r\n    The module 'module1' was initialised\r\n    Calling init call for module module2\r\n    The module 'module2' was initialised\r\n    Running hook \"something\" for module1\r\n    The result of invokeAll('something') is: \r\n    [ { returned: 11 } ]\r\n    Calling init call for module module3\r\n    The module 'module3' was initialised\r\n    The module module2 has already been initialised, and exported passedNumber: 10\r\n    Running hook \"run\" for module3\r\n    The module 'module3' was run\r\n    Running hook \"run\" for module2\r\n    The module 'module2' was run\r\n    Running hook \"run\" for module1\r\n    The module 'module1' was run\r\n    Express server listening on port 3000\r\n\r\n\r\nThe log line `Module module3 has a init.after list, honouring it: [ 'module2' ]` shows that `init.after` does what it advertises: it makes sure that `module3` is initialised _before_ `module2`. Then, `module2` itself calls the hook `something` which means that all modules implementing the hok `something` will need to be initialised first -- that is, `module1`.\r\n\r\n## More Hotplate features\r\n\r\n### Setting Hotplate-wide variables\r\n\r\nYou can set Hotplate-wide variables in your app.js file (or anywhere, really) and read those values from your modules. In the example `app.js` file, there is the following line:\r\n\r\n\r\nIn the example module `module4` you have:\r\n\r\n    // Require hotplate\r\n    var hotplate = require('hotplate');\r\n\r\n    // The `hooks` object defines this module's hooks\r\n    var hooks = exports.hotHooks = {};\r\n\r\n    hooks.init = function( done ){\r\n      console.log(\"The module 'module4' was initialised\");\r\n      console.log(\"The variable globalSetting is:\");\r\n      console.log( hotplate.get( 'globalSetting' ) );\r\n    \r\n      done( null );\r\n    };\r\n\r\nThis is probably the smallest module ever written! It shows how the module can access `globalSettings` with `hotplate.get()`. Note that modules will tend to create variables with a namespace. So, a Hotplate-wide variable would be called, in this case, `module1/globalSetting`. This is just a naming convention, not necessarily forced upon you.\r\n\r\n### Mass-registering of modules\r\n\r\nNormally, you would end up registering a lot of modules rather than just a couple. Hotplate's core for example is made up of a number of highly specialised, small modules. Requiring and registering each one of them would me inconvenient at best. That's why you can just do this:\r\n\r\n\r\n    hotplate.registerAllEnabledModules( /^module/, __dirname + '/node_modules' );\r\n\r\nThe first parameter `/^module/` is a regexp which will filter which modules you actually want to load. The second parameter, `__dirname + '/node_modules'`, is the _full_ path of the modules you want to load. It's important that you do pass the module's full path here, which is why I used `__dirname` (which is `app.js`'s full path).\r\n\r\nIn actual fact, a more common scenario would be requiring all of Hotplate's core modules:\r\n\r\n    hotplate.registerAllEnabledModules( /^hotCore/ );\r\n\r\nIn this case, the second parameter is optional (it defaults to Hotplate's `node_modules` directory).\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}