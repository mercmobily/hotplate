
define( [

  "dojo/_base/declare"
, "dojo/topic"
, "dojo/_base/lang"
, "dojo/aspect"
, "dojo/when"
, "dojo/topic"

, "hotplate/hotClientDojo/stores/stores"
, 'hotplate/hotClientDojo/globals/globals'

], function(

  declare
, topic
, lang
, aspect
, when
, topic

, stores
, globals

){

  // When a 'resetStores' topic is published, all store's cache is deleted (as it's
  // most likely to be outdated)
  topic.subscribe( 'resetStores', function(){

    // Sets 'configStores' as the hash containing the config stores (they will NOT
    // get zapped)
    var configStores = {};
    if( typeof( vars['hotCoreStoreConfig'] ) === 'object' && typeof( vars['hotCoreStoreConfig'] ) !== null ){
      if( typeof( vars['hotCoreStoreConfig']['configStores'] ) === 'object' && typeof( vars['hotCoreStoreConfig']['configStores'] ) !== null ){
        configStores = vars['hotCoreStoreConfig']['configStores'];
      }
    }
 
    var allDefinedStores = stores();
    for( var storeName in allDefinedStores ){
      var definedStores = allDefinedStores[ storeName ];

      // Zap all stores, except the config ones
      for( var target in definedStores ){
        var store = definedStores[ target ];
        if( ! configStores[ store.storeName ] ){

          if( store.memCache ) store.memCache.setData( [] );
        }
      } 
     
    };
  });

  // Utility function used to check if a target's placeholding elements
  // match a object's keys. For example:
  // * target: '/workspaces/workspaceId/users'
  // * targetHash: { workspaceId: 10 }
  // THEN:
  // * o == { user: 'Tony', workspaceId: 11} // RETURN FALSE
  // * o == { user: 'Tony', workspaceId: 10} // RETURN TRUE
  var objectValuesIn = function( target, targetHash, o ){

    // Get all tokens in the target.
    var elements = target.match(/:(\w*)/g);

    // No tokens: true by principle
    if( ! elements ) return true;
  
    // Go through tokens, and check that object being worked on
    // matches the passed hash for that store
    var equal = true;
    for( var i = 0, l = elements.length; i < l; i ++){
      var token = elements[ i ].substr( 1 );
      if( targetHash[ token ] != o[ token ] ){
        equal = false;
        break;
      }
    }

    return equal;
  }



  topic.subscribe( 'hotplate/hotClientDojo/newStore', function( storeName, store ){

    store.on( 'add,update,remove', function( event ){

      var topicType, topicEvent = {};

      // If an event has `remote` set, it means that it was the result of a remote comet message: this topic
      // would be a duplicate. So, don't.
      if( event.remote ) return;

      // Publish the topic depending on the event. This is to make sure that the application
      // can listen to storeRecord????? events, and get both the local ones and the remote ones
      // treating them the same way. This is especially useful if a developer wants to monitor
      // changes to a store _globally_, without running `on()` for specific instances
      var topicType = event.type === 'add' ? 'storeRecordCreate' : (  event.type === 'update' ? 'storeRecordUpdate' : 'storeRecordRemove' );
     
      // Creating the basic topic event
      topicEvent = { type: topicType, storeName: storeName, target: event.target, targetId: event.target[ store.idProperty ], beforeId: event.beforeId };

      topic.publish( topicType, globals.userId, topicEvent, false )

    });
  });



  // Make sure that events are broadcast to alsoNotify stores and that alsoNotify store's
  // cache is updated accordingly

  topic.subscribe( 'hotplate/hotClientDojo/newStore', function( storeName, store ){

    store.on( 'add,update,remove', function( event ){

      if( event.withinAlsoStoreNotification ) return;

      // Check if store.alsoNotify has elements -- if it does, they are "sibling" stores
      if( store.alsoNotify ){

        // Make up the new, enriched, event
        var newEvent = lang.mixin( event );
        newEvent.withinAlsoStoreNotification = true;

        // For each entry in alsoNotify, get the list of store instances (each one
        // might have a different target)
        for( var i = 0, l = store.alsoNotify.length; i < l; i ++){
          var alsoStores = stores( store.alsoNotify[ i ] );

          if( alsoStores ){

            // Go through each store instance
            for( var k in alsoStores ){
              var alsoStore = alsoStores[ k ];

              // If the paramIds matches, then add the item to the alsoStore cache
              // and issue a notify for the alsoStore for the object
              if( objectValuesIn( alsoStore.target, alsoStore.targetHash, event.target ) ){
                if( event.type == 'add' || event.type == 'update' ){

                  var options = {};
                  if( event.beforeId ) beforeId = event.beforeId;

                  alsoStore.memCache.put( event.target, options );
                  alsoStore.emit( newEvent );
              
                } else {
                  alsoStore.memCache.remove( event.target );
                  alsoStore.emit( newEvent );
                }
              }
            }
          }
        }
      }
    });
  });

  // CHANGES FROM THE OUTSIDE
  //
  // Update local stores according to Comet messages
  
  topic.subscribe('storeRecordUpdate', function( from, message, remote ){

    // It will only deal with remote events, local ones are totally ignored
    if( ! remote ) return;

    var definedStores = stores( message.storeName );
    for( var k in definedStores ){
      var store = definedStores[ k ];

      if( objectValuesIn( store.target, store.targetHash, message.target ) ){

        // Place the item in the right spot in the cache
        // Note that `message` is passed as the `put()`'s parameters option
        // since it will contain objectId
        if( store.memCache) store.memCache.put( message.target, message );

        // This is here to prevent this very file from fire a topic as well
        message.remote = true;

        // Emit the update event, which will effectively notify all tracking widgets
        store.emit( 'update', message );

      }
    }
  });

  topic.subscribe('storeRecordCreate', function( from, message, remote ){

    // It will only deal with remote events, local ones are totally ignored
    if( ! remote ) return;

    var definedStores = stores( message.storeName );
    for( var k in definedStores ){
      var store = definedStores[ k ];

      if( objectValuesIn( store.target, store.targetHash, message.target ) ){

        // Place the item in the right spot in the cache
        // Note that `message` is passed as the `put()`'s parameters option
        // since it will contain objectId
        if( store.memCache) store.memCache.put( message.target, message );

        // This is here to prevent this very file from fire a topic as well
        message.remote = true;

        // Emit the update event, which will effectively notify all tracking widgets
        store.emit( 'add', message );
      }
    }
  });

  topic.subscribe('storeRecordRemove', function( from, message, remote ){

    // It will only deal with remote events, local ones are totally ignored
    if( ! remote ) return;

    var definedStores = stores( message.storeName );
    for( var k in definedStores ){
      var store = definedStores[ k ];

     if( objectValuesIn( store.target, store.targetHash, message.target ) ){

        // Make up removeParameters. Since I need an extra attribute, `id`, I make a new
        // object so that I don't modify the message object (which would be probably fine,
        // but dirty and side-effect-ish)
        var removeParameters = {};
        for( var k in message ) removeParameters[ k ] = message[ k ];
        removeParameters.id = message.targetId;

        // Delete the element from the cache
        if( store.memCache) store.memCache.remove( message.targetId, removeParameters );

        // This is here to prevent this very file from fire a topic as well
        message.remote = true;

        // Emit the update event, which will effectively notify all tracking widgets
        store.emit( 'remove', removeParameters );
      }
    }
  });

  return {};

});


