"use strict";

var dummy
  , hotplate =  require('hotplate')
  , declare = require( 'simpledeclare' )
  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreStoreRegistry = require('hotCoreStoreRegistry')
  , hotCoreMultiHome = require('hotCoreMultiHome')
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )
;

exports.get = function( done ){

  var classes = {};
  var sharedValidators = {};

  hotplate.hotEvents.emit('sharedFunctions', function( err, sharedFunctions) {
    if( err ){
      done( err );
    } else {

      // Gets the results, and adds them to the sharedValidators hash which
      // will then get used
      sharedFunctions.onlyResults().forEach( function( functions ){
        for( var k in functions ){
          // If it ends with "Validator", then it's a validator
          if( k.indexOf('Validator', k.length - 'Validator'.length) !== -1 ){
            sharedValidators[ k ] = functions[ k ];
          }
        }
      });

      classes.HotSchemaMixin = declare( null, {

        sharedValidatorTypeParam: function( p ){
          if( typeof( p.parameterValue ) !== 'string' )
            throw( new Error("Validator needs to be a string, found: " + typeof( p.parameterValue ) ) );

     
          var f = sharedValidators[ p.parameterValue + "Validator" ];
 
          if( f && ! f( p.value ) ){
            var msg = f( false );
            p.errors.push( { field: p.fieldName, message: msg, mustChange: true } );
          }
        }
      });

      // Basic schema with info defined in config
      classes.BasicSchema = declare( [ SimpleSchema, hotplate.config.get( 'hotplate.SchemaMixin') ] );

      // Advanced schema mixin with validators
      classes.HotSchema = declare( [ classes.BasicSchema, classes.HotSchemaMixin ] );


      classes.HotStoreMixin = declare( null, {

        killComet: false,
        chainErrors: 'all',

        hotGlobalBroadcast: false,

        echoAfterPutNew: true,
        echoAfterPutExisting: true,
        echoAfterPost: true,

        handleDelete: false,

        // This is 100% not needed as chainError is set to 'all', logging happens there
        //logError: function( error ){
        //  hotCoreServerLogger.log( error );
        //},

        _getTabId: function( req ){

          // If the tab header wasn't there, then there is no way to broadcast -- abord
          if( typeof( req ) === 'undefined' ) return null;

          var tabId = req.headers['x-hotplate-tabid'];
          if( tabId == '' ){
            tabId = null;
          }
          return tabId; 
        },


        // This function can be used to trigger a change event manually after a non-store change to the DB
        // ---
        // In `options`, the following are worked out from `request` if they aren't set:
        // * `options.userId`
        // * `options.tabId`
        // * `options.beforeId

        broadcastStoreChanges: function( request, type, objectId, object, options, cb ){

          var userId, tabId;
          var makeTabIdHash;
          var message;

          // No comet required (from the option, or for the store's own request
          if( this.killComet || request.killComet ) return cb( null );

          // Make up basic message variable
          message = { type: type, storeName: this.storeName, targetId: objectId, target: object };

          // userId, tabId, beforeId are inferred from `request` if 
          // they weren't passed
          if( typeof( options.userId ) === 'undefined' ){
            userId = request._req && request._req.session && request._req.session.userId || undefined;
          } else {
            userId = options.tabId;
          }
          if( typeof( options.tabId ) === 'undefined' ){
            tabId = this._getTabId( request._req );
          } else {
            tabId = options.tabId;
          }
          if( typeof( options.beforeId ) === 'undefined' ){

            // Work out beforeId, either from putBefore (which will have an ID)
            // or from putDefaultPosition (if set to "end", beforeId will be `null`
            //
            // NOTE: original dstore Rest calls where defaultNewToStart and beforeId aren't set (most
            // common case) will STILL end up with options.beforeId set to NULL in the broadcast.
            // This is fine, since options.beforeId === null AND 
            // ( potions.beforeId === undefined && ! defaultNewToStart) are fully equivalent
            if( typeof( request.options.putBefore ) !== 'undefined' ){
              message.beforeId = request.options.putBefore;
            } else {
              if( request.options.putDefaultPosition  === 'end' ) message.beforeId = null;  
            }
          }

          // makeTabIdHash will be passed depending on hotCoreMultiHome
          if( hotplate.config.get( 'hotCoreMultiHome.enabled' ) ) makeTabIdHash = hotCoreMultiHome.makeTabIdHashForMultihome;
          

          // Enrich message with options passed
          // NOTE: setting an option as `undefined` will have the effect of DELETING it
          // from the message.
          // ALSO: tabId and userId are _not_ copied over to the messages as they would be redundant
          for( var k in options ){
            if( typeof( options[ k ]) === 'undefined' ){
              delete message[ k ];
            } else {
              if( k !== 'tabId' && k !== 'userId' ) message[ k ] = options[ k ];
            }
          }

          hotplate.hotEvents.emit('cometBroadcast', userId, tabId, makeTabIdHash, message, cb );
        },

        afterEverything: function f( request, method, p, done ){
          var self = this;

          this.inheritedAsync( f, arguments, function( err ){
            if( err ) return done( err );

            if( method === 'getQuery' || method === 'get' ) return done( null );

            //var d =  ( method === 'putExisting' ? p.docAfter : p.doc );    
            var d = p.preparedDoc;
            
            var m;
            switch( method ){
              case 'putExisting':
                m = 'storeRecordUpdate';
              break;
              case 'putNew':
              case 'post':
                m = 'storeRecordCreate';
              break;
              case 'delete':
                m = 'storeRecordRemove';              
              break;
            }

            self.broadcastStoreChanges( request, m, d[ self.idProperty], d, {}, done );
          });
        },

       
      });


      // Sets the DB Layer
      var DbLayer = declare([ SimpleDbLayer, hotplate.config.get('hotplate.DbLayerMixin') ], {
        db: hotplate.config.get( 'hotplate.db' ) 
      });

      // Creates a basic DB store based on that layer
      classes.BasicDbStore = declare( [ JsonRestStores, JsonRestStores.SimpleDbLayerMixin ], {
        DbLayer: DbLayer,
      });

      // Creates the HotStore: the basic DB store with HotStoreMixin
      classes.HotStore = declare( [ classes.BasicDbStore, classes.HotStoreMixin ]);

      done( null, classes );

    }
  });

}


/*
  IN SHORT:
  * To WRITE (putExisting, putNew, post, delete), userId needs to match logged in user
*/
exports.BasicPermissionsMixin = declare( null, {

  _checkUserId: function( request, cb ){

    // User is not logged in: fail
    if( ! request._req.session.userId ) return cb( new self.UnauthorizedError() );

    // The request doesn't include a userId: pass it through (nothing to compare against)
    if( ! request.params.userId ) return cb( null, true );

    // userId is different to session's: fail
    if( request.params.userId.toString() !== request._req.session.userId.toString() ){
      return cb( null, false );
    }

    // Any other cases: pass
    cb( null, true );
        
  },

  checkPermissions: function f( request, method, p, cb ){
    
    this.inheritedAsync( f, arguments, function( err, res ){
      if( err ) return cb( err );
      if( ! res ) return cb( null, false );

      // getXXX methods are not handled
      if( method === 'get' || method === 'getQuery' ) return cb( null, true );

      self._checkUserId( request, cb );
    });
  },

});

/*
  IN SHORT:
  * To READ (get, getQuery), userId needs to match logged in user
*/
exports.PrivateUserDataPermissionsMixin = declare( null, {

  _checkUserIdForJsonRestStores: function( request, cb ){
    var self = this;

    // User is not logged in: fail
    if( ! request._req.session.userId ) return cb( new self.UnauthorizedError() );

    // The request doesn't include a userId: pass it through (nothing to compare against)
    if( ! request.params.userId ) return cb( null, true );

    // userId is different to session's: fail
    if( request.params.userId.toString() !== request._req.session.userId.toString() ){
      return cb( null, false );
    }

    // Any other cases: pass
    cb( null, true );
    
  },

  checkPermissions: function f( request, method, p, cb ){
    var self = this;

    this.inheritedAsync( f, arguments, function( err, res ){
      if( err ) return cb( err );
      if( ! res ) return cb( null, false );

      // Only getXXX methods are handled
      if( method !== 'get' && method !== 'getQuery' ) return cb( null, true );

      self._checkUserIdForJsonRestStores( request, cb );
      
    });
  },
 
});



