{
  "name": "eventemittercollector",
  "description": "An implementation of EventEmitter that allows you to collect the listeners' results",
  "keywords": [
    "events",
    "async"
  ],
  "main": "EventEmitterCollector.js",
  "version": "0.3.13",
  "private": false,
  "repository": {
    "type": "git",
    "url": "git://github.com/mercmobily/EventEmitterCollector.git"
  },
  "author": {
    "name": "Tony Mobily"
  },
  "dependencies": {
    "simpledeclare": "0.3.x",
    "async": "~1.5.2"
  },
  "readme": "EventEmitterCollector\n=====================\n\nIn Nodejs, the [EventEmitter](http://nodejs.org/api/events.html) constructor is great in most situations: it fires up events, and allows others to listen for those events and act appropriately.\n\nThere is one use-case that is completely failed by node's EventEmitter: when you want to fire up an event, and you actually want to know _what your listeners have to say about it_. This is imensely useful for example:\n\n* In plugins. You fire up an event called `gather files to send`, and then each function registered with that EventEmitter will add files to the list of the ones to send. Note that \n* In cases where you want to check if an event was handled appropriately. For example, each listener could return `true` of `false` and you could decide what to do in case some of them didn't work (maybe warn the user?)\n\nIn these situations, and possibly others I haven't thought of, \"welcome to EventEmitterCollector\". \n\n## The API\n\nThe EventEmitterCollector constructor can be used just like EventEmitter, adding \"Collect\" to the methods' signature. Please note that EventEmitter's API is not 100% emulated (although it _can_ be if there is enough interest in this module). At the moment, it supports:\n\n* `onCollect()` (with `addListenerCollect()` as an alias )\n* `emitCollect()`\n\nIt does _not_ implement:\n\n* `once()`\n* `removeListener()`\n* `removeAllListeners()`\n* `listeners()`\n* `setMaxListeners()`\n\nIt also adds a specific way to emit events belonging to a specific `module`:\n\n* `emitCollectModule()` \n\nEvent emitter implementation that will actually collect the listener's results and return them\n\n## Usage\n\nHere is the most basic usage of EventEmitterCollector:\n\n    var EventEmitterCollector = require('eventemittercollector');\n\n    var as = new EventEmitterCollector();\n\n    as.onCollect( 'event1', function( done ){\n      console.log(\"Called event 'event1' (first listener)\");\n      done( null, 'event1, first listener' );\n    });\n\n    as.onCollect( 'event1', function( done ){\n      console.log(\"Called event 'event1' (second listener)\");\n      done( null, 'event1, second listener' );\n    });\n\n    as.emitCollect( 'event1', function( err, results ){\n      console.log( results );\n    });\n\nThe result:\n\n    Called event 'event1' (first listener)\n    Called event 'event1' (second listener)\n\n    [ { module: 'global', result: 'event1, first listener' },\n      { module: 'global', result: 'event1, second listener' } ]\n\nThe results are grouped as an array of objects, where the first attribute is `module` (set by default as `global`) and the second one is `result` (which is whatever was returned by the listener).\n\nIf any one of the listeners sets the `err` variable, other missing listeners will _not_ be invoked and the callback called by `emit()` will hav ethe error set:\n\n    var EventEmitterCollector = require('eventemittercollector');\n\n    var as = new EventEmitterCollector();\n\n    as.onCollect( 'event1', function( done ){\n      console.log(\"Called event 'event1' (first listener)\");\n      done( new Error(\"Did not work\") );\n    });\n\n    as.onCollect( 'event1', function( done ){\n      console.log(\"Called event 'event1' (second listener)\");\n      done( null, 'event1, second listener' );\n    });\n\n    as.emitCollect( 'event1', function( err, results ){\n      console.log( \"Error:\");\n      console.log( err );\n    });\n\nThe result will be:\n\n    Called event 'event1' (first listener)\n    [Error: Did not work]\n\nSo, a single listener failing _does_ stop the flow and _does_ mean that something went horribly wrong and should be dealt with.\n\n## Using \"modules\"\n\nEventEmitterCollector was first developed as a way to write \"modules\", and allow those modules to emit events identifying themselves as \"that particular module\".\n\nIf you are collecting results from listeners, there are many cases where you want a result to be associated to a specific listener.\n\nSo, you can associate a \"module\" (or, call it an \"id\") to a listener:\n\n    var EventEmitterCollector = require('eventemittercollector');\n\n    var as = new EventEmitterCollector();\n\n    as.onCollect( 'event1', 'someId', function( done ){\n      console.log(\"Called event 'event1' (first listener)\");\n      done( null, 'event1, first listener' );\n    });\n\n    as.onCollect( 'event1', 'someId', function( done ){\n      console.log(\"Called event 'event1' (second listener)\");\n      done( null, 'event1, second listener' );\n    });\n\n    as.emitCollect( 'event1', function( err, results ){\n      console.log( results );\n    });\n\nThe result is:\n\n    Called event 'event1' (first listener)\n    Called event 'event1' (second listener)\n\n    [ { module: 'someId', result: 'event1, first listener' },\n      { module: 'someId', result: 'event1, second listener' } ]\n\nYou can obviously have a mixture of module names as your listeners:\n\n\n    var EventEmitterCollector = require('eventemittercollector');\n\n    var as = new EventEmitterCollector();\n\n    as.onCollect( 'event1', 'module1', function( done ){\n      console.log(\"Called event 'event1' (first listener)\");\n      done( null, 'event1, first listener' );\n    });\n\n    as.onCollect( 'event1', 'module2', function( done ){\n      console.log(\"Called event 'event1' (second listener)\");\n      done( null, 'event1, second listener' );\n    });\n\n    as.onCollect( 'event1', function( done ){\n      console.log(\"Called event 'event1' (third listener)\");\n      done( null, 'event1, third listener' );\n    });\n\n    as.emitCollect( 'event1', function( err, results ){\n      console.log( results );\n    });\n\nThe result:\n\n    Called event 'event1' (first listener)\n    Called event 'event1' (second listener)\n    Called event 'event1' (third listener)\n\n    [ { module: 'module1', result: 'event1, first listener' },\n      { module: 'module2', result: 'event1, second listener' },\n      { module: 'global', result: 'event1, third listener' } ]\n\nAs you can see, the third listener didn't specify a module name. So, it defaulted to \"global\".\n\n## Parameters to events\n\nYou can emit an event and pass it arguments, which will then passed to your listeners. Watch out: the number of arguments _must_ be the same for your emitters and your listeners.\n\nSo, for example:\n\n    var EventEmitterCollector = require('eventemittercollector');\n\n    var as = new EventEmitterCollector();\n\n    as.onCollect( 'event1', 'module1', function( n1, n2, done ){\n      console.log(\"Called event 'event1'i (first listener)\");\n      console.log(\"n1: \" + n1 + \"; n2: \" + n2 );\n      done( null, 'event1, first listener' );\n    });\n\n    as.onCollect( 'event1', 'module2', function( n1, n2, done ){\n      console.log(\"Called event 'event1' (second listener)\");\n      console.log(\"n1: \" + n1 + \"; n2: \" + n2 );\n      done( null, 'event1, second listener' );\n    });\n\n    as.onCollect( 'event1', function( n1, n2, done ){\n      console.log(\"Called event 'event1' (third listener)\");\n      console.log(\"n1: \" + n1 + \"; n2: \" + n2 );\n      done( null, 'event1, third listener' );\n    });\n\n    as.emitCollect( 'event1', 10, 20, function( err, results ){\n      console.log( results );\n    });\n\n\nThe result:\n\n    Called event 'event1' (first listener)\n    n1: 10; n2: 20\n    Called event 'event1' (second listener)\n    n1: 10; n2: 20\n    Called event 'event1' (third listener)\n    n1: 10; n2: 20\n    [ { module: 'module1', result: 'event1, first listener' },\n      { module: 'module2', result: 'event1, second listener' },\n      { module: 'global', result: 'event1, third listener' },\n\n\n## Emit only to specific modules\n\nSometimes, you might want to emit an event but decide to invoke listeners associated to specific modules. In these cases, you would use `emitCollectModule()`:\n\n\n    var EventEmitterCollector = require('eventemittercollector');\n\n    var as = new EventEmitterCollector();\n\n    as.onCollect( 'event1', 'module1', function( done ){\n      console.log(\"Called event 'event1' (first listener)\");\n      done( null, { a1: 'event1, first listener' }  );\n    });\n\n    as.onCollect( 'event1', 'module2', function( done ){\n      console.log(\"Called event 'event1' (second listener)\");\n      done( null, { a1: 'event1, second listener' } );\n    });\n\n    as.onCollect( 'event1', 'module2', function( done ){\n      console.log(\"Called event 'event1' (third listener)\");\n      done( null, { a2: 'event1, third listener' } );\n    });\n\n    as.onCollect( 'event1', function( done ){\n      console.log(\"Called event 'event1' (fourth listener)\");\n      done( null, { a2: 'event1, fourth listener' } );\n    });\n\n    as.emitCollectModule( 'event1', 'module2', function( err, results ){\n      console.log( results );\n    });\n\nResult:\n\n    Called event 'event1' (second listener)\n    Called event 'event1' (third listener)\n\n    [ { module: 'module2', result: { a1: 'event1, second listener' } },\n      { module: 'module2', result: { a2: 'event1, third listener' } },\n\nOnly the listeners associated to `module2` were called.\n\n\n## Helper functions in results\n\nThe results array can be boring to manipulate. Sometimes, you just want the results without worrying about what the module name is, for example. The good news is that the `results` array comes with some handy helper functions:\n\n### `onlyResults`\n\nThis helper function will strip everything from the array, except the actual results. See:\n\n    var EventEmitterCollector = require('eventemittercollector');\n\n    var as = new EventEmitterCollector();\n\n    as.onCollect( 'event1', 'module1', function( done ){\n      console.log(\"Called event 'event1' (first listener)\");\n      done( null, 'event1, first listener' );\n    });\n\n    as.onCollect( 'event1', 'module2', function( done ){\n      console.log(\"Called event 'event1' (second listener)\");\n      done( null, 'event1, second listener' );\n    });\n\n    as.onCollect( 'event1', 'module2', function( done ){\n      console.log(\"Called event 'event1' (third listener)\");\n      done( null, 'event1, third listener' );\n    });\n\n    as.onCollect( 'event1', function( done ){\n      console.log(\"Called event 'event1' (fourth listener)\");\n      done( null, 'event1, fourth listener' );\n    });\n\n    as.emitCollect( 'event1', function( err, results ){\n      console.log( results.onlyResults() );\n    });\n\nThe result:\n\n    Called event 'event1' (first listener)\n    Called event 'event1' (second listener)\n    Called event 'event1' (third listener)\n    Called event 'event1' (fourth listener)\n\n    [ 'event1, first listener',\n      'event1, second listener',\n      'event1, third listener',\n      'event1, fourth listener' ]\n\n### `groupByModule()`\n\nThis helper function will group results by module:\n\n    var EventEmitterCollector = require('eventemittercollector');\n\n    var as = new EventEmitterCollector();\n\n    as.onCollect( 'event1', 'module1', function( done ){\n      console.log(\"Called event 'event1' (first listener)\");\n      done( null, 'event1, first listener' );\n    });\n\n    as.onCollect( 'event1', 'module2', function( done ){\n      console.log(\"Called event 'event1' (second listener)\");\n      done( null, 'event1, second listener' );\n    });\n\n    as.onCollect( 'event1', 'module2', function( done ){\n      console.log(\"Called event 'event1' (third listener)\");\n      done( null, 'event1, third listener' );\n    });\n\n    as.onCollect( 'event1', function( done ){\n      console.log(\"Called event 'event1' (fourth listener)\");\n      done( null, 'event1, fourth listener' );\n    });\n\n    as.emitCollect( 'event1', function( err, results ){\n      console.log( results.groupByModule() );\n    });\n\n\nThe result:\n\n    Called event 'event1' (first listener)\n    Called event 'event1' (second listener)\n    Called event 'event1' (third listener)\n    Called event 'event1' (fourth listener)\n\n    { module1: [ 'event1, first listener' ],\n      module2: [ 'event1, second listener', 'event1, third listener' ],\n      global: [ 'event1, fourth listener' ] }\n\nNote that the result is an associative array, with each element being an array of results.\n\n\n## Afterword\n\nYou can argue that this module is not an EventEmitter at all: some argue that events are by definition \"fire-and-forget\". The API also differs from EventEmitter's, \n\nI feel that the concepts behind EventEmitterCollectors are very similar to EventEmitter, and that fire-and-forget is only an opinion: wanting to know the results of an event is a fair enough requirement in some cases, even if it's just to know that all listeners actually managed to do what they were meant to do. This is especially true for cases where the success of each listener is critical (let alone the gathering of the results of each listener).\n\n\n\n",
  "readmeFilename": "README.md",
  "gitHead": "1b492887eb0aa969e6abac7500cc0a7ee115d6c7",
  "bugs": {
    "url": "https://github.com/mercmobily/EventEmitterCollector/issues"
  },
  "homepage": "https://github.com/mercmobily/EventEmitterCollector#readme",
  "_id": "eventemittercollector@0.3.13",
  "scripts": {},
  "_shasum": "3d376af615cec34147c48dc98a7675935b3a2657",
  "_from": "eventemittercollector@>=0.3.0 <0.4.0"
}
