{
  "name": "simpledblayer",
  "description": "Simple, generic, no fuss DB layer for NodeJS",
  "keywords": [
    "javascript",
    "database",
    "mongo"
  ],
  "main": "SimpleDbLayer.js",
  "version": "0.3.29",
  "private": false,
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mercmobily/simpledblayer.git"
  },
  "author": {
    "name": "Tony Mobily"
  },
  "dependencies": {
    "simpledeclare": "0.3.x",
    "eventemittercollector": "0.3.x",
    "async": "~1.5.2",
    "debug": "~2.2.0"
  },
  "devDependencies": {
    "simpleschema": "0.3.x"
  },
  "readme": "Simpledblayer\n=============\n\nSimpleDbLayer is a module that allows you to connect and query a DB server. It was created specifically to provide a thin database layer for [JsonRestStores](https://github.com/mercmobily/JsonRestStores).\n\nFeatures:\n\n* Complex queries, with nested AND and OR statements, as well as ranges and sorting\n* Full cursor support, including `each()` and a way to break out of `each()`\n* Schema to cast/validate fields, using [simpleschema](https://github.com/mercmobily/simpleschema).\n* It allows 1-level joins in queryes and data fetching; joins are defined right in the table definition.\n* The 1-level join is in the table definition because, using MongoDB, children data will be _preloaded_ and automatically updated. This means that you will be able to fetch the record of a person, with all associated addresses, email addresses, phone numbers, etc. _in one single DB operation_.\n* It is written with very simple, Object Oriented code using [simpledeclare](https://github.com/mercmobily/simpleDeclare)\n* For each managed database table, there is -- and there _can be_ -- only one plain Javascript object which will manipulate that table.\n* Positioning management. You can define the position of a record, which will affect the order they are returned from a query when no sorting is specified (very useful when implementing Drag&Drop in your web application)\n* Semi-automatic index generation. Indexes will be created automatically as much as possible. For example, all fields marked as `searchable` will be defined as an index, as well as indexes for positioning.\n\nLimitations:\n\n* It doesn't manage connections. You will have to create a connection to the database and pass it to it. This is due to the module's philosophy of getting in the way as little as possible.\n* `update` and `delete` statements don't accept `sort` and `range` (they will either affect one record, or all of them). This is mainly to make sure that pre-caching of children (join/lookup) tables is workable.\n* It doesn't implement Models constructors and object types as many other ORMs do (mainly because SimpleDbLayer is _not_ an ORM, but a thin layer around databases).\n\nOnce again, all these features (and limitations) are tailored around the fact that SimpleDbLayer is a module that enables [JsonRestStores](https://github.com/mercmobily/JsonRestStores) to have several (thin) database layers.\n\n\nDOCUMENTATION TODO: Specify that SimpleDbLayer inherits from EventEmitterCollector, and emits collecting events before and after operations. This allows field manipulation on the fly.\n\n\n# Database-specific adapters\n\nAt the moment, here is the list of database-specific adapters:\n\n* MongoDB -- [simpledblayer-mongo](https://github.com/mercmobily/simpledblayer-mongo). In MongoDB joins are implemented with pre-caching, meaning that 1:n relations are pre-loaded in the record itself. This means very, very fast read operations and very tricky update/delete logic in the layer (cached data needs to be updated/deleted as well).\n* ...more to come (now that the API is stable)\n\n# Note: \"SimpleDbLayer is not an ORM\"\n\nSimpleDbLayer is exactly what it says: a (thin) database layer. Most of the other database libraries (such as the excellent [Waterline](https://github.com/balderdashy/waterline)) work in such a way that they define an \"Object type\" (call it a model, or constructor function) and create objects of that \"type\":\n\n    // This is NOT how SimpleDbLayer works\n    var User = Waterline.Collection.extend({ name: { type: 'string' } } );\n    var user = new User();\n    user.name = \"tony\";\n    user.save();`.\n\nThis is _not_ how SimpleDbLayer works: you don't define models, custom methods for specific models, etc. SimpleDbLayer is a _thin_ layer around database data. In SimpleDbLayer, each managed database table is mapped to exacly _one plain database object_:\n\n    // ...Include module, create database connection, etc.\n    var DbLayer = SimpleDbLayer.extend( SimpleDbLayerMongo, { db: db } );\n\n      var people = new DbLayer( {\n\n        table: 'people',\n\n        schema: new SimpleSchema({\n          id:      { type: 'id' },\n          name:    { type: 'string', required: true },\n          surname: { type: 'string', searchable: true },\n          age:     { type: 'number', searchable: true },\n        }),\n\n        idProperty: 'id',\n      });\n\n      people.insert( {id: 1, name: 'Tony', surname: 'Mobily', age: '39' });\n\n\nThe plain Javascript object `people` will have several methods (`people.update()`, `people.select()`, etc.) which will manipulate the corresponding table `people`. There are no types defined, and there are no \"models\" for that matter. Each created object will manipulate a specific table on the database, and _application-wide, there **must** only be one SimpleDbLayer variable created for each database table_.\n\nWhen you create `people`, SimpleDbLayer keeps track of the layer created and creates an entry in its internal registry, based on the database table's name. _This means that you can only create one layer variable (a plain Javascript object) per table_. **Attempting to create two different layer variables for the same table will result in an error being thrown. Only one plain Javascript object per DB table is allowed.**\n\nIn an applicatiom, you will typically want to define those store objects in a module so that any other module can `require` them.\n\n# Create a DB connection\n\nSimpleDbLayer does not handle DB connections for you. It's your responsibility to connect to the database and pass the connection object to it.\nFor MongoDB, you can use Mongo's connect call:\n\n    mongo.MongoClient.connect( 'mongodb://localhost/hotplate', {}, function( err, db ){\n     // db exists here\n    };\n\n# Make up your DB Layer class: mixins\n\nIn order to use this library, you will need to _mixin_ the basic SimpleDbLayer class and a DB-specific mixin. If you are not used to mixins, don't be scared: it's simpler than it sounds. Im simple words, requiring `simpledblayer` will return a constructor that doesn't have any of the DB-specific functions in its prototype (not in a meaningful way -- they are just stubs that throws an error). If you try to create an object using the `simpledblayer` and then run `object.select()`, `object.insert()`, etc., you will end up with an error being thrown. By _mixing in_ the constructor returned by `simpledblayer-mongo`, however, you end up with a constructor that creates fully functional objects.\n\n    var SimpleDbLayer = require('simpledblayer'); // This is the main class\n    var SimpleSchema = require('simpleschema'); // This will be used to define the schema\n    var SimpleDbLayerMongo = require('simpledblayer-mongo'); // This is the layer-specific mixin\n\n    var mongo = require('mongodb');\n\n        // Connect to the database\n    mongo.MongoClient.connect('mongodb://localhost/someDB', {}, function( err, db ){\n\n      // DbLayer will be SimpleDbLayer \"enhanced\" with DB-Specific SimpleDbLayerMongo\n      var DbLayer = SimpleDbLayer.extend( SimpleDbLayerMongo, { db: db } );\n\n      // At this point, you can run `var people = new DbLayer( { ... } );\n\n      // Documentation's code will live here\n\n    });\n\n**Please note:** from now on, I will assume that any code referenced in this guide will be surrounded by the code above.\n\nTHe critical line is this:\n\n      var DbLayer = SimpleDbLayer.extend( SimpleDbLayerMongo, { db: db } );\n\nWhich can also be written as:\n\n      var DbLayer = declare( [ SimpleDbLayer, SimpleDbLayerMongo ], { db: db } );\n\nIn this case, you need to also require `simpledeclare` like this: `var declare = require('simpledeclare');`. For first-class, close-to-metal OOP in Javascript have a look at [simpledeclare](https://github.com/mercmobily/simpleDeclare), which is what SimpleDbLayer uses.\n\nHere you are creating a constructor function called `DbLayer`, whose prototype will be the merge of `SimpleDbLayer` (the basic functionalities), `SimpleDbLayerMongo` (the db-specific functions) and a plain object `{db: db }` (used to set the `db` attribute to the database connection)..\n\n# Create your layer object\n\nOnce you have your DbLayer class, it's up to you to create objects which will then modify specific database tables:\n\n      var people = new DbLayer( {\n\n        table: 'people',\n\n        schema: new SimpleSchema({\n          id:      { type: 'id' },\n          name:    { type: 'string', required: true },\n          surname: { type: 'string', searchable: true },\n          age:     { type: 'number', searchable: true },\n        }),\n\n        idProperty: 'id',\n      });\n\n`people` is an object tied to the collecton `people` in the MongoDb database..\n\nThe second parameter in the constructor (an object defining `table`, `schema` and `idProperty`) is a parameter object, which in this case include 1) The table name 2) The schema definition 3) The `idProperty`, which needs to be set and refer to an existing field.\n\nSimpleschema is an constructor based on [SimpleSchema](https://github.com/mercmobily/SimpleSchema), which provides a way to define extensible schemas with a very simple API. In this case, the `name` field is required whereas `surname` and `age` are not required but are searchable.\n\nSince the `id` field was set as `isProperty`, it will automatically be set as both `required` and `searchable`.\n\n## Note on prototype parameters and the constructor parameter\n\nWhen you actually create the object with `new`, you pass an object to the constructor: `var people = new DbLayer( { /*...this is an object with the constructor's parameters...*/ });`.\n\nNormally, you would define at least `table`, `schema` and `idProperty` (the required attributes every object needs to work).\n\nPlease note that you can define these attribute either in the object's prototype, or in the constructor's parameter. Every property in the constructor's parameter will be added to the created object (overriding the prototype's value).\n\nFor example, if all of your tables have `idProperty` set to `id`, you can define a layer like so:\n\n      var DbLayerWithId = SimpleDbLayer.extend( SimpleDbLayerMongo, { db: db, idProperty: 'id' } );\n\nAny object created with this constructor will automatically have the attribute `id` set (in the prototype):\n\n      var people = new DbLayerWithId( {\n        table: 'people',\n        schema: ...\n      });\n\n      // people.idProperty is already 'id' (from the prototype)\n\n You can always override the prototype-provided value with something else:\n\n     var rocks = new DbLayerWithId( {\n        idProperty: 'weirdId',\n        table: 'rocks',\n        schema: ...\n      });\n      // rocks.idProperty (an object's own attribute) is 'weirdId',\n\nThis means that you can create a constructor with the most common attributes, and only pass the absolute minimum to the constructor.\n\n# Important object attributes\n\nSome attributes are used by the objects to define how the object will work.\nThey are:\n\n## `hardLimitOnQueries` -- Setting a hard limit on queries. Default: `0`\n\nCursor-less queries on large data sets will likely chew up huge amounts of memory. This is why you can set a hard limit on queries:\n\n      var DbLayer = SimpleDbLayer.extend( SimpleDbLayerMongo, { db: db, hardLimitOnQueries: 10 } );\n\nThis will imply that each _non-cursor_ query will only ever return 10 items max. You can also set this limit on specific objects by passing hardLimitOnQueries as a constructor parameter:\n\n    var DbLayer = SimpleDbLayer.extend( SimpleDbLayerMongo,, { db: db } );\n    var people = new DbLayer( {  /* ...layer parameters..., */ hardLimitOnQueries: 10 } );\n\nNote that hardLimtOnQueries only ever applies to non-cursor queries.\n\n## `SchemaError` -- Constructor function used to throw schema validation errors. Default: `Error`\n\nThe `insert` and `update` operations will trigger validation against the schema. If validation fails, the callback is called with an error. The error object is created by SimpleDbLayer like this:\n\n    var error = new Error( { errors: errorsArray } );\n    error.errors = errorsArray;\n\nThe variable `errorsArray` is an array of objects, where each object has `field` and `message` defined. For example:\n\n    [ { field: 'age', message: 'Age is invalid' }, { field: 'name', message: 'Field is required: name' } ]\n\nYou can set the constructor used to create the error objects by passing a `SchemaError` parameter when you define the layer:\n\n    var DbLayer = SimpleDbLayer.extend( SimpleDbLayerMongo, { db: db, SchemaError: SomeErrorConstructor } );\n\nAs always, you can also define a the SchemaError constructor when creating the object with `new`:\n\n    var DbLayer = SimpleDbLayer.extend( SimpleDbLayerMongo, { db: db } );\n    var people = new DbLayer( { /* ...layer parameters..., */ SchemaError: SomeErrorConstructor } );\n\n# Full list of options for SimpleDbLayer\n\nHere is a full list of options that affect the behaviour of SimpleDbLayer objects. Please keep in mind that all of them can me defined either in the constructor's prototype, or as attribute of the constructor's parameter oject.\n\n## Basic properties\n\n* `table`. Required. No default. The table name in the underlying database.\n* `schema`. Required. No default. The schema to be used.\n* `idProperty`. Required. No default. The property representing the record's ID.\n* `hardLimitOnQueries`. Defaults to `0` (no limit). The maximum number of objects returned by non-cursor queries.\n* `SchemaError`. Defaults to `Error`. The constructor for `Error` objects.\n* `strictSchemaOnFetch`. Defaults to `true`. Every fethed record is validated against the schema. If this is `false`, schema errors will be ignored. If `true`, a schema error will generate an error. This is important if you decide to add a required field to your schema, but don't want to update the actual database.\n\n## Advanced properties\n\nThese attributes are explained later in the documentation.\n\n* `positionField`. Defaults to `null` (no positioning). The field used by the database engine to keep track of positioning.\n* `positionBase`. Defaults to `[]`. The list of key fields which will `group` positioning\n* `fetchChildrenByDefault`. Defaults to `false`; If true, queries returning records will return children by default.\n* `nested`. Defaults to `[]`. The 'children' tables for in-table joints.\n\n# Running queries\n\n## Querying: `insert()`\n\nTo insert data into your table:\n\n    people.insert( {\n      id: 1,\n      name: 'Tony',\n      surname: 'Mobily',\n      age: 37 },\n      , function( err, record ){\n\n\nThe second parameter is optional. If you pass it:\n\n* If `children` is `true`, the returned record will also include its children. Default is `false`.\n* If `skipValidation` is `true`, then the validation of the data against the schema will be skipped. Default is `false`.\n* `If `position` is defined, and table has a `positionField` element, then the record will be placed in the designated spot. The `position` element should be an object with `where` and optionally `beforeId`. See the [Repositioning section](#Repositioning) section in the documentation for details.\n\n# Querying: `update()`\n\nThis is a simple update:\n\n    people.update(\n      { name: 'startsWith', args: [ 'surname', 'mob' ] },\n      { surname: 'Tobily' },\n      { deleteUnsetFields: false, multi: true },\n      function( err, howMany, record ){\n\nThe callback will have `howMany` set as the number of changed records. The `record` parameter is not always there: if `multi` was set as `true`, then `record` is `undefined`. If `multi` was set as `false` (the default), `record` will be either the changed record (if one was updated -- in this case `num` is 1) or `null` (if nothing was updated -- in this case `num` is 0).\n\nThe third parameter, here set as `{ deleteUnsetFields: false, multi: true }`, is optional. If you pass it:\n\n* `multi`. If set to `true`, all records matching the search will be updated. Otherwise, only one record will be updated. Default: `false`.\n* `deleteUnsetFields`. If set to `true`, then any field that is not defined in the update object will be set as empty in the database. Basically, it's a \"full record update\" regardless of what was passed. Validation will fail if a field is required by the schema and it's not set while this option is `true`. Default: `false`.\n* `skipValidation`. If set to `true`, then the schema validation of the data against the schema will be skipped. Casting will still happen. Default: `false`.\n\nPlease note how the filter is an object that defines how data will be filtered. Check the `select` section to see how the filter works.\n\n# Querying: `delete()`\n\nThis is a simple delete:\n\n    people.delete(\n      { type: 'gt', args: [ 'age', 28 ] },\n      { multi: true },\n      function( err, howMany, record ){\n\nThe callback will have `howMany` set as the number of deleted records.  The `record` parameter is not always there: if `multi` was set as `true`, then `record` is `undefined`. If `multi` was set as `false` (the default), `record` will be either the deleted record (if one was deleted -- in this case `num` is 1) or `null` (if nothing was deleted -- in this case `num` is 0).\n\nThe second parameter, here set as `{ multi: true }`, is optional. If you pass it:\n\n* If `multi` is set to `true`, all records matching the search will be deleted. Otherwise, only one record will be deleted. Default: `false`.\n\n# Querying: `select()`\n\nSimpleDbLayer supports both normal and cursor-based queries, depending on the `useCursor` parameter.\n\n## Normal queries\n\nFor normal queries:\n\n    people.select(\n      {},\n      { useCursor: false , delete: false, skipHardLimitOnQueries: false },\n      function( err, data, total, grandTotal ){\n\nThe first parameter is an object representing the query (more about this later).\nThe second parameter is optional. If you pass it:\n\n* `useCursor`. If set to `true`, the function will call the call the callback with a cursor rahter than the data. Default: `false`.\n* `delete`. If set to `true`, SimpleDbLayer will _delete_ any fetched record. For normal queries, it will delete all records _before_ calling your callback.\n* `skipHardLimitOnQueries`. If set to `true`, SimpleDbLayer will ignore the `hardLimitOnQuery` attribute and will return _all_ fetched data. flag. Remember that if you have a very large data set and do not impose any range limits, non-cursor queries will attempt to place the whole thing in memory and will probably kill your server. Default: `false.`.\n\nThe callback is called with parameter `data` (the returned records), `total` (the number of records returned) and `grandTotal` (the _total_ number of records that satisfy the query without taking into consideration the required ranges).\n\n## Cursor queries\n\nFor cursor queries:\n\n    people.select(\n      {},\n      { useCursor: true , delete: false },\n      function( err, cursor, total, grandTotal ){\n\nThe second parameter is optional. If you pass it:\n\n* `useCursor`. If set to `true`, the function will call the call the callback with a cursor rather than the data. Default: `false`.\n* `delete`. If set to `true`, SimpleDbLayer will _delete_ any fetched record. For cursor queries, it will delete records as they are fetched with `cursor.next()`. Default: `false`.\n\nNote that for cursor queries `skipHardLimitOnQueries` will be ignored.\n\nThe callback is called with parameter `cursor` (the returned cursor), `total` (the number of records returned) and `grandTotal` (the _total_ number of records that satisfy the query without taking into consideration the required ranges).\n\n## Using the cursor\n\nThe `cursor` object has the methods `each()`, `next()` and `rewind()`.\n\n### cursor.each( iterator, cb )\n\nThis cursor function will call `iterator( item, done )` for each one of the fetched records. Once all of the records have been iterated, `cb()` will be called.\nThe iterator will have access to `item` (the item just fetched) and to `done( err, breakFlag)` (the function to call at the end of each iteration).\nIf the iterator calls `done()` with `err` set, then execution will be interrupted and `cb()` will be called with that error set.\nIf the iterator calls `done()` with `err` set to `null`, but with `breakFlag` set to `true`, then execution will be called and `cb()` will be called with `err` set to `null.`\nHere is a typical example of cursor usage:\n\n```javascript\n    function cursorExample( done ){\n\n      people.select( {}, { children: true, useCursor: true }, function( err, cursor ){\n        if( err ) return done( err );\n\n        cursor.each(\n\n          // This is the iterator. It will be called for each item, and\n          // it will call `cb()` after each iteration\n          function( item, cb ){\n\n            console.log(\"ITEM:\", item );\n\n            // If item 'Tony' is found, call `cb` with `breakFlag` set to\n            // true, which will effectively interrupt the cycle\n            if( item.type === 'Tony') return cb( null, true );\n\n            cb( null );\n          },\n\n          // This is the function that will be called 1) When all items\n          // have been visited OR 2) The iterator called `cb()` with an\n          // error OR 3) The iterator called `cb()` with no error, but with\n          // `breakFlag` set to true\n          function( err ){\n            if( err ) return done( err );\n\n            console.log('CYCLE IS OVER. Error:', err );\n            done( null );\n          }\n        );\n      });\n    }\n````\nUsing `each()` is the most convenient way to use a cursor.\n\n### cursor.next( cb )\n\n`next()` will call the passed callback `cb()` with the next available record, or `null` for the last fetched record.\n\n### cursor.rewind()\n\n`rewind()` will bring the cursor back to the beginning of the returned dataset. You can use `rewind()` within `cursor.each()`, although you run the risk of entering an infinite loop.\n\n## Filtering\n\nThe first parameter in select, which up to this point in the documentation was was left as an empty object, is an object with the following parameters:\n\n* `conditions`. It's an object including the attribute `type` (a string representing the type of the conditional operation to perform) and `args` (an array containing the parameters to the operation). For example, `{ type: 'startsWith', args: [ 'surname', 'mob' ] },` will filter all record where the field `surname` starts with `mob`.\n* `ranges`. It's an object that can have the attributes `from`, `to` and `limit` set. All attributes are optional. For example `{ limit: 10 }`.\n* `sort`. It's an object where each key represents the field the sort will apply to. For each key, value can be `-1` (bigger to smaller)  or `1` (smaller to bigger).\n\nAll parameters are optional.\n\nNote that while the parameter passed to `select()` includes `conditions` `ranges`, `sort`, the first parameter passed to `update()` and `delete()` is only passed the `conditions` object. This means that update and delete queries will either affect _all_ records (`multi` is `true`), or _one_ record (`multi` is `false` or not passed).\n\nA possible filtering parameter could be:\n\n    var searchFilter = {\n      ranges: {\n        from: 3,\n        to: 10\n      },\n      sort: {\n        name: -1,\n        age: 1\n      }\n      conditions: {\n        type: 'and',\n        args: [\n          {\n            type: 'startsWith',\n            args: [ 'name', 'to' ]\n          },\n          {\n            type: 'gt',\n            args: [ 'age', 30 ]\n          },\n        ]\n      }\n    }\n\n    people.select( searchFilter, function( err, cursor, total, grandTotal ){\n      // ...\n    });\n\n\n### The `conditions` object\n\nThe conditions object can have the following conditional operators (in `type`):\n\n* `and` -- all conditions in `args` need to be true\n* `or` -- at least one condition in `arts` needs to be true\n\nAnd the following logical operators (where the value of the field called `args[0]` will need to match `args[1]`):\n\n* `lt` -- less than\n* `lte` -- less or equal than\n* `gt` -- greater than\n* `gte` -- greater or equal than\n* `eq` -- equal to\n* `contains` -- string contains\n* `startsWith` -- string starts with\n* `endsWith` -- string ends with\n\nAn example could be:\n\n    {\n      type: 'and',\n      args: [\n        {\n          type: 'startsWith',\n          args: [ 'name', 'to' ]\n        },\n\n        {\n          type: 'or',\n          args: [\n            {\n              type: 'gt',\n              args: [ 'age', 30 ]\n            },\n            {\n              type: 'lt',\n              args: [ 'age', 10 ]\n            },\n          ]\n        }\n      ]\n    }\n\nWhich means `name startsWith 'to' AND ( age > 30 OR age < 10 )`.\n\n\n\n# Automatic loading of children (joins)\n\nIt is common, in application, to need to load a user's information as well as all several pieces of information related to him or her: all email addresses, all phone numbers, etc.\n\nWhile SimpleDbLayer doesn't suppose joining of tables at query time, it does support joining of tables ad _table definition_ time. This means that you can define how two tables are related before hand.\n\nThe main aim of this mechanism is to allow pre-caching of data whenever possible. So, if you have a table `people` and a table `emails`, and they are have a 1:n relationship (that is, the `emails` table contains a `personId` field which will make each record related to a specific person), every time you load a record from `people` you will also automatically load all of his or her email addresses. DB-specific functions will do their best to pre-cache results. This means that, if you are using MongoDB, you can fetch a person's record as well as _any_ information associated with it (email addresses, addresses, phone numbers, etc.) **in a single read**.\n\n## Define nested layers\n\nYou can now define a layer as \"child\" of another one:\n\n    var people = new DbLayer({\n\n      table: 'people',\n\n      schema: new SimpleSchema({\n        id     : { type: 'id' },\n        name   : { type: 'string', required: true },\n        surname: { type: 'string', searchable: true },\n        age    : { type: 'number', searchable: true },\n      }),\n\n      idProperty: 'id',\n\n      nested: [\n        {\n          type: 'multiple',\n          layer: 'emails',\n          join: { personId: 'id' },\n        },\n      ]\n\n    });\n\n    var emails = new DbLayer({\n\n      table: 'emails',\n\n      schema: new SimpleSchema({\n        id      : { type: 'id' },\n        personId: { type: 'id' },\n        address : { type: 'string', required: true, searchable: true },\n      }),\n\n      idProperty: 'id',\n\n      nested: [\n        {\n          type: 'lookup',\n          localField: 'personId'\n          layer: people,\n          layerField: 'id',\n        }\n      ],\n    });\n\n    SimpleDbLayer.init(); // <--- IMPORTANT!\n\n**It's absolutely crucial that you run `SimpleDbLayer.init()` before running queries if you have nested layers.**\n\nWhenever you load a record from the `people` table, you will also get a `_children` attribute for that object that will include all children data. `lookup`s will become one single object, whereas `multiple`s will become array of objects. Note: children are always loaded into `_children`, which cannot be changed. This is to keep things sane code-wise and data-wise.\n\nIf you see carefully, `people` is defined like this:\n\n    var people = new DbLayer({\n\n      table: 'people',\n      // ...\n      nested: [\n        {\n          type: 'multiple',\n          layer: 'emails', // <-- note: this is a string! Will do a lookup based on the table\n          join: { personId: 'id' },\n        },\n      ]\n\nA layer is a simple Javascript object linked to a specific table. However, when defining the layer `people`, the layer `emails` isn't defined yet -- and yet, you might need to reference it while creating relationships between layers (like in this case: a person has multiple email addresses, but `emails` hasn't been created yet).\n\nThe solution is to pass the string `'email'` for the `layer` property. When you run `SimpleDbLayer.init()`, SimpleDbLayer will go through every `nested` option of every defined layer thanks to the registry, and will also work to 'resolve' the string (based on the table's name: in this case, `emails`).\n\n### Single lookup\n\nFor single lookup nesting, `nested` is an array of nested table, each one defining:\n\n* `type`. The type of relationship. In this case, `lookup`.\n* `localField`. The field in the local table linking to an external record.\n* `layer`. The layer object representing the table you are linking to. NOTE that if you have a string instead of an object, the layer object will be looked up using the passed string as a table name.\n* `layerField`. The field, in the foreing table, you are linking to\n\nThe way you read this example is \"create a `personId` entry in `_children` where `people.id` is the same as the local `personId`\". So when you load an email, you will have an attribute in `_children` called `personId` which will contain the full person's record.\n\n### Multiple lookup\n\nFor multiple lookup nesting,\n\n`nested` is an array of nested table, each one defining:\n\n* `type`. The type of relationship. In this case, `multiple`.\n* `layer`. The layer object representing the table you are linking to. NOTE that if you have a string instead of an object, the layer object will be looked up using the passed string as a table name.\n* `join`. An object, where each key represents the foreign layer's field, and each value represents the local field.\n\nThe way you read this example is \"create a `emails` array in `_children` where including all records in `email` where `emails.personId` is the same as the local `id`\". So when you load a person, you will have an attribute in `_children` called `emails` which will contain all of the matching email records.\n\n## Searching\n\nThe fact that two tables are joined means that you can run queries on children records as well as on its \"main\" records.\n\nFor example, you can run a query like this:\n\n\n    var conditions = {\n      type: 'and',\n      args: [\n        {\n          type: 'startsWith',\n          args: [ 'emails.address', 'ton' ]\n        },\n        {\n          type: 'gt',\n          args: [ 'age', 30 ]\n        },\n      ]\n    }\n    people.select( { conditions: conditions }, { children: true }, function( err, data ){\n      if( err ) return cb( err );\n\n      console.log(\"Data: \", data );\n    });\n\nThis query will return all record with an email address starting with `ton`. In MongoDB, this happens by performing a query in the `_children` attribute of the record. In relational (uncached) databases, a JOIN will be used instead.\n\n## Caching layers\n\nSome layers (notably, MongoDB) lack the ability to do joins. To minulate joins, normally you would need to run an extra query for each fetched record. This would potentially put a strain on the database server.\n\nLayers might then implement pre-caching of children records. In such a case, you will need functions to mark records and collections \"dirty\" -- meaning that their children's basic structure has changed, and the cache s no longer reliable.\n\nSimpleDbLayer provides three functions to deal with this:\n\n### dirtyRecord( obj, cb )\n\nIt will mark the record dirty.\n\n### dirtyAll( cb )\n\nIt will mark all records dirty\n\n### dirtyAllParents( cb )\n\nIt will mark all records of all parent tables dirty. This is probably the most useful function, which should be run whenever you change the structure of a table.\n\n## Practical examples\n\nHere is a practical example of what happens when adding data with nested tables:\n\n```javascript\n    function addPeople( cb ){\n\n      var opt = { children: true };\n      people.insert( { id: 1, name: 'Tony', surname: 'Mobily', age: 37 }, opt, function( err, recordTony ){\n        if( err ) return cb( err );\n\n        people.insert( { id: 2, name: 'Chiara', surname: 'Mobily', age: 25 }, opt, function( err, recordChiara ){\n          if( err ) return cb( err );\n\n          people.insert( { id: 3, name: 'Sara', surname: 'Fabbietti', age: 15 }, opt, function( err, recordSara ){\n            if( err ) return cb( err );\n\n            cb( null);\n          });\n        });\n      });\n    }\n\n    function addEmails( cb ){\n\n      var opt = { children: true };\n\n      emails.insert( { id: 1, personId: 1, address: 'tonymobily@gmail.com' }, opt, function( err, tonyEmail1 ){\n        if( err ) return cb( err );\n\n        emails.insert( { id: 2, personId: 1, address: 'merc@mobily1.com' }, opt, function( err, tonyEmail2 ){\n          if( err ) return cb( err );\n\n          emails.insert( { id: 3, personId: 2, address: 'chiaramobily@gmail.com' }, opt, function( err, chiaraEmail1 ){\n            if( err ) return cb( err );\n\n            cb( null, tonyEmail1, tonyEmail2, chiaraEmail1 );\n          });\n        });\n      });\n    }\n\n\n    function fetchTony( cb ){\n\n      var opt = { children: true };\n\n      emails.select( { conditions: { type: 'eq', args: [ 'id', 1 ] } }, opt, function( err, data ){\n        if( err ) return cb( err );\n\n        cb( null, data[ 0 ]);\n\n      });\n    }\n\n    function deleteEmailsStartingWithTon( cb ){\n\n      emails.delete( {  type: 'and', args: [  { type: 'startsWith', args: [ 'address', 'TON' ] } ] }, { multi: true }, function( err, n ){\n        if( err ) return cb( err );\n        cb( null, n );\n      });\n    }\n\n\n    function runTest( cb ){\n\n      addPeople( function( err, recordTony, recordChiara, recordSara ){\n        if( err ) return cb( null );\n\n        /*\n        At this point, recordTony is:\n        { id: 1,\n          name: 'Tony',\n          surname: 'Mobily',\n          age: 37,\n         _children: { emails: [] }\n        }\n\n        recordChiara is:\n        { id: 2,\n          name: 'Chiara',\n          surname: 'Mobily',\n          age: 25,\n         _children: { emails: [] }\n        }\n\n        recordSara is:\n        {\n          id: 3,\n          name: 'Sara',\n          surname: 'Fabbietti',\n          age: 15,\n          _children: { emails: [] }\n        }\n        */\n\n        addEmails( function( err, tonyEmail1, tonyEmail2, chiaraEmail1 ){\n          if( err ) return cb( null );\n\n          /*\n          At this point, tonyEmail1 is:\n\n          { id: 1,\n            personId: 1,\n            address: 'tonymobily@gmail.com',\n            _children:\n             { personId:\n                { id: 1,\n                  name: 'Tony',\n                  surname: 'Mobily',\n                  age: 37,\n                  __uc__surname: 'MOBILY',\n                  _children: {}\n                }\n              }\n          }\n\n          tonyEmail2 is:\n\n          { id: 2,\n            personId: 1,\n            address: 'merc@mobily1.com',\n            _children:\n             { personId:\n                { age: 37,\n                  id: 1,\n                  name: 'Tony',\n                  surname: 'Mobily',\n                  __uc__surname: 'MOBILY',\n                  _children: {}\n                }\n              }\n          }\n\n          chiaraEmail1 is:\n\n          { id: 3,\n            personId: 2,\n            address: 'chiaramobily@gmail.com',\n            _children:\n             { personId:\n                { id: 2,\n                  name: 'Chiara',\n                  surname: 'Mobily',\n                  age: 25,\n                  __uc__surname: 'MOBILY',\n                  _children: {}\n                }\n              }\n          }\n\n          Note that each email address has an entry in _children called personId,\n          which represents the record.\n          */\n\n          fetchTony( function( err, tonyRecord ){\n            if( err ) return cb( null );\n\n            /*\n            At this point, tonyRecord includes all email addresses related to that record\n            as an array in _children:\n\n            { id: 1,\n              name: 'Tony',\n              surname: 'Tobily',\n              age: 37,\n              _children:\n               { emails:\n                  [ { id: 1,\n                      personId: 1,\n                      address: 'tonymobily@gmail.com',\n                      _children: {} },\n                    { id: 2,\n                      personId: 1,\n                      address: 'merc@mobily1.com',\n                      _children: {}\n                    }\n                  ]\n                }\n            }\n            */\n\n            deleteEmailsStartingWithTon( function( err, n ){\n              if( err ) return cb( null );\n\n              fetchTony( function( err, tonyRecord ){\n                if( err ) return cb( null );\n\n                /*\n                At this point, the record in emails with id 1 (the only one with an email\n                address started with \"ton\") is gone. More importantly, when fetchng 'Tony\" this is what\n                will return (notice how the deleted email address is gone)\n\n                { id: 1,\n                  name: 'Tony',\n                  surname: 'Tobily',\n                  age: 37,\n                  _children:\n                   { emails:\n                      [\n                        { id: 2,\n                          personId: 1,\n                          address: 'merc@mobily1.com',\n                          _children: {}\n                        }\n                      ]\n                    }\n                }\n                */\n\n              });\n            });\n          });\n        });\n      });\n    }\n```\n\nThe most important thing to remember is that when you use MongoDB in your backend, you will only perform a single read operation when you fetch a person. The children data is cached within the record. Any update operation will affect the main table, as well as any tables holding cached data.\n\nThis means that if the email record with ID 2 (`merc@mobily1.com`) is updated, then the cache for the personId with ID 1 will also be updated so that the email address is correct.\n\n# Positioning\n\nWhen records are fetched (using `select`) without chosing any `sort`ing options, they are returned in whichever order the underlying database server returns them. However, in web applications you often want to be able to decide the `placement` of an element, in order to allow drag&drop sorting etc.\n\nPositioning is tricky to manage from the application layer, as changing a field's position requires the update of several records in the database. This is why SimpleDbLayer handles (re)positioning for you.\n\n## Basic positioning\n\nIf you have a \"flat\" table, you can simply define the `positionField` attribute when you define the constructor:\n\n    var people = new DbLayer( 'people', {\n\n      schema: new SimpleSchema({\n        id: { type: 'id' },\n        name: { type: 'string', required: true },\n        surname: { type: 'string', searchable: true },\n        age: { type: 'number', searchable: true },\n      }),\n\n      idProperty: 'id',\n\n      positionField: 'position',\n    } );\n\nNote that `positionField` is _not_ defined in the schema. In fact, it will be completely _invisible_ to the application using SimpleDbLayer: it won't be returned in `select` queries, and won't be updatable.\n\nImagine that you add some data:\n\n    var tony = { id: 1, name: 'Tony', surname: 'Mobily', age: 39 };\n    var chiara = { id: 2, name: 'Chiara', surname: 'Mobily', age: 25 };\n\n    people.insert( tony, , function( err, tony ){\n      if( err ) return cb( err );\n\n      people.insert( chiara, , function( err, chiara ){\n        if( err ) return cb( err );\n        // ...\n\nSince the `positionField` is defined, and since `insert()` by default positions new records at the end, the data on the database will actually be:\n\n    [\n      { id: 1,\n        name: 'Tony',\n        surname: 'Mobily',\n        age: 39,\n        position: 1\n      },\n\n      { id: 2,\n        name: 'Chiara',\n        surname: 'Mobily',\n        age: 25,\n        position: 2\n      }\n    ]\n\nNote the `position` field. Also remember that the `position` field will always be hidden from you by SimpleDbLayer, when returning queries.\n\nHowever, when running a select:\n\n    people.select( {}, function( err, list ){\n      if( err ) return cb( err );\n\n      // ...\n    });\n\nSince there is no `sort` option specified, you are _guaranteed_ that `list` will return the records in the right order (`Tony` first, and `Chiara` second).\n\n## Positioning at insert time\n\nWhen inserting a record, you can decide its position by passing a `position` parameter to the `insert()` call. `position` can have:\n\n* `where`. It can be `start`, `end` or `before`. If it's `before`, then the next parameter `beforeId` comes into play. Default: `end`.\n* `beforeId`. If `where` is `before`, then the new record will be placed before `beforeId`.\n\nSo, for example:\n\n````javascript\n    var sara = { id: 3, name: 'Sara', surname: 'Fabbietti', age: 15 };\n    var marco = { id: 4, name: 'Marco', surname: 'Fabbietti', age: 54 };\n    var dion = { id: 5, name: 'Dion', surname: 'Patelis', age: 38 }\n\n    // The record will be placed first\n    people.insert( sara, { position: 'start' }, function( err, sara ){\n      if( err ) return cb( err );\n\n      // The record will be placed before ID 2 ('Chiara')\n      people.insert( marco, { position: 'before', beforeId: 2 }, function( err, marco ){\n        if( err ) return cb( err );\n        // ...\n\n        // The record will be placed last\n        people.insert( dion, { position: 'end' }, function( err, dion ){\n          if( err ) return cb( err );\n          // ...\n````\n\n\n## Repositioning\n\nYou can decide to move a record `after` inserting it. This is especially useful in case a user moves a record using Drag & Drop in your web application.\n\nTo reposition a record, just run `reposition`:\n\n    // Move \"Chara\" to the start, position 1.\n    people.reposition( chiara, 'start`, null, function( err ){\n      if( err ) return cb( err );\n\n      // ...\n    });\n\nThe call `reposition( record, where, beforeId )` will take the following parameters:\n\n* `record`. This is the record that will be repositioned.\n* `where`. It can be `start`, `end`, or `before`.\n* `beforeId`. If `where` is `before`, then `record` will be positioned before the one with ID `beforeId`.\n\n## Nested record positioning\n\nIn most cases, your records will be \"nested\" to other ones. Imagine the two layers we have dealt with up to this point, `people` and `emails`:\n\n    var people = new DbLayer({\n\n      table: 'people',\n\n      schema: new SimpleSchema({\n        id     : { type: 'id' },\n        name   : { type: 'string', required: true },\n        surname: { type: 'string', searchable: true },\n        age    : { type: 'number', searchable: true },\n      }),\n\n      idProperty: 'id',\n    });\n\n    var emails = new DbLayer({\n\n      table: 'emails',\n\n      schema: new SimpleSchema({\n        id      : { type: 'id' },\n        personId: { type: 'id' },\n        address : { type: 'string', required: true, searchable: true },\n      }),\n\n      idProperty: 'id',\n    });\n\nEach person will have a number of emails -- all the ones with the corresponding `personId`. When dealing with positioning, you need to take into account what fields define the 'ordering grouping': placing an email address before another one should only ever affect the records belonging to the same person.\n\nThis is where the `positionBase` array comes in.\n\nThis is how you would make the `emails` layer able to handle positioning:\n\n    var emails = new DbLayer({\n\n      table: 'emails',\n\n      schema: new SimpleSchema({\n        id      : { type: 'id' },\n        personId: { type: 'id' },\n        address : { type: 'string', required: true, searchable: true },\n      }),\n\n      idProperty: 'id',\n\n      positionField: 'position',\n      positionBase: [ 'personId' ],\n    });\n\nThe attribute `positionBase` basically decides the domain in which the reordering will happen: only records where `personId` matches the moving record's `personId` will be affected by repositioning.\n\nThis means that repositioning one of Tony's email address will not affect the order of Chiara's email address.\n\nNote that all elements in `positionBase` will need to be defined in the schema, and that they will be forced as `searchable` and `required`.\n\n# Indexing\n\nYou can create and delete indexes using SimpleDbLayer.\nThe methods are:\n\n## `makeIndex( keys, name, options, cb )`\n\nThe method `makeIndex` will create an index. When calling the function:\n\n* `keys` is an hash where each key is the field name, and each value can be `1` (ascending order) or `-1` (descending order). So, if you have `{ name: 1, surname: 1 }`, the database will be instructed to create an index with the fields `name` and `surname`, both in ascending order.\n* `name` is the name of your index.\n* `options` is a hash where: `{ background: true }` will start the process in background; `unique` will instruct the database that the index will need to be unique; `name` will force the index name to a specific label, rather than the database's default.\n\n## `dropIndex( name, cb)`\n\nThis metod `dropIndex()` will drop an index.\n\n## `dropAllIndexes()`\n\nThe method `dropAllIndexes` will drop all indexes for the table/collection.\n\n## `generateSchemaIndexes( options, callback )`\n\nThis function is used to generate indexes depending on what fields are marked as `searchable` in the schema. Where `options` is an options object. Possible keys:\n\n* `background`. If `true`, indexes will be generated in the background and the `callback` will be called immediately.\n\nThe implementation of this depends on the capabilities and architecture of the database server you are using. The goal is to make sure that the most common searches are based on indexes, leaving you the task of adding only the special cases by hand.\n\nIn most cases, database engines should at least create the following:\n\n* The `idProperty` field will be indexed, and will be marked as `unique`.\n* Any field marked as `searchable` will be indexed. If `indexBase` is defined as an array, every field marked as `searchable` will be indexed with the `indexBase` values as prefix.\n* If `positionField` is set, then `positionField` will also be indexed (along with its `positionBase`)\n* If `extraIndexes` is set, any index defined there will be created. Since extraIndexes are added last, it can also be used to override existing indexes (as long as the names match).\n\n(Note: for MongoDB, which pre-caches children records within the main records, indexes will be created for the sub-fields as well, voiding indeing of foreign keys whenever possible (although _some_ wastage does happen)).\n\nImagine that you have a schema so defined:\n\n    var people = new DbLayer({\n\n      table: 'people',\n\n      schema: new SimpleSchema({\n        workspaceId : { type: 'id', searchable: true },\n        id          : { type: 'id' },\n        name        : { type: 'string', searchable: true, required: true },\n        surname     : { type: 'string', searchable: true },\n        age         : { type: 'number' },\n      }),\n\n      // ID property\n      idProperty: 'id',\n\n      // Position fields\n      positionField : 'position',\n      positionBase: [ 'workspaceId' ],\n\n      // Indexes properties\n      indexBase: [ 'workspaceId']\n      extraIndexes: {\n        name: 'nameSurname',\n        options: { },\n        keys   : { name: 1, surname: 1 },\n      },\n\n    });\n\nNote that `positionField` is set as `position`, and that each workspace will have its own ordering thanks to `positionBase` set to `[ 'workspaceId' ]`. Also, note that there is also `indexBase` set as `[ 'workspaceId' ]`, which tells SimpleDbLayer that most searches will be done with `workspaceId` set.\nThe following indexes will generally be created:\n\n* `idProperty`. It will be marked as `unique` so that there won't be any duplicates.\n* `name`. The straight \"name\" field.\n* `surname. The straight \"surname\" field.\n* `workspaceId+name`. The \"name\" field, index with a prepending `workspaceId` (since most searches will be likely to include it)\n* `workspaceId+surname`. The \"surname\" field, index with a prepending `workspaceId` (since most searches will be likely to include it).\n* `workspaceId+position`. The \"position\" field, including the `positionBase` (since sorting will always be based on `positionBase`).\n* `name+surname`. This will be created thanks to `extraIndexes`, which is used to create indexs for common cases like this one\n\nBasically, simpleDbLayer covers the most common scenarios in terms of indexing, with the flexibility of defining extra indxes with `extraIndexes` (for example for `name+surname`), so that slow queries are avoided at all costs minimising wastage in terms of indexing.\n\n### Customising what `generateSchemaIndexes()` does\n\nTo define custom indexes that cannot be covered with the options above, or to perform extra db-specific operations while creating indexes, you could override the `generateSchemaIndexes` method for your layer:\n\n    var people = new DbLayer({\n\n      table: 'people',\n\n      schema: new SimpleSchema({\n        workspaceId : { type: 'id' },\n        id          : { type: 'id' },\n        name        : { type: 'string', searchable: true, required: true },\n        surname     : { type: 'string', searchable: true },\n        age         : { type: 'number' },\n      }),\n\n      idProperty: 'id',\n\n      positionField : 'position',\n      positionBase: [ 'workspaceId' ],\n\n      indexBase: [ 'workspaceId'],\n\n      generateSchemaIndexes: function f( options, callback ){\n        var self = this;\n\n        // Call the original call\n        this.inheritedAsync( f, arguments, function( err ){\n          if( err ) return callback( err );\n\n          // Make indexes for name and surname together\n          self.makeIndex( { name: 1, surname: 1 }, 'nameSurname', options, function( err ){\n            if( err ) return callback( err );\n\n            // Make indexes for name and surname including the workspaceId\n            self.makeIndex( { workspaceId: 1, name: 1, surname: 1 }, 'workspaceIdNameSurname', options, function( err ){\n              if( err ) return callback( err );\n\n              // All good, return!\n              callback( null );\n            });\n          }),\n        });\n\n      },\n    });\n\n\n(Yes, this particular example could have easily been done with `extraIndexes`). Note that in this code the original `generateSchemaIndexes()` function was overridden by a custom one. However, the original call was actually called thanks to `this.inheritedAsync()` (which is available thanks to simpleDeclare). Then `self.nameIndex()` was called twice, with the new indexes.\n\n\n# Class-level functions\n\nEach constructor that inherits from SimpleDbLayer has some \"class functions\" available. The functions are actially copied, father to descendant, by simpleDeclare.\n\n## Layer registry functions\n\nSimpleDbLayer keeps a registry of layers (indexed by table name, which is unique). The registry is accessible through class calls.\n\nThis mechanism is very handy when you want to define your layers objects in a module within your program, and then want to access those variables anywhere in your program.\n\nThe registry is also used by SimpleDbLayer itself when you reference a nested layer with a string rather than a layer object (the layer object is looked by table name).\n\nHere are the registry functions:\n\n### DbLayer.getLayer( table )\n\nThe function `DbLayer.getLayer( table )` will return a single layer from the layer registry:\n\n    emails = DbLayer.getLayer( 'emails' )\n    // Layer variable 'email' is now ready to be used to insert, delete, etc.\n\n### DbLayer.getAllLayers()\n\nThe function `DbLayer.getAllLayers()` will return _all_ layers in the registry:\n\n    allLayers = DbLayer.getAllLayers()\n    // allLayers is now { emails: [Object], people: [Object], ... }\n\nAs you can see, allLayers is a hash object where each key is the layer's name.\n\n## Global index manipulation functions\n\nSimpleDbLayer provides two class-level functions that affect indexes for all the layers in the registry:\n\n### `SimpleDbLayer.generateSchemaIndexesAllLayers( options, callback )`.\n\nThis function does what it says: it generates all schema indexes for every layer defined in the registry. Parameters:\n\n* `options`. Any options that will be passed to each `generateSchemaIndexes()` call. Especially useful when you want to pass `{ background: true }`.\n* `callback`. The callback that will be called.\n\n### `SimpleDbLayer.dropAllIndexesAllLayers( callback)`.\n\nThis function drops all indexes for every layer defined in the registry. Parameters:\n\n* `callback`. The callback that will be called.\n",
  "readmeFilename": "README.md",
  "gitHead": "1a588094cdf7ce7e82f3c1339d934bb05e464053",
  "bugs": {
    "url": "https://github.com/mercmobily/simpledblayer/issues"
  },
  "homepage": "https://github.com/mercmobily/simpledblayer#readme",
  "_id": "simpledblayer@0.3.29",
  "scripts": {},
  "_shasum": "5476e4745b022c33023ac3b6d3ca4e4d20fad8b0",
  "_from": "simpledblayer@>=0.3.0 <0.4.0"
}
