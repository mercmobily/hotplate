"use strict";

var dummy
  , hotplate = require('hotplate')

  , declare = require('simpledeclare')

  , async = require( 'async' )
  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )
  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )

  , hotCoreStoreConfig = require( 'hotCoreStoreConfig' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )
  , debug = require('debug')('hotplate:hotCoreComet')
;


// Define store and mongo drivers.

var TABLIFESPAN = 180000;
var CLEANUPINTERVAL = 60000;

hotplate.hotEvents.on( 'stores', 'hotCoreComet', hotplate.cachable( function( done ){

  var stores = {};

  // This module only uses JsonRestStores as a way to access the DB and expose methods,
  // it doesn't mixin with hotJsonRestStores (which would do Comet event emission etc.)

   hotCoreJsonRestStores.get( function( err, s ){
    if( err ) return done( err );

    var BasicDbStore = s.BasicDbStore;
    var BasicSchema = s.BasicSchema;

    // ***********************************
    // *** OPEN TABS   *******************
    // ***********************************
  
    var Tabs = declare( BasicDbStore, {
  
      schema: new BasicSchema({
        userId:        { type: 'id', required: true, searchable: true },
        lastSync:      { type: 'date', default: function(){ return new Date() } },
      }),
  
      // Time filters. Note that since handleGetQuery is off, this is only really used by the API.
      // Note that the module ought to use DbLayer to do this, but uses the API for "historycal" reasons
      // TODO: change module so that it queries tabs using DbLayer rather than API
      onlineSearchSchema: new BasicSchema({
        fromLastSync:  { type: 'date', searchable: true, searchOptions: { type: 'gte', field: 'lastSync' } },
        toLastSync:    { type: 'date', searchable: true, searchOptions: { type: 'lte', field: 'lastSync' }  },
      }),
  
      handlePost: true,
      handleDelete: true,
      
      storeName:  'tabs',
  
      publicURL: '/tabs/:id',
      hotExpose: true,
      type: 'uncached',
  
      prepareBody: function( request, method, p, cb ){
  
        var body = request.body;

        if( method == 'post' && request.remote ){
          if( request._req.session.userId ){
            body.userId = request._req.session.userId;
          }
        }
        cb( null, body );
      },
  
      // Delete ALL entries in TabMessages when a tab gets deleted
      postEverything: function( request, method, p, cb ){
  
        // Only deal with delete
        if( method !== 'delete' ) return cb( null );

        // Delete the tab messages
        stores.tabMessages.dbLayer.delete( { conditions: { and: [ { field: 'tabId', type:'eq', value: request.body.tabId } ] } }, cb );
        
      },
  

    });
    stores.tabs = new Tabs();
  
  
  
    var TabMessages = declare( BasicDbStore, {
  
      schema: new BasicSchema({
        fromUserId:    { type: 'id', required: false },
        message:       { type: 'serialize', required: true },
        added:         { type: 'date', default: function() { return new Date() } },
      }),
  
      // Time filters. Note that since handleGetQuery is off, this is only really used by the API.
      // Note that the module ought to use DbLayer to do this, but uses the API for "historycal" reasons
      // TODO: change module so that it queries tabs using DbLayer rather than API
      onlineSearchSchema: new BasicSchema({
        fromAdded: { type: 'date', searchable: true, searchOptions: { type: 'gte', field: 'added' }  },
        toAdded  : { type: 'date', searchable: true, searchOptions: { type: 'lte', field: 'added' }  },
      }),
  
      storeName:  'tabMessages',
      paramIds: [ 'tabId', 'id' ],
      type: 'uncached',
  
    });
    stores.tabMessages = new TabMessages();
  
    
    // PSEUDO-STORE, sends an object out with all of the messages
    // It will return an array of unserialised messages in TabMessages for
    // a specific tabId, and then it will DELETE those messages
    var TabMessageDispatcher = declare( JsonRestStores, {
  
      // COMMON
      schema: new SimpleSchema({
        tabId:         { type: 'blob' }, // This is 'blob' as SimpleSchema has numbers for IDs by default
        messages:      { type: 'none' },
      }),
  
  
      //logError: function( error ){ hotCoreServerLogger.log( error ); },

      storeName:  'tabMessageDispatcher',
  
      publicURL: '/tabs/dispatcher/:tabId',
      hotExpose: true,
      type: 'uncached',

      handleGet: true,
      checkPermissions: function( request, method, p, done ){
  
        // Check that the remote user requesting the tab is indeed the tab's owner
        var self = this;
  
        // Only check for 'get'
        if( method !== 'get' ) return done( null, true );

        // User needs to be logged in
        if( ! request._req.session.userId ) return done( null, false );
  
        // TODO: Optimise a little here. Since checkPermissions is called before driverAllDbFetch,
        // try and cache this result
        stores.tabs.apiGetQuery( { filters: { fromLastSync: new Date() - TABLIFESPAN, id: request.params.tabId } }, function( err, tab ){
          if( err ) return done( err );
          
          // This may seem strange, but always pass authentication if the tab is not
          // there, as the store will need to accept the get and return the "storeReset"
          // message after returning the new tab
          if( tab.length == 0 ){
             done( null, true );
          } else {
            tab = tab[0];
            done( null, tab.userId.toString() === request._req.session.userId.toString() );
          }
          
        });
  
   
      },
  
      implementFetchOne: function( request, done ){
  
        var messages = [];
        var self = this;
  
  
        // If it's not a remote call, always return empty result
        if( ! request.remote ) return done( null, { messages: [] } );
  
        var headersWorkspaceId = request._req.headers[ 'x-hotplate-workspaceid' ];
  
        // User is not logged in -- goodbye
        if( ! request._req.session.loggedIn || ! request._req.session.userId ){
          debug("A non-logged in user tried to fetch tabId %s for workspaceId %s, denying...", request.params.tabId, headersWorkspaceId );
          return done( new self.UnauthorizedError() );
        }
  
        debug("Looking for tab %s owned by user %s, x-workspaceId is %s", request.params.tabId, request._req.session.userId, headersWorkspaceId );
  
        // Return all messages for that tab, REMOVING after fetching
        stores.tabs.apiGetQuery( { filters: { id: request.params.tabId, userId: request._req.session.userId, fromLastSync: new Date() - TABLIFESPAN } }, function( err, tab ){
          if( err ){
            done( err );
          } else {
  
  
            debug("Returned:");
            debug( tab );
            if( tab.length == 0 ){
  
              debug("Tab was NOT present. Trying to understand if I should create one");
  
              // At this point, the tab wasn't found. If workspaceId was passed via headers,
              // the person will be returned the configuration for that workspace. We need to check
              // that the user actually has access to that workspaceId.
  
              hotCoreStoreRegistry.getAllStores( function( err, storesData ){
                if( err ){
                  done( err );
                } else {
                  debug("Checking that user has access to the workspaceId she is trying to register for");
                  storesData.usersWorkspaces.apiGetQuery( { filters: { userId: request._req.session.userId, workspaceId: headersWorkspaceId } }, function( err, uwDocs){
                    if( err ){
                      done( err );
                    } else {
                      if( uwDocs.length == 0 ){
                        debug("No access -- user needs to (re?)login!");
                        done( new self.UnauthorizedError() );
                      } else {
                 
      
                        debug("OK, access is cleared, creating the tab for the user...");
                        debug( request._req.session.userId );
                        stores.tabs.apiPost( { userId: request._req.session.userId }, { killComet: true }, function( err, tab ){
                          if( err ){
                             done( err );
                          } else {
      
                            
                            debug("...and ALSO returning the workspace configuration for that userId");
                            hotCoreStoreConfig.getConfigRecords( headersWorkspaceId, request._req.session.userId, function( err, storeRecords ){
                              if( err ){
                                done( err );
                              } else {
                                done( null, { messages: [ { fromUserId: request._req.session.userId, message: { type: 'resetStores', tabId: tab.id, storeRecords: storeRecords } } ] } );
                              };
                            });
      
                          }
                        }); // Tabs.Post()
      
      
                      }
                    }
                  });//UsersWorkspaces.GetQuer ()
                }
              });
  
  
            } else {
  
              // Write the new access time onto the tab's record; 
              tab = tab[ 0 ];
              tab.lastSync = new Date();
              stores.tabs.apiPut( tab.id, tab, { killComet: true }, function( err, tab ){
                if( err ){
                  done( err );
                } else {
  
                  // Return all messages for that tab, REMOVING after fetching
                  stores.tabMessages.apiGetQuery( { sort: { added: 1 }, filters: { tabId: request.params.tabId, fromAdded: new Date() - TABLIFESPAN }, delete: true }, function( err, tabMessages ){
                    if( err ){
                      done( err );
                    } else {
           
                      tabMessages.forEach( function( tabMessage ){
                        // delete tabMessage._\id;
                        delete tabMessage.messageId;
                        delete tabMessage.tabId;
  
                        messages.push( tabMessage);
                      });
                      done( null, { messages: messages } );
                    }
                  });
                }
  
              });
  
             }
          };
        });
      
      },
  
    });
    stores.tabMessageDispatcher = new TabMessageDispatcher();

    done( null, stores );
  });

}))


hotplate.hotEvents.on( 'run', hotplate.cachable( function( done ){

  hotCoreStoreRegistry.getAllStores( function( err, storesData ){
    if( err ){
      done( err );
    } else {
      // Clean up Tabs collection every 30 seconds, so that
      // dead tabs are gotten rid of
      var cleaningUp = false;


      setInterval( function(){
        if( cleaningUp ) return;
        cleaningUp = true;

        debug("Cleaning up unused tabs...");

        //debug( "Cleaning up expired tabs and tab messages..." );

        storesData.tabs.dbLayer.delete( { conditions: { and: [ { field: 'lastSync', type: 'lte', value: new Date( new Date() - TABLIFESPAN ) } ] } }, { multi: true }, function( err, howMany ){
          // debug( 'Tabs: error and howMany: ', err, howMany );
          //TODO: Log error

          storesData.tabMessages.dbLayer.delete( { conditions: { and: [ { field: 'added', type: 'lte', value: new Date( new Date() - TABLIFESPAN ) } ] } }, { multi: true }, function( err, howMany ){
            ////  debug( 'TabMessages: error and howMany: ', err, howMany );
            // TODO: Log error
            cleaningUp = false;
          });
        });
 
      }, CLEANUPINTERVAL );

    }
  });

  done( null );
}));


hotplate.hotEvents.on('cometBroadcast', 'hotCoreComet', function( userId, tabId, makeTabIdHash, message, done ){

  var self = this;

  hotCoreStoreRegistry.getAllStores( function( err, storesData ){
    if( err ){
      done( err );
    } else {

      // makeTabId function wasn't passed: just use the stock "send it to all tabs" function
      if( ! makeTabIdHash ){
        debug("Using allTabIdHash!");
        makeTabIdHash = allTabIdHash;
      } else {
        debug("Using PASSED makeTabIdHash!");
      }      
      
      // Get the list of tab ids
      makeTabIdHash( userId, tabId, message, function( err, tabIdHash ){

        async.each( 

          Object.keys( tabIdHash ),

          function( tabId, cb){

            // Make up the object. fromUserId is not required, so it will only be added if needed
            var obj = {
              tabId: tabId,
              message: message
            };
            if( userId ) obj.fromUserId = userId;

            // OK, post it to the messages
            storesData.tabMessages.apiPost( obj, { killComet: true }, cb );
          },

          function( err ){
            if( err ) return done( err );

            done( null );
          }
        );

      })
    }

  });  

});

function allTabIdHash( userId, tabId, message, done ){

  debug("In allTabIdHash!" );

  hotCoreStoreRegistry.getAllStores( function( err, storesData ){
    if( err ){
      done( err );
    } else {

      var tabIdHash = {}; 

      // Just return all active tabs

      storesData.tabs.apiGetQuery( { filters: { fromLastSync: new Date() - TABLIFESPAN  }  }, function( err, docs ){
        if( err ){
          done( err );
        } else {
          docs.forEach( function( i ){
            if( i.id != tabId ) tabIdHash[ i.id ] = true;
          });
          done( null, tabIdHash );
        }
      });
    }
  });

}



