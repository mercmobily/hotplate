"use strict";

/**
This file is a "plugin" for hotCoreAuth, and provides two methods:

* `extraStores( stores, done )`
* `strategyRoutesMaker( app, strategyName, done )`

Which will add an extra store (`logins`) and will create the right routes so that local authentication works.

@class hotCoreAuth.local
@static
*/

var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , JsonRestStores = require( 'jsonreststores' )
  , SimpleSchema = require( 'simpleschema' )
  , declare = require('simpledeclare')

  , passport = require('passport')
  , LocalStrategy = require('passport-local').Strategy
  , hat = require('hat')
  , bcrypt = require('bcrypt')
  , hotCoreAuth = hotplate.require('hotCoreAuth')
  , hotCoreStoreRegistry = hotplate.require('hotCoreStoreRegistry')
;

var SALT_WORK_FACTOR = 15;

var makeResponder = hotCoreAuth.makeResponder;

/**
Adds `logins` to the list of stores returned by hotCoreAuth

## `logins`

This is used so that an applicaton can know in advance if a user login is already taken. It does so by querying `usersStrategies`, where `strategyId` is 'local' and `field1` is `request.options.conditions.login`.

    // This is used so that an applicaton can know in advance if a user login is already taken
    var Logins = declare( JsonRestStores, JsonRestStores.HTTPMixin, {

      schema: new SimpleSchema({
        login     : { type: 'string', required: true, lowercase: true, trim: 30, searchable: true },
      }),

      storeName:  'logins',

      handleGetQuery: true,

      // This is descriptive only
      queryConditions: {
        type: 'eq',
        args: [ 'login', '#login' ]
      },

      publicURL: '/logins/:id',
      hotExpose: true,

      // Will look for `requests.options.conditions.login` in `usersStrategies`. If it's there,
      // will return it as a 1-element collection `[ { login: request.options.conditions.login } ]`
      implementQuery: function( request, cb ){ }

    });
    stores.login = new Logins();

@method extraStores
@param {Object} stores The existing hotCoreAuth stores
@param {Function} done Callback
*/
exports.extraStores = function( stores, done ){

  // This is used so that an applicaton can know in advance if a user login is already taken
  var Logins = declare( JsonRestStores, JsonRestStores.HTTPMixin, {

    schema: new SimpleSchema({
      login     : { type: 'string', required: true, lowercase: true, trim: 30, searchable: true },
    }),

    storeName:  'logins',

    handleGetQuery: true,

    publicURL: '/logins/:id',
    hotExpose: true,

   // This is descriptive only
    queryConditions: {
      type: 'eq',
      args: [ 'login', '#login' ]
    },

    implementQuery: function( request, cb ){

      var self = this;

      stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: 'local', field1: request.options.conditions.login } }, { children: true }, function( err, res ){
        if( err ) return cb( err );

        // Return the login
        if( ! res.length) return cb( null, [ ] );
        cb( null, [ { login: request.options.conditions.login } ] );

      });

    },

  });
  stores.login = new Logins();

  done( null );
}


/**
A function that sets the routes to implement Local (username/password) authentication.
It will set the following routes:

  * Manager: `/auth/manager/local`
  * Signin: `/auth/signin/local`
  * Recover: `/auth/recover/local`
  * Register: `/auth/register/local`
  * Resume: `/auth/resume/local`

In usersStrategies:

* `field1` is used to store the username
* `field3` is used to store an encripted version of the password

While managing the passwords, if the client sends `*` as the password, the old password is retained.

@method strategyRoutesMaker
@param {Object} app Express' `app` variable, used to create routes
@param {String} strategyName The name of the strategy that needs to be setup (e.g. 'facebook')
@param {Function} done Callback
*/
exports.strategyRoutesMaker = function( app, strategyName, done  ){

  hotCoreStoreRegistry.getAllStores( function( err, stores ){
    if( err ) return done( err );

    // Get the strategy's data
    var strategyConfig = hotplate.config.get('hotCoreAuth.strategies' )[strategyName];

    // ***********************
    // *** MANAGER         ***
    // ***********************

    passport.use('local-manager', new LocalStrategy({
      passReqToCallback: true,
      usernameField: 'login',
    },

    function(req, login, password, done) {

      if( ! req.session.loggedIn ) return  done( null, false );

      // Check that there isn't one already there
      stores.usersStrategies.dbLayer.selectByHash( { conditions: { userId: req.session.userId, strategyId: 'local' } }, { children: true }, function( err, res ){
        if( err ) return done( err, null );

        if( res.length ){
          var itsEdit = true;
          var existingPassword = res[0].field3;
          var foundStrategyId = res[0].id;
        }

        stores.usersStrategies.dbLayer.selectByHash( { conditions: { field1: login.toLowerCase() } }, function( err, res ){
          if( err ) return done( err, null );

          // Check that it's not editing itself
          var editingSelf = false;
          if( res.length > 0 ){
            editingSelf = ( itsEdit == true && res[0].id.toString() == foundStrategyId.toString()  );
          }

          if( res.length > 0 && !editingSelf ) return done( null, false, { message: "Login name taken!" } );

          // It's an edit: overwrite existing values
          if( itsEdit ){

            // If the password is a '*', then it will retain the existing password
            if( password == '*' ) password = existingPassword;

            stores.usersStrategies.dbLayer.updateById( foundStrategyId, { userId: req.session.userId, strategyId: 'local', field1: login.toLowerCase(), field3: password }, function( err, res ){
              if( err ) return done( err, null );
              return done( null, { id: res.userId } );

            });

          // It's a new entry: add a new record
          } else {

            stores.usersStrategies.apiPost( { userId: req.session.userId, strategyId: 'local', field1: login.toLowerCase(), field3: password }, function( err, res ){
              if( err ) return done( err, null );

              return done( null, { id: res.userId } );
            });
          }
        });
      });

    }
    ));

    app.post( hotplate.prefix( '/auth/manager/local' ), function( req, res, next) {
      passport.authenticate('local-manager',  makeResponder( req, res, next, 'local', 'manager')  )(req, res, next);
    });

    // ***********************
    // *** SIGN IN         ***
    // ***********************

    passport.use('local-signin', new LocalStrategy({
      passReqToCallback: true,
      usernameField: 'login',
    },

    function(req, login, password, done) {

      stores.usersStrategies.dbLayer.selectByHash( { conditions: { field1: login.toLowerCase(), field3: password } }, function( err, res ){
        if( err ) return done( err, null );

        if( res.length ){
          req.session.loggedIn = true;
          req.session.userId = res[0].userId;
          return done( null, { id: res[ 0 ].userId } );
        }

        done( null, false );
      });

    }
    ));

    app.post( hotplate.prefix( '/auth/signin/local' ), function( req, res, next) {
      passport.authenticate('local-signin',  makeResponder( req, res, next, 'local', 'signin')  )(req, res, next);
    });

    // ***********************
    // *** RECOVER         ***
    // ***********************

    passport.use('local-recover', new LocalStrategy({
      passReqToCallback: true,
      usernameField: 'login',
    },

    function(req, login, password, done) {

      if( req.session.loggedIn ) return done( null, false );

      // The profile MUST contain an ID
      if( login == '' ){
         return done( null, false, { message: "Username cannot be empty" } );
      }

      // Check that "local" isn't already there
      stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: 'local', field1: login.toLowerCase() } }, { children: true }, function( err, res ){
        if( err ) return done( err, null );

        if( ! res.length ) return done( null, false, { message: "Username not found" } );

        stores.users.dbLayer.selectById( res[0].userId, function( err, user ){
          if( err ) return done( err, null );

          // Create the recoveryToken
          user.recoverToken = hat();
          user.recoverTokenCreated = new Date();
          delete user._children;
          // Place the token in the user's record
          stores.users.dbLayer.updateById( user.id, user, function( err, newUser ){
            if( err ) return done( err, null );

            done( null, false, { message: "Recovery procedure initiated" }  );
          });
        });
      });

    }
    ));

    app.post( hotplate.prefix( '/auth/recover/local' ), function( req, res, next) {
      passport.authenticate('local-recover',  makeResponder( req, res, next, 'local', 'recover')  )(req, res, next);
    });

    // ***********************
    // *** REGISTER        ***
    // ***********************

    passport.use('local-register', new LocalStrategy({
      passReqToCallback: true,
      usernameField: 'login',
    },

    function(req, login, password, done) {

      if( req.session.loggedIn ) return done( null, false );

      // The profile MUST contain an ID
      if( login == '' ){
         return done( null, false, { message: "Username cannot be empty" } );
      }

      // Check that "local" isn't already there
      stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: 'local', field1: login.toLowerCase() } }, { children: true }, function( err, res ){
        if( err ) return done( err );

        if( res.length ) return done( null, false, { message: "Username taken" } );

        stores.users.dbLayer.insert( {}, function( err, user ){
          if( err ) return done( err );

          stores.usersStrategies.dbLayer.insert( { userId: user.id, strategyId: 'local', field1: login.toLowerCase(), field3: password }, function( err, res ){
            if( err ) return done( err );

            // User just registered: make her "logged in"
            req.session.loggedIn = true;
            req.session.userId = res.userId;

            done( null, { id: user.id } );
          });
        });
      });

    }
    ));

    app.post( hotplate.prefix( '/auth/register/local' ), function( req, res, next) {
      passport.authenticate('local-register',  makeResponder( req, res, next, 'local', 'register')  )(req, res, next);
    });

    // ***********************
    // *** RESUME          ***
    // ***********************

    passport.use('local-resume', new LocalStrategy({
      passReqToCallback: true,
      usernameField: 'login',
    },

    function(req, login, password, done) {

      stores.usersStrategies.dbLayer.selectByHash( { conditions: { field1: login.toLowerCase(), field3: password } }, function( err, res ){
        if( err ) return done( err, null );

        if( ! res.length ) return done( null, false );

        req.session.loggedIn = true;
        req.session.userId = res[0].userId;
        done( null, { id: res[ 0 ].id } );
      });

    }
    ));

    app.post( hotplate.prefix( '/auth/resume/local' ), function( req, res, next) {
      passport.authenticate('local-resume',  makeResponder( req, res, next, 'local', 'resume')  )(req, res, next);
    });

    done( null );

  });
}
