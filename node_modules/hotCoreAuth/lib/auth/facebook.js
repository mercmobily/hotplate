"use strict";

/**
This file is a "plugin" for hotCoreAuth, and implements:

* `strategyRoutesMaker( app, strategyName, done )`

Which will create the right routes so that Facebook authentication works.

@class hotCoreAuth.facebook
@static
*/

var dummy
  , path = require('path')
  , hotplate = require('hotplate')

  , hat = require('hat')

  , passport = require('passport')
  , FacebookStrategy = require('passport-facebook').Strategy
  , hotCoreAuth = hotplate.require('hotCoreAuth')
  , hotCoreStoreRegistry = hotplate.require('hotCoreStoreRegistry')
;

var makeResponder = hotCoreAuth.makeResponder;

/**
Returns a function compatible with hotCoreAuth to implement Facebook authentication.
It will set the following routes:

  * Manager: `/auth/manager/facebook`, `/auth/manager/facebook/callback`
  * Signin: `/auth/signin/facebook`, `/auth/manager/signin/callback`
  * Recover: `/auth/recover/facebook`, `/auth/manager/recover/callback`
  * Register: `/auth/register/facebook`, `/auth/manager/register/callback`
  * Resume: `/auth/resume/facebook`, `/auth/manager/resume/callback`

In usersStrategies:

* `field1` is used to store the Facebook profile ID

While managing the passwords, if the client sends `*` as the password, the old password is retained.

@method exports
@param {Object} app Express' `app` variable, used to create routes
@param {String} strategyName The name of the strategy that needs to be setup (e.g. 'facebook')
@param {Object} stores The hash of all available stores. Mainly passed to optimise
*/
exports.strategyRoutesMaker = function( app, strategyName, done ) {

  hotCoreStoreRegistry.getAllStores( function( err, stores ){
    if( err ) return done( err );

    // Get the strategy's data
    var strategyConfig = hotplate.config.get('hotCoreAuth.strategies' )[strategyName];

    // Work out callbackURLBase which needs to be honoured
    var callbackURLBase = hotplate.config.get( 'hotCoreAuth.callbackURLBase' );

    // ***********************
    // *** MANAGER         ***
    // ***********************

    passport.use('facebook-manager', new FacebookStrategy({
      clientID: strategyConfig.clientID,
      clientSecret: strategyConfig.clientSecret,
      callbackURL: callbackURLBase + hotplate.prefix( "/auth/manager/facebook/callback" ),
      passReqToCallback: true,
    },

    function(req, accessToken, refreshToken, profile, done) {

      // User is not logged in: nothing to do
      if( ! req.session.loggedIn ) return done( null, false );

      // The profile MUST contain an ID
      if( typeof( profile ) === 'undefined' || ! profile.id ){
         return done( null, false, { message: "Facebook didn't return a profile ID, procedure aborted" } );
      }

      // Check that the user doesn't already have "facebook" as a strategy
      stores.usersStrategies.dbLayer.selectByHash( { conditions: { userId: req.session.userId, strategyId: 'facebook' } }, function( err, res ){
        if( err ) return done( err, false );
        if( res.length ) return done( null, false, { message: "User already has a Facebook login setup" } );

        // Check that _that_ specific facebook ID is not associated to an account
        stores.usersStrategies.dbLayer.selectByHash( { conditions: { field1: profile.id } }, { children: true }, function( err, res ){
          if( err ) return done( err, false );
          if( res.length ) return  done( null, false, { message: "Facebook profile already linked to another account" } );

          // This is an apiPost so that change is passed through comet to the clients
          stores.usersStrategies.apiPost( { userId: req.session.userId, strategyId: 'facebook', field1: profile.id }, function( err, res ){
            if( err ) return  done( err, false );

            done( null, { id: res.userId }, profile );
          });
        });
      });

    }
    ));

    app.get( hotplate.prefix( '/auth/manager/facebook' ), passport.authenticate('facebook-manager'));
    app.get( hotplate.prefix( '/auth/manager/facebook/callback' ), function( req, res, next) {
      passport.authenticate('facebook-manager',  makeResponder( req, res, next, 'facebook', 'manager')  )(req, res, next);
    });


    // ***********************
    // *** SIGN IN         ***
    // ***********************

    passport.use( 'facebook-signin', new FacebookStrategy({
      clientID: strategyConfig.clientID,
      clientSecret: strategyConfig.clientSecret,
      callbackURL: callbackURLBase + hotplate.prefix( "/auth/signin/facebook/callback" ),
      passReqToCallback: true,
    },

    function( req, accessToken, refreshToken, profile, done ) {

      if( req.session.loggedIn ) return done( null, false );

      // The profile MUST contain an ID
      if( typeof( profile ) === 'undefined' || ! profile.id ){
         return done( null, false, { message: "Facebook didn't return a profile ID, procedure aborted" } );
      }

      stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: 'facebook', field1: profile.id } }, { children: true }, function( err, res ){
        if( err ) return done( err, null );

        if( ! res.length ) return done( null, false, { message: "Your Facebook user is not registered" } );

        req.session.loggedIn = true;
        req.session.userId = res[0].userId;
        done( null, { id: res[0].userId }, profile  );
      })
    }
    ));

    app.get( hotplate.prefix( '/auth/signin/facebook' ), passport.authenticate('facebook-signin'));
    app.get( hotplate.prefix( '/auth/signin/facebook/callback' ), function( req, res, next) {
      passport.authenticate('facebook-signin',  makeResponder( req, res, next, 'facebook', 'signin')  )(req, res, next);
    });

    // ***********************
    // *** RECOVER         ***
    // ***********************

    passport.use('facebook-recover', new FacebookStrategy({
      clientID: strategyConfig.clientID,
      clientSecret: strategyConfig.clientSecret,
      callbackURL: callbackURLBase + hotplate.prefix( "/auth/recover/facebook/callback" ),
      passReqToCallback: true,
    },

    function(req, accessToken, refreshToken, profile, done) {

      if( req.session.loggedIn ) return done( null, false );

      // The profile MUST contain an ID
      if( typeof( profile ) === 'undefined' || ! profile.id ){
         return done( null, false, { message: "Facebook didn't return a profile ID, procedure aborted" } );
      }

      stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: 'facebook', field1: profile.id } }, { children: true }, function( err, res ){
        if( err ) return done( err, null );

        if( res.length ){
          stores.users.dbLayer.selectById( res[0].userId, function( err, user ){
            if( err ) return done( err, null );
            // RECOVER PROCEDURE

            // TODO: emit signal

            // Create the recoveryToken
            user.recoverToken = hat();
            user.recoverTokenCreated = new Date();

            // Place the token in the user's record

            stores.users.dbLayer.updateById( user.id, user, function( err, howMany){
              if( err ) return done( err, null );

              done( null, { id: res[0].userId }, profile );
            });
          });

        } else {
          done( null, false, { message: "Your Facebook user is not registered" } );
        }
      });
    }
    ));

    app.get( hotplate.prefix( '/auth/recover/facebook' ), passport.authenticate('facebook-recover'));
    app.get( hotplate.prefix( '/auth/recover/facebook/callback' ), function( req, res, next) {
      passport.authenticate('facebook-recover',  makeResponder( req, res, next, 'facebook', 'recover')  )(req, res, next);
    });


    // ***********************
    // *** REGISTER        ***
    // ***********************

    passport.use('facebook-register', new FacebookStrategy({
      clientID: strategyConfig.clientID,
      clientSecret: strategyConfig.clientSecret,
      callbackURL: callbackURLBase + hotplate.prefix( "/auth/register/facebook/callback" ),
      passReqToCallback: true,
    },

    function(req, accessToken, refreshToken, profile, done) {

      // User is already logged in: nothing to do
      if( req.session.loggedIn ) return done( null, false );

      // The profile MUST contain an ID
      if( typeof( profile ) === 'undefined' || ! profile.id ){
         return done( null, false, { message: "Facebook didn't return a profile ID, procedure aborted" } );
      }

      // Check that _that_ specific facebook ID is not associated to an account
      stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: 'facebook', field1: profile.id } }, { children: true }, function( err, res ){
        if( err ) return done( err, null );

        if( res.length ) return done( null, false, { message: "Facebook profile already registered" } );

        // Add a user. It's really about creating an ID
        stores.users.dbLayer.insert( {}, function( err, user ){
          if( err ) return done( err, null );

          stores.usersStrategies.dbLayer.insert( { userId: user.id, strategyId: 'facebook', field1: profile.id }, function( err, res ){
            if( err ) return done( err, null );

            // User just registered: make her "logged in"
            req.session.loggedIn = true;
            req.session.userId = res.userId;

            done( null, { id: res.userId }, profile );
          });
        });
      });
    }
    ));

    app.get( hotplate.prefix( '/auth/register/facebook' ), passport.authenticate('facebook-register'));
    app.get( hotplate.prefix( '/auth/register/facebook/callback' ), function( req, res, next) {
      passport.authenticate('facebook-register',  makeResponder( req, res, next, 'facebook', 'register')  )(req, res, next);
    });

    // ***********************
    // *** RESUME          ***
    // ***********************

    passport.use('facebook-resume', new FacebookStrategy({
      clientID: strategyConfig.clientID,
      clientSecret: strategyConfig.clientSecret,
      callbackURL: callbackURLBase + hotplate.prefix( "/auth/resume/facebook/callback" ),
      passReqToCallback: true,
    },

    function( req, accessToken, refreshToken, profile, done) {

      if( req.session.loggedIn ) return done( null, false );

      // The profile MUST contain an ID
      if( typeof( profile ) === 'undefined' || ! profile.id ){
         return done( null, false, { message: "Facebook didn't return a profile ID, procedure aborted" } );
      }

      stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: 'facebook', field1: profile.id } }, { children: true }, function( err, res ){
        if( err ) return done( err, null );

        if( ! res.length ) return done( null, false, { message: "Your Facebook user is not registered" } );

        req.session.loggedIn = true;
        req.session.userId = res[0].userId;

        done( null, { id: res[0].userId }, profile  );
      });

    }
    ));

    app.get( hotplate.prefix( '/auth/resume/facebook' ), passport.authenticate('facebook-resume'));
    app.get( hotplate.prefix( '/auth/resume/facebook/callback' ), function( req, res, next) {
      passport.authenticate('facebook-resume',  makeResponder( req, res, next, 'facebook', 'resume')  )(req, res, next);
    });

    done( null );
  });
}
