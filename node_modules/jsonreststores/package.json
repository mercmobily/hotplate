{
  "name": "jsonreststores",
  "description": "A module to create full Json REST stores in minutes",
  "keywords": [
    "json",
    "REST",
    "Dojo",
    "mongodb"
  ],
  "main": "JsonRestStores.js",
  "version": "0.3.47",
  "private": false,
  "repository": {
    "type": "git",
    "url": "git://github.com/mercmobily/JsonRestStores.git"
  },
  "author": {
    "name": "Tony Mobily"
  },
  "scripts": {
    "test": "nodeunit test-tingo.js"
  },
  "dependencies": {
    "allhttperrors": "0.3.x",
    "simpledeclare": "0.3.x",
    "simpleschema": "0.3.x",
    "async": "~1.5.2"
  },
  "devDependencies": {
    "nodeunit": "~0.9.1",
    "tingodb": "~0.4.x",
    "simpledblayer-tingo": "0.3.x",
    "simpledblayer": "0.3.x"
  },
  "readme": "JsonRestStores\n==============\n\nJsonRestStores is the best way to create REST stores that return JSON data. JsonRestStores is in RC1 status, and the API is locked. Please (find and) file bugs and requests as issues against this repo.\n\nRundown of features:\n\n* **DRY approach**. Create complex applications keeping your code short and tight, without repeating yourself.\n* **Down-to-earth**. It does what developers _actually_ need, using existing technologies.\n* **Database-agnostic**. You can either use a generic database connector, or implement the data-manipulation methods yourself.\n* **Protocol-agnostic**. For now, only HTTP is implemented. However, with JsonRestStores the protocol used to make REST calls doesn't actually matter.\n* **Schema based**. Anything coming from the client will be validated and cast to the right type.\n* **API-ready**. Every store function can be called via API, which bypass permissions constraints\n* **Tons of hooks**. You can hook yourself to every step of the store processing process: `afterValidate()`,   `afterCheckPermissions()`, `afterDbOperation()`, `afterEverything()`\n* **Authentication hooks**. Only implement things once, and keep authentication tight and right.\n* **Mixin-based**. You can add functionality easily.\n* **Inheriting stores**. You can easily derive a store from another one.\n* **Nested data**. Automatically load all child records and lookup records from other stores.\n* **Simple error management**. Errors can be chained up, or they can make the store return them to the client.\n* **Great documentation**. Every aspect of JsonRestStores is carefully explained and documented. Note that every day usage doesn't require knowlege of every single aspect of JsonRestStores.\n\nJsonRestStores even comes with its own database layer mixin, SimpleDbLayerMixin, which will implement all of the important methods that will read, write and delete elements from a database. The mixin uses [simpledblayer](https://github.com/mercmobily/simpledblayer) to access the database. For now, only MongoDb is supported but more will surely come.\n\n# Introduction to (JSON) REST stores\n\nHere is an introduction on REST, JSON REST, and this module. If you are a veteran of REST stores, you can probably just skim through this.\n\n## Implementing REST stores\n\nImagine that you have a web application with bookings, and users connected to each booking, and that you want to make this information available via a JSON Rest API. You would have to define the following routes in your application:\n\n* `GET /bookings/`\n* `GET /bookings/:bookingId`\n* `PUT /bookings/:bookingId`\n* `POST /bookings/`\n* `DELETE /bookings:/bookingId`\n\nAnd then to access users for that booking:\n\n* `GET /bookings/:bookingId/users/`\n* `GET /bookings/:bookingId/users/:userId`\n* `PUT /bookings/:bookingId/users/:userId`\n* `POST /bookings/:bookingId/users/`\n* `DELETE /bookings/:bookingId/users/:userId`\n\nIt sounds simple enough (although it's only two tables and it already looks rather boring). It gets tricky when you consider that:\n\n* You need to make sure that permissions are always carefully checked. For example, only users that are part of booking `1234` can `GET /bookings/1234/users`\n* When implementing `GET /bookings/`, you need to parse the URL in order to enable data filtering (for example, `GET /bookings?dateFrom=1976-01-10&name=Tony` will need to filter, on the database, all bookings made after the 10th of January 1976 by Tony).\n* When implementing `GET /bookings/`, you need to return the right `Content-Range` HTTP headers in your results so that the clients know what range they are getting.\n* When implementing `GET /bookings/`, you also need to make sure you take into account any `Range` header set by the client, which might only want to receive a subset of the data\n* With `POST` and `PUT`, you need to make sure that data is validated against some kind of schema, and return the appropriate errors if it's not.\n* With `PUT`, you need to consider the HTTP headers `If-match` and `If-none-match` to see if you can//should//must overwrite existing records\n* All unimplemented methods should return a `501 Unimplemented Method` server response\n\nThis is only a short list of obvious things: there are many more to consider. The point is, when you make a store you should be focusing on the important parts (the data you gather and manipulate, and permission checking) rather than repetitive, boilerplate code.\n\nWith JsonRestStores, you can create JSON REST stores without ever worrying about any one of those things. You can concentrate on what _really_ matters: your application's data and logic.\n\n## Understand a little about REST stores\n\nIf you are new to REST and web stores, you will probably benefit by reading a couple of important articles. Understanding the concepts behind REST stores will make your life easier.\n\nI suggest you read [John Calcote's article about REST, PUT, POST, etc.](http://jcalcote.wordpress.com/2008/10/16/put-or-post-the-rest-of-the-story/). It's a fantastic read, and I realised that it was written by John, who is a long term colleague and fellow writer at Free Software Magazine, only after posting this link here!\n\nYou should also read my small summary of [what a REST store actually provides](https://github.com/mercmobily/JsonRestStores/blob/master/jsonrest.md).\n\nAt this stage, the stores are 100% compatible with [Dojo's JsonRest](http://dojotoolkit.org/reference-guide/1.8/dojo/store/JsonRest.html) as well as [Sitepen's dstore](http://dstorejs.io/).\n\n# Dependencies overview\n\nJsonreststores is a module that creates managed routes for you, and integrates very easily with existing ExpressJS applications.\n\nHere is a list of modules used by JsonRestStores. You should be at least slightly familiar with them.\n\n* [SimpleDeclare - Github](https://github.com/mercmobily/SimpleDeclare). This module makes creation of constructor functions/classes a breeze. Using SimpleDeclare is a must when using JsonRestStores -- unless you want to drown in unreadable code.\n\n* [SimpleSchema - Github](https://github.com/mercmobily/SimpleSchema). This module makes it easy (and I mean, really easy) to define a schema and validate/cast data against it. It's really simple to extend a schema as well. It's a no-fuss module.\n\n* [Allhttperrors](https://npmjs.org/package/allhttperrors). A simple module that creats `Error` objects for all of the possible HTTP statuses.\n\n* [SimpleDbLayer](https://github.com/mercmobily/simpledblayer). The database layer used to access the database\n\nNote that all of these modules are fully unit-tested, and are written and maintained by me.\n\n**It is recommended that you have a working knowledge of SimpleDbLayer (focusing on querying and automatic loading of children) before delving too deep into JsonRestStores, as JsonRestStores uses the same syntax to create queries and to define nested layers.**\n\n# Your first Json REST store\n\nCreating a store with JsonRestStores is very simple. Here is how you make a fully compliant store, ready to be added to your Express application:\n\n````Javascript\n      var JsonRestStores = require('jsonreststores'); // The main JsonRestStores module\n      var Schema = require('simpleschema');  // The main schema module\n      var SimpleDbLayer = require('simpledblayer');\n      var MongoMixin = require('simpledblayer-mongo')\n      var declare = require('simpledeclare');\n\n      // The DbLayer constructor will be a mixin of SimpleDbLayer (base) and\n      // MongoMixin (providing mongo-specific driver to SimpleDbLayer)\n      var DbLayer = declare( SimpleDbLayer, MongoMixin, { db: db } );\n\n      // Basic definition of the managers store\n      var Managers = declare( JsonRestStores, JsonRestStores.HTTPMixin, JsonRestStores.SimpleDbLayerMixin, {\n\n        // Constructor class for database-access objects, which in this case\n        // will access MongoDNB collections\n        DbLayer: DbLayer,\n\n        schema: new Schema({\n          name   : { type: 'string', trim: 60 },\n          surname: { type: 'string', searchable: true, trim: 60 },\n        }),\n\n        storeName: 'managers',\n        publicURL: '/managers/:id',\n\n        handlePut: true,\n        handlePost: true,\n        handleGet: true,\n        handleGetQuery: true,\n        handleDelete: true,\n      });\n\n      var managers = new Managers();\n\n      JsonRestStores.init();\n      managers.protocolListen( 'HTTP', { app: app } );;\n````\n\nNote that since you will be mixing in `JsonRestStores` with `JsonRestStores.HTTPMixin` and `JsonRestStores.SimpleDbLayerMixin` for every single store you create (more about mixins shortly), you might decide to create the mixin once for all making the code less verbose:\n\n````Javascript\n    var JsonRestStores = require('jsonreststores'); // The main JsonRestStores module\n    var Schema = require('simpleschema');  // The main schema module\n    var SimpleDbLayer = require('simpledblayer');\n    var MongoMixin = require('simpledblayer-mongo')\n    var declare = require('simpledeclare');\n\n    // The DbLayer constructor will be a mixin of SimpleDbLayer (base) and\n    // MongoMixin (providing mongo-specific driver to SimpleDbLayer)\n    var DbLayer = declare( SimpleDbLayer, MongoMixin, { db: db } );\n\n    // Mixin of JsonRestStores, JsonRestStores.HTTPMixin and JsonRestStores.SimpleDbLayerMixin\n    // with the DbLayer parameter already set\n    var Store = declare( JsonRestStores, JsonRestStores.HTTPMixin, JsonRestStores.SimpleDbLayerMixin, { DbLayer: DbLayer } );\n\n    // Basic definition of the managers store\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n\n    var managers = new Managers();\n\n    JsonRestStores.init();\n    protocolListen( 'HTTP', { app: app } );\n````\n\nThat's it: this is enough to add, to your Express application, a a full store which will handly properly all of the HTTP calls.\n\n* `Managers` is a new constructor function that inherits from `JsonRestStores` (the main constructor for JSON REST stores) mixed in with `JsonRestStores.HTTPMixin` (which ensures that `protocolListen()` works with the `HTTP` parameter, allowing clients to connect using HTTP) and `JsonRestStores.SimpleDbLayerMixin` (which gives `JsonRestStores` the ability to manipulate data on a database automatically).\n* `DbLayer` is a SimpleDbLayer constructor mixed in with `MongoMixin`, the MongoDB-specific layer for SimpleDbLayer. So, `DbLayer` will be used by `Managers` to manipulate MongoDB collections.\n* `schema` is an object of type Schema that will define what's acceptable in a REST call.\n* `publicURL` is the URL the store is reachable at. ***The last one ID is the most important one***: the last ID in `publicURL` (in this case it's also the only one: `id`) defines which field, within your schema, will be used as _the_ record ID when performing a PUT and a GET (both of which require a specific ID to function).\n* `storeName` (_mandatory_) needs to be a unique name for your store.\n* `handleXXX` are attributes which will define how your store will behave. If you have `handlePut: false` and a client tries to PUT, they will receive an `NotImplemented` HTTP error.\n* `protocolListen( 'HTTP', { app: app } )` creates the right Express routes to receive HTTP connections for the `GET`, `PUT`, `POST` and `DELETE` methods.\n* `JsonRestStores.init()` should _always_ be run once you have declared all of your stores. This function will run the initialisation code necessary to make nested stores work properly.\n\n\n## The store live in action in your express application\n\nJsonRestStores is very unobtrusive of your Express application. In order to make everything work, you can just:\n\n * Generate a new ExpressJS application\n * Connect to the database\n * Define the stores using the code above.\n\nThis is how the stock express code would change to implement the store above (please note that this is mostly code autogenerated when you generate an Express application):\n\n````Javascript\n    var express = require('express');\n    var path = require('path');\n    var favicon = require('serve-favicon');\n    var logger = require('morgan');\n    var cookieParser = require('cookie-parser');\n    var bodyParser = require('body-parser');\n\n    var routes = require('./routes/index');\n    var users = require('./routes/users');\n\n    var app = express();\n\n    // CHANGED: ADDED AN INCLUDE `dbConnect`\n    var dbConnect = require('./dbConnect');\n\n    // view engine setup\n    app.set('views', path.join(__dirname, 'views'));\n    app.set('view engine', 'jade');\n\n    // uncomment after placing your favicon in /public\n    //app.use(favicon(__dirname + '/public/favicon.ico'));\n    app.use(logger('dev'));\n    app.use(bodyParser.json());\n    app.use(bodyParser.urlencoded({ extended: false }));\n    app.use(cookieParser());\n    app.use(express.static(path.join(__dirname, 'public')));\n\n    app.use('/', routes);\n    app.use('/users', users);\n\n    // CHANGED: Added call to dbConnect, and waiting for the db\n    dbConnect( function( db ){\n\n      // ******************************************************\n      // ********** CUSTOM CODE HERE **************************\n      // ******************************************************\n\n      var JsonRestStores = require('jsonreststores'); // The main JsonRestStores module\n      var Schema = require('simpleschema');  // The main schema module\n      var SimpleDbLayer = require('simpledblayer');\n      var MongoMixin = require('simpledblayer-mongo')\n      var declare = require('simpledeclare');\n\n      // The DbLayer constructor will be a mixin of SimpleDbLayer (base) and\n      // MongoMixin (providing mongo-specific driver to SimpleDbLayer)\n      var DbLayer = declare( SimpleDbLayer, MongoMixin, { db: db } );\n\n      // Common mixin of JsonRestStores, JsonRestStores.SimpleDbLayerMixin and the DbLayer parameter\n      // already set\n\n      var Store = declare( JsonRestStores, JsonRestStores.SimpleDbLayerMixin, { DbLayer: DbLayer } );\n\n      var Managers = declare( Store, {\n\n        schema: new Schema({\n          name   : { type: 'string', trim: 60 },\n          surname: { type: 'string', searchable: true, trim: 60 },\n        }),\n\n        storeName: 'managers',\n        publicURL: '/managers/:id',\n\n        handlePut: true,\n        handlePost: true,\n        handleGet: true,\n        handleGetQuery: true,\n        handleDelete: true,\n      });\n      var managers = new Managers();\n\n      JsonRestStores.init();\n      managers.protocolListen( 'HTTP', { app: app } );;\n\n      // ******************************************************\n      // ********** END OF CUSTOM CODE      *******************\n      // ******************************************************\n\n      // catch 404 and forward to error handler\n      app.use(function(req, res, next) {\n          var err = new Error('Not Found');\n          err.status = 404;\n          next(err);\n      });\n\n      // error handlers\n\n      // development error handler\n      // will print stacktrace\n      if (app.get('env') === 'development') {\n          app.use(function(err, req, res, next) {\n              res.status(err.status || 500);\n              res.render('error', {\n                  message: err.message,\n                  error: err\n              });\n          });\n      }\n\n      // production error handler\n      // no stacktraces leaked to user\n      app.use(function(err, req, res, next) {\n          res.status(err.status || 500);\n          res.render('error', {\n              message: err.message,\n              error: {}\n          });\n      });\n\n\n    });\n    module.exports = app;\n````\n\nThe `dbConnect.js` file is simply something that will connect to the database and all the callback with the `db` instance:\n\n    var mongo = require('mongodb');\n    exports = module.exports = function( done ){\n      // Connect to the database\n      mongo.MongoClient.connect('mongodb://localhost/storeTesting', {}, function( err, db ){\n        if( err ){\n          console.error( \"Error connecting to the database: \", err );\n          process.exit( 1 );\n        }\n        return done( db );\n      });\n    }\n\nThis store is _actually_ fully live and working! It will manipulate your database and will respond to any HTTP requests appropriately.\n\nA bit of testing with `curl`:\n\n    $ curl -i -XGET  http://localhost:3000/managers/\n    HTTP/1.1 200 OK\n    X-Powered-By: Express\n    Content-Type: application/json; charset=utf-8\n    Content-Length: 2\n    ETag: \"223132457\"\n    Date: Mon, 02 Dec 2013 02:20:21 GMT\n    Connection: keep-alive\n\n    []\n\n    curl -i -X POST -d \"name=Tony&surname=Mobily\"  http://localhost:3000/managers/\n    HTTP/1.1 201 Created\n    X-Powered-By: Express\n    Location: /managers/2\n    Content-Type: application/json; charset=utf-8\n    Content-Length: 54\n    Date: Mon, 02 Dec 2013 02:21:17 GMT\n    Connection: keep-alive\n\n    {\n      \"id\": 2,\n      \"name\": \"Tony\",\n      \"surname\": \"Mobily\"\n    }\n\n    curl -i -X POST -d \"name=Chiara&surname=Mobily\"  http://localhost:3000/managers/\n    HTTP/1.1 201 Created\n    X-Powered-By: Express\n    Location: /managers/4\n    Content-Type: application/json; charset=utf-8\n    Content-Length: 54\n    Date: Mon, 02 Dec 2013 02:21:17 GMT\n    Connection: keep-alive\n\n    {\n      \"id\": 4,\n      \"name\": \"Chiara\",\n      \"surname\": \"Mobily\"\n    }\n\n    $ curl -i -GET  http://localhost:3000/managers/\n    HTTP/1.1 200 OK\n    X-Powered-By: Express\n    Content-Type: application/json; charset=utf-8\n    Content-Length: 136\n    ETag: \"1058662527\"\n    Date: Mon, 02 Dec 2013 02:22:29 GMT\n    Connection: keep-alive\n\n    [\n      {\n        \"id\": 2,\n        \"name\": \"Tony\",\n        \"surname\": \"Mobily\"\n      },\n      {\n        \"id\": 4,\n        \"name\": \"Chiara\",\n        \"surname\": \"Mobily\"\n      }\n    ]\n\n\n    $ curl -i -GET  http://localhost:3000/managers/?surname=mobily\n    HTTP/1.1 200 OK\n    X-Powered-By: Express\n    Content-Type: application/json; charset=utf-8\n    Content-Length: 136\n    ETag: \"15729456527\"\n    Date: Mon, 02 Dec 2013 02:22:35 GMT\n    Connection: keep-alive\n\n    [\n      {\n        \"id\": 2,\n        \"name\": \"Tony\",\n        \"surname\": \"Mobily\"\n      },\n      {\n        \"id\": 4,\n        \"name\": \"Chiara\",\n        \"surname\": \"Mobily\"\n      }\n    ]\n\n    $ curl -i -GET  http://localhost:3000/managers/?surname=fabbietti\n    HTTP/1.1 200 OK\n    X-Powered-By: Express\n    Content-Type: application/json; charset=utf-8\n    Content-Length: 2\n    ETag: \"1455673456\"\n    Date: Mon, 02 Dec 2013 02:22:42 GMT\n    Connection: keep-alive\n\n    []\n\n    $ curl -i -X PUT -d \"name=Merc&surname=Mobily\"  http://localhost:3000/managers/2\n    HTTP/1.1 200 OK\n    X-Powered-By: Express\n    Location: /managers/2\n    Content-Type: application/json; charset=utf-8\n    Content-Length: 54\n    Date: Mon, 02 Dec 2013 02:23:50 GMT\n    Connection: keep-alive\n\n    {\n      \"id\": 2,\n      \"name\": \"Merc\",\n      \"surname\": \"Mobily\"\n    }\n\n    $ curl -i -XGET  http://localhost:3000/managers/2\n    HTTP/1.1 200 OK\n    X-Powered-By: Express\n    Content-Type: application/json; charset=utf-8\n    Content-Length: 54\n    ETag: \"-264833935\"\n    Date: Mon, 02 Dec 2013 02:24:58 GMT\n    Connection: keep-alive\n\n    {\n      \"id\": 2,\n      \"name\": \"Merc\",\n      \"surname\": \"Mobily\"\n    }\n\nIt all works!\n\n## Clarification on mixins\n\nMixins are a powerful way to specialise a generic constructor.\n\nFor example, the constructor `JsonRestStores` on its own is hardly useful as it doesn't allow you to wait for request and actually serve them. On its own, calling `protocolListen( 'HTTP', { app: app } );` will fail, because `protocolListen()` will attempt to run the method `protocolListenHTTP( { app: app } )`, which isn't defined.\n\nThe good news is that the mixin `JsonRestStores.HTTPMixin` implements `protocolListenHTTP()` (as well as the corresponding `protocolSendHTTP()`), which makes `protocolListen( 'HTTP', { app: app } );` work.\n\nYou can mix a store with as many protocol mixins as you like (although at this stage only HTTP is currently implemented).\n\n`HTTPMixin` is only one piece of the puzzle: on its own, it's not enough. JsonRestStores mixed with `HTTPMixin`\n creates JSON REST stores with the following data-manipulation methods left unimplemented (they will throw an error if they are run):\n\n * `implementFetchOne: function( request, cb )`\n * `implementInsert: function( request, forceId, cb )`\n * `implementUpdate: function( request, deleteUnsetFields, cb )`\n * `implementDelete: function( request, cb )`\n * `implementQuery: function( request, next )`\n * `implementReposition: function( doc, where, beforeId, cb )`\n\nImplementing these methods is important to tell `JsonRestStores` how to actualy manipulate the store's data. [You can do it yourself by hand](#naked-non-database-stores), but if you want to save a few hundred hours, this is exactly what `JsonRestStores.SimpleDbLayerMixin` does: it's a mixin that enriches the basic `JsonRestStore` objects with all of the methods listed above, using a database as data storage.\n\nSo when you write:\n\n    var Managers = declare( JsonRestStores, JsonRestStores.HTTPMixin, JsonRestStores.SimpleDbLayerMixin, {\n\nYou are creating a constructor, `Managers`, mixing in the prototypes of `JsonRestStores` (the generic, unspecialised constructor for Json REST stores), `HTTPMixin` (which makes `protocolListen( 'HTTP', { app: app } );` work) and `JsonRestStores.SimpleDbLayerMixin` (which provides the implementations of `implementFetchOne()`, `implementInsert()`, etc. to manipulate data).\n\n`SimpleDbLayerMixin` will use the `DbLayer` attribute of the store as the constructor used to create \"table\" objects, and will manipulate data with them.\n\n`DbLayer` itself is created using the same pattern as `Managers`.\n\nSimpleDbLayer on its own is useless: it creates a DB layer with the following methods left unimplemented:\n\n* `select( filters, options, cb )`\n* `update( conditions, updateObject, options, cb )`\n* `insert( record, options, cb )`\n* `delete( conditions, options, cb )`\n* `reposition: function( record, where, beforeId, cb )`\n\nThe implementation will obviously depend on the database layer. So, when you type:\n\n    var DbLayer = declare( SimpleDbLayer, MongoMixin );\n\nYou are creating a constructor, `DbLayer`, that is the mixin of `SimpleDbLayer` (where `select()` `update()` etc. are not implemented) and `MongoMixin` (which implements `select()`, `update()` etc. using MongoDB as the database layer).\n\nThis is the beauty of mixins: they implement the missing methods in a generic, unspecialised constructor.\n\n## A note on `publicURL` and `paramIds`\n\nWhen you define a store like this:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      hardLimitOnQueries: 50,\n    });\n\n    managers.protocolListen( 'HTTP', { app: app } );;\n\nThe `publicURL` is used to:\n\n* Add `id: { type: id }` to the schema automatically. This is done so that you don't have to do the grunt work of defining `id` in the schema if they are already in `publicURL`.\n* Create the `paramIds` array for the store. In this case, `paramIds` will be `[ 'id' ]`.\n\nSo, you could reach the same goal without `publicURL`:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        id     : { type: 'id' },\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', trim: 60 },\n      }),\n\n      storeName: 'managers',\n      paramIds: [ 'id' ],\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      hardLimitOnQueries: 50,\n    });\n\n    var managers = new Managers();\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );; // This will throw()\n\nNote that:\n * The `id` parameter had to be defined in the schema\n * The `paramIds` array had to be defined by hand\n * `managers.protocolListen( 'HTTP', { app: app } );` can't be used as the public URL is not there\n\nThis pattern is much more verbose, and it doesn't allow the store to be placed online with `protocolListen()`.\n\nIn any case, the property `idProperty` is set as last element of `paramIds`; in this example, it is `id`.\n\nIn the documentation, I will often refers to `paramIds`, which is an array of element in the schema which match the ones in the route. However, in all examples I will declare stores using the \"shortened\" version.\n\n# How stores work: a walk-through\n\nHere is a walk-through on how stores actually work, and how requests are fulfilled. Note that this refers very specifically to stores mixing in with HTTPMixin and with SimpleDbLayerMixin.\n\n## Store definition\n\nWhen you define a store like this:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      hardLimitOnQueries: 50,\n    });\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n\n## Request listening\n\nThe last line is the one that makes the store \"active\": `managers.protocolListen()` will actually run `managers.protocolListenHTTP()`, which is defined thanks to HTTPMixin.\n`protocolListenHTTP()` will define the appropriate routes using Express' `app` (passed to it as a parameter).\nThe code in HTTPMixin looks like this:\n\n````Javascript\n    // Make entries in \"app\", so that the application\n    // will give the right responses\n    app.get(      url + id, this._getRequestHandler( 'Get' ) );\n    app.get(      url,      this._getRequestHandler( 'GetQuery') );\n    app.put(      url + id, this._getRequestHandler( 'Put') );\n    app.post(     url,      this._getRequestHandler( 'Post') );\n    app.delete(   url + id, this._getRequestHandler( 'Delete') );\n````\nSo, the following routes are defined:\n\n    GET /managers/:id -- returns a specific manager. Handler: `store._makeGet()`\n    GET /managers/ -- returns a collection of elements; you can filter by surname, which is searchable. Handler: `store._makeGetQuery()`\n    PUT /managers/:id -- writes over an existing manager object. Handler: `store._makePut()`\n    POST /managers/ -- creates a new manager object. Handler: `store._makePost()`\n    DELETE /managers/:id -- deletes a manager. Handler: `store._makeDelete()`\n\n## Receiving the request\n\nThe method `this._getRequestHandler()`, also defined in HTTPMixin, will be responsible of creating a plain Javascript object called `request`, and enrich it with the following attributes:\n\n* `remote`: Set to `true`.\n* `protocol`: set to HTTP.\n* `params`: set to the URL parameters. For example, a request like this: `PUT /managers/10/cars/20` will have `params` set as `{ managerId: 10, id: 20 }`\n* `body`: set to the request's `body`.\n* `session`: set to the request's session.\n* `options`: set based on the request's query string and headers, see the next section for more details\n* `_req` and `_res`: set to the request's `req` and `res` parameters -- this is specific to HTTPMixin.\n\nAfter defining this object, `this._getRequestHandler()` will finally be ready to call one of the following methods (depending on the method):\n\n * `_makeGet( request, next )` (implements GET for one single document)\n * `_makeGetQuery( request, next )` (implements GET for a collection, no ID passed)\n * `_makePut( request, next )` (implements PUT for a collection)\n * `_makePost( request, next )` (implements POST for a collection)\n * `_makeDelete( request, next )` (implements DELETE for a collection)\n\nThese methods are the heart of JsonRestStores: they will handle the request by calling `implementFetchOne()`, `implementInsert()`, `implementUpdate()`, `implementDelete()`, `implementQuery()` and `implementReposition()` (conveniently provided in this case by SimpleDbLayerMixin).\n\n### The `options` object\n\nThe `options` object is the most complex and the most useful.\nEach request handlers will consider different attributes:\n\n#### `_makePut()`\n  * `putBefore`. If set, and if the store supports positioning, the entry will be placed before the entry with id `putBefore`.\n  * `putDefaultPosition`. If set, and if the store supports positioning, this option will instruct JsonRestStores where to place the entry: `start` or `end` (only used when `putBefore` isn't set)\n  * `overwrite`. If set to `true`, the `put` will only be successful if the record is an existing one. If set to `false`, the `put` will only be successful if the record didn't exist. If not set, the `put` will work either way.\n\n#### `_makePost()`\n  * `putBefore`. Same as the handler `_makePut`\n  * `putDefaultPosition`. Same as the handler `_makePut`\n\n#### `_makeGetQuery()`:\n  * `conditions`. An hash object containing the filter criteria, which will have to match `onlineSearchSchema`.\n  * `ranges`. It can have `skip` and `count`.\n  * `sort`. An hash that defines how to sort the query. For example `{ model: -1, maker: 1 }`. Note that each key needs to be listed in the `sortableFields` element of the store.\n  * `skipHardLimitOnQueries`. If set to `true`, the attribute `hardLimitOnQueries` will be ignored when making `getQuery` calls.\n  * `delete`. If set to `true`, each record will be deleted after retrieval. Note that if the store's `self.deleteAfterGetQuery` is set to `true`, then `delete` will automatically be set to true for each request.\n\n### How HTTPMixin creates the `options` object\n\nProtocol mixins (in this case, HTTPMixin) have the task of accepting the request, and make sure that the `options` object passed to the request handler is adequately filled depending on the request itself.\n\nSpecifically:\n\n### `_makePut`\n  * `putBefore`. From header `x-put-before`\n  * `putDefaultPosition`. From header `x-put-default-position`\n  * `overwrite`. If the header `if-match` is set to `*`, it's set to true. If the header `if-none-match` is set to `*`, is set to false.\n\n### `_makePost`\n  * `putBefore`. Same as the handler `_makePut`\n  * `putDefaultPosition`. Same as the handler `_makePut`\n\n### `_makeGetQuery`:\n  * `conditions`. Worked out from the query string.\n  * `ranges`. Worked out from the `range` header; if the header is `3-10`, then `ranges` will be assigned `skip: 3, limit: 8 }` (it will skip to the third element, and will fetch 8 elements at the most).\n  * `sort`. Worked out from the `sortBy` element in the query string; if it is for example `?sortBy=-model,+maker`, `options.sort` will be `{ model: -1, maker: 1 }`.\n\nPlease note that you can easily overload the specific methods in HTTPMixin if you want store parameters to be taken from the store differently.\n\n## Sending the response back to the client\n\nThe `_make???()` request handlers will use the `self.sendData(  request, method, returnObject );` method to send data out to the client.  `sendData()`, in turn, will call `protocolSendHTTP( request, method, returnObject )`. This method has has access to the `request` attribute, which (as mentioned earlier) was assigned `_req` and `_res`. `req._res` is used by `protocolSendHTTP()` to set the right HTTP headers and status, and deliver the response to the client:\n\n* status is `200` by default.\n* if there is an error (the method is set as `error`, and `returnObject` is therefore an Error object), the status is set to the `httpError` attribute of the error, and the response will be the `responseBody` attribute of the error.\n* `post` and `putNew` and `putExisting` methods will set the `Location` header\n* `post` and `putNew` will set the status to 201. `delete` will set the status to `204`.\n* `getQuery` will set the `Content-Range` headers, like `items 3-10/100` (which will tell the client what was actually fetched in terms of range, and what the total count is).\n*\n\n# A nested store\n\nStores are never \"flat\" as such: you have workspaces, and then you have users who \"belong\" to a workspace. Here is how you create a \"nested\" store:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n    var managers = new Managers();\n\n    var ManagersCars = declare( Store, {\n\n      schema: new Schema({\n        make     : { type: 'string', trim: 60, required: true },\n        model    : { type: 'string', trim: 60, required: true },\n      }),\n\n      storeName: 'managersCars',\n      publicURL: '/managers/:managerId/cars/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n    var managersCars = new ManagersCars();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n    managersCars.protocolListen( 'HTTP', { app: app } );;\n\nYou have two stores: one is the simple `managers` store with a list of names and surname; the other one is the `managersCars` store: note how the URL for `managersCars` includes `managerId`.\n\nThe managersCars store will will respond to `GET /managers/2222/cars/3333` (to fetch car 3333 of manager 2222), `GET /workspace/2222/users` (to get all cars of manager 2222), and so on.\n\nRemember that in `managersCars` _remote queries will **always** honour the filter on `managerId`, both in queries (`GET` without an `id` as last parameter) and single-record operations_ (`GET` with a specific `id`). This happens thanks to SimpleDbLayerMixin (more about this later).\n\n## Fetching children records automatically in nested stores\n\nIf you have two nested tables like the ones shown above, you might want to be able to look up fields automatically. JsonRestStores allows you to to so using the `nested` property.\n\nFor example:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      nested: [\n        {\n          type: 'multiple',\n          store: 'managersCars',\n          join: { managerId: 'id' },\n        }\n      ],\n\n    });\n    var managers = new Managers();\n\n    var ManagersCars = declare( Store, {\n\n      schema: new Schema({\n        make     : { type: 'string', trim: 60, required: true },\n        model    : { type: 'string', trim: 60, required: true },\n      }),\n\n      storeName: 'managersCars',\n      publicURL: '/managers/:managerId/cars/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      nested: [\n        {\n          type: 'lookup',\n          localField: 'managerId',\n          store: 'managers',\n        }\n      ],\n    });\n    var managersCars = new ManagersCars();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n    managersCars.protocolListen( 'HTTP', { app: app } );;\n\nThis is an example where using JsonRestStores really shines: when you use `GET` to fetch a manager, the object's attribute `manager._children.managersCars` will be an array of all cars joined to that manager. Also, when you use `GET` to fetch a car, the object's attribute `car._children.managerId` will be an object representing the correct manager. This is immensely useful in web applications, as it saves tons of HTTP calls for lookups. **NOTE**: The child's store's `extrapolateDoc()` and `prepareBeforeSend()` methods _will_ be called on the child's data (as you would expect). Keep in mind that when those methods are being called on bested data, `request.nested` will be set to true.\n\nNote that in `nested` objects the store names are passed as _strings_, rather than objects; this is important: in this very example, you can see `store: 'managersCars',` as a nested store, but at that point `managersCars` hasn't been declared yet. The store names in `nested` will be resolved later, by the `JsonRestStores.init()` function, using JsonRestStores' registry for the lookup. This is why it's crucial to run `JsonRestStores.init()` only when _all_ of your stores have been created (and are therefore in the registry).\n\nFetching of nested data is achieved by SimpleDbLayerMixin by using [SimpleDbLayer's nesting abilities](https://github.com/mercmobily/simpledblayer#automatic-loading-of-children-joins), which you should check out. If you do check it out, you will see strong similarities between JsonRestStores' `nested` parameter and `SimpleDbLayer`. If you have used nested parameters in SimpleDbLayer, then you easily see that  JsonRestStores will simply make sure that the required attribute for `nested` entries are there; for each `nested` entry it will add a `layer` property (based on the store's own `collectionName`) and a `layerField` property (based on the store's own `idProperty`).\n\n# Naming conventions for stores\n\nIt's important to be consistent in naming conventions while creating stores. In this case, code is clearer than a thousand bullet points:\n\n## Naming convertions for simple stores\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        // ...\n      });\n\n      publicUrl: '/managers/:id',\n\n      storeName: `managers`\n      // ...\n    }\n    var managers = new Managers();\n\n    var People = declare( Store, {\n\n      schema: new Schema({\n        // ...\n      });\n\n      publicUrl: '/people/:id',\n\n      storeName: `people`\n      // ...\n    }\n    var people = new People();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n    people.protocolListen( 'HTTP', { app: app } );;\n\n* Store names anywhere lowercase and are plural (they are collections representing multiple entries)\n* Irregulars (`Person` => `People`) are a fact of life\n* Store constructors (derived from `Store`) are in capital letters (as constructors, they should be)\n* Store variables are in small letters (they are normal object variables)\n* `storeName` attributes are in small letters (to follow the lead of variables)\n* URL are in small letters (following the stores' names, since everybody knows that `/Capital/Urls/Are/Silly`)\n\n## Naming conventions for nested stores\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        // ...\n      });\n\n      publicUrl: '/managers/:id',\n\n      storeName: `managers`\n      // ...\n    }\n    var managers = new Managers();\n\n    var ManagersCars = declare( Store, {\n\n      schema: new Schema({\n        // ...\n      });\n\n      publicUrl: '/managers/:managerId/cars/:id',\n\n      // ...\n      storeName: `managersCars`\n      // ...\n    }\n    var managerCars = new ManagersCars();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n    managerCars.protocolListen( 'HTTP', { app: app } );;\n\n\n* The nested store's name starts with the parent store's name (`managers`) keeping pluralisation\n* The URL is in small letters, starting with the URL of the parent store\n\n# Customise search rules\n\nIn the previous examples, I explained how marking a field as `searchable` in the schema has the effect of making it searchable in queries:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n\n    var managers = new Managers();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n\n\nIf you query the store with `http://localhost:3000/managers/?surname=mobily`, it will only return elements where the `surname` field matches.\n\n## Custom `onlineSearchSchema`\n\nIn JsonRestStores you actually define what fields are acceptable as filters with the parameter `onlineSearchSchema`, which is defined exactly as a schema. So, writing this is equivalent to the code just above:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 },\n      }),\n\n      onlineSearchSchema: new Schema( {\n        surname: { type: 'string', trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n\n    var managers = new Managers();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n\nIf `onlineSearchSchema` is not defined, JsonRestStores will create one based on your main schema by doing a shallow copy, excluding `paramIds` (which means that, in this case, `id` is not added automatically to `onlineSearchSchema`, which is most likely what you want).\n\nIf you define your own `onlineSearchSchema`, you are able to decide exactly how you want to filter the values. For example you could define a different default, or trim value, etc. However, in common applications you can probably live with the auto-generated `onlineSearchSchema`.\n\n## Custom `queryConditions`\n\nYou can decide how the elements in `onlineSearchSchema` will be turned into a search with the `queryConditions` parameter.\n\n`queryConditions` is normally automatically generated for you if it's missing. So, not passing it is the same as writing:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 },\n      }),\n\n      onlineSearchSchema: new Schema( {\n        surname: { type: 'string', trim: 60 },\n      }),\n\n      queryConditions: {\n        type: 'eq',\n        args: [ 'surname', '#surname#']\n      },\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n\n    var managers = new Managers();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n\nBasically, `queryConditions` is automatically generated with the `name` field in the database that matches the `name` entry in the query string (that's what `#name#` stands for).\n\nRemember that here:\n\n    queryConditions: {\n      type: 'eq',\n      args: [ 'surname', '#surname#']\n    },\n\n`surname` refers to the database field `surname`, whereas `#surname#` refers to the query string's `surname` element (which is cast thanks to `onlineSearchSchema`.\n\nIf you had defined both `name` and `surname` as searchable, `queryConditions` would have been generated as:\n\n    queryConditions: {\n        type: 'and',\n        args: [\n          { type: 'eq', args: [ 'name', '#name#' ] },\n          { type: 'eq', args: [ 'surname', '#surname#' ]\n        ]\n      },\n\nBasically, _both_ `name` and `surname` need to match their respective values in the query string. To know more about the syntax of `queryConditions`, please have a look at [the conditions object in SimpleDbLayer](https://github.com/mercmobily/simpledblayer#the-conditions-object).\n\nYou can effectively create _any_ kind of query based on the passed parameter. For exampe, you could create a `searchAll` field like this:\n\n    onlineSearchSchema: new Schema( {\n      searchAll: { type: 'string', trim: 60 },\n    }),\n\n    queryConditions: {\n      type: 'or',\n      ifDefined: 'searchAll',\n      args: [\n        { type: 'startsWith', args: [ 'number', '#searchAll#' ] },\n        { type: 'startsWith', args: [ 'firstName', '#searchAll#' ] },\n        { type: 'startsWith', args: [ 'lastName', '#searchAll#' ] },\n      ]\n    },\n\nThis example highlights that `onlineSearchSchema` fields don't have to match existing fields in the schema: they can be _anything_, which is then used as a `#field#` value in `queryConditions`. They are basically values that will be used when constructing the actual query in `queryConditions`.\n\nKeep in mind that the syntax of JsonRestStore's `queryConditions` is identical to the syntax of the `conditions` object in SimpleDbLayer, with the following extras:\n\n1) Value resolution\n\nIn JsonRestStores, when a value is in the format `#something#`, that `something` will be replaced by the value in the corresponding value in the query string when making queries. _If `something` is not passed in the query string, that section of the query is ignored._\n\n2) `ifDefined` to filter out chunks\n\nYou can have the attribute `ifDefined` set as a value in `queryConditions`: in this case, that section of the query will only be evaluated if the corresponding value in the query string is defined.\n\nFor example, you could define `queryConditions` as:\n\n    queryConditions: {\n      type: 'and',\n      args: [\n\n        {\n          type: 'and', ifDefined: 'surname', args: [\n            { type: 'startsWith', args: [ 'surname', '#surname#' ] },\n            { type: 'eq', args: [ 'active', true ] },\n          ]\n        },\n\n        {\n          type: 'startsWith', args: [ 'name', '#name#']\n        }\n      ]\n    },\n\nThe strings `#surname#` and `#name#` are translated into their corresponding values in the query string. The `ifDefined` means that that whole section of the query will be ignored unless `surname` is passed to the query string. The comparison operators, which were `eq` in the generated `queryConditions`, are now much more useful `startsWith`.\n\n3) The immensely useful `each` statement\n\nYou will often want to break down a string into words, and then use those individual words in your search criteria. This is what `each` is for. This will be a much more powerful implementation of `searchAll`:\n\n    onlineSearchSchema: new Schema( {\n      searchAll: { type: 'string', trim: 60 },\n      userId: { type: 'id' }\n    }),\n\n    queryConditions: {\n      type: 'or',\n      ifDefined: 'searchAll',\n      args: [\n        { type: 'startsWith', args: [ 'number', '#searchAll#' ] },\n        { type: 'startsWith', args: [ 'firstName', '#searchAll#' ] },\n        { type: 'startsWith', args: [ 'lastName', '#searchAll#' ] },\n      ]\n    },\n\n    var initialQueryConditions = {\n      type: 'and',\n      args: [\n\n        // First: filter by userId if passed\n        { type: 'eq', args: [ 'userId', '#userId#'] },\n\n        // Second: must satisfy _each_ condition based on the breakdown of #searchAll#, space-separated\n        { type: 'each', value: 'searchAll', as: 'searchAllEach', linkType: 'and', separator: ' ', args: [\n          { type: 'or', args: [\n            { type: 'contains', args: [ 'title', '#searchAllEach#' ] },\n            { type: 'contains', args: [ 'videosTags.tagName', '#searchAllEach#' ] },\n          ]},\n        ]},\n      ]\n    };\n\nNote that it comes with defaults, so that the `each` line could have looked like this:\n\n    { type: 'each', value: 'searchAll', args: [\n\nSince `linkType` defaults to `and`, the separator defaults to a space, and the `as` field defaults to the name of the value with `Each` added at the end.\n\n`queryConditions` is basically a very powerful engine that will generate the queries for you based on what parameters were passed.\n\n## Nested data and queries\n\nThanks to `queryConditions` you can define any kind of query you like. The good new is that you can also search in _children_ tables that are defined as `nested` in the store definitions.\n\nFor example:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', searchable: true, trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      onlineSearchSchema: new HotSchema({\n        name    : { type: 'string', trim: 60 },\n        surname : { type: 'string', trim: 60 },\n        carInfo : { type: 'string', trim: 30 },\n      }),\n\n      queryConditions: {\n        type: 'and',\n        args: [\n\n          {\n            type: 'startsWith', args: [ 'surname', '#surname#']\n          },\n\n          {\n            type: 'or',\n            ifDefined: 'carInfo',\n            args: [\n              { type: 'startsWith', args: [ 'managersCars.make', '#carInfo#' ] },\n              { type: 'startsWith', args: [ 'managersCars.model','#carInfo#' ] },\n            ]\n          }\n        ]\n      },\n\n      nested: [\n        {\n          type: 'multiple',\n          store: 'managersCars',\n          join: { managerId: 'id' },\n        }\n      ],\n\n    });\n    var managers = new Managers();\n\n    var ManagersCars = declare( Store, {\n\n      schema: new Schema({\n        make     : { type: 'string', trim: 60, searchable: true, required: true },\n        model    : { type: 'string', trim: 60, searchable: true, required: true },\n      }),\n\n      onlineSearchSchema: new HotSchema({\n        make       : { type: 'string', trim: 60 },\n        model      : { type: 'string', trim: 60 },\n        managerInfo: { type: 'string', trim: 60 }\n      }),\n\n      queryConditions: {\n        type: 'and',\n        args: [\n\n          { type: 'startsWith', args: [ 'make', '#make#'] },\n\n          { type: 'startsWith', args: [ 'model', '#model#'] },\n\n          {\n            type: 'or',\n            ifDefined: 'managerInfo',\n            args: [\n              { type: 'startsWith', args: [ 'managers.name', '#managerInfo#' ] },\n              { type: 'startsWith', args: [ 'managers.surname','managerInfo#' ] },\n            ]\n          }\n        ]\n      },\n\n      storeName: 'managersCars',\n      publicURL: '/managers/:managerId/cars/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      nested: [\n        {\n          type: 'lookup',\n          localField: 'managerId',\n          store: 'managers',\n        }\n      ],\n    });\n    var managersCars = new ManagersCars();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n    managersCars.protocolListen( 'HTTP', { app: app } );;\n\nYou can see how for example in `Managers`, `onlineSearchSchema` has a mixture of fields that match the ones in the schema (`name`, `surname`) that look for a match in the corresponding fields, as well as search-specific fields (like `carInfo`) that end up looking into the nested children.\n\nIt's totally up to you how you want organise your searches. For example, you might decide to make a `searchAll` field instead for `Managers`:\n\n    onlineSearchSchema: new HotSchema({\n      searchAll : { type: 'string', trim: 60 },\n    }),\n\n    queryConditions: {\n      type: 'or',\n      ifDefined: 'searchAll',\n      args: [\n        { type: 'startsWith', args: [ 'name', '#searchAll#'] }\n        { type: 'startsWith', args: [ 'surname', '#searchAll#'] }\n        { type: 'startsWith', args: [ 'managersCars.make', '#searchAll#' ] },\n        { type: 'startsWith', args: [ 'managersCars.model','#searchAhh#' ] },\n      ]\n    },\n\nIn this case, the only allowed field in the query string will be `searchAll` which will look for a match anywhere.\n\n# Sorting options and default sort\n\nA client can require data sorting by setting the `sortBy` parameter in the query string. This means that there shouldn't be a `sortBy` element in the `onlineSearchSchema` attribute. JsonRestStores will parse the query string, and make sure that data is fetched in the right order.\n\nIn JsonRestStores you can also decide some default fields that will be used for sorting, in case no sorting option is defined in the query string.\n\n## The `sortBy` option\n\nThe `sortBy` attribute is in the format `+field1,+field2,-field3` which will instruct JsonRestStores to sort by `field1`, `field2` and `field3` (with `field3` being sorted in reverse).\n\nWhen you create a store, you can decide which fields are sortable:\n\nFor example:\n\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', searchable: true, trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 },\n      }),\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      sortableFields: [ 'name', 'surname' ],\n\n      nested: [\n        {\n          type: 'multiple',\n          store: 'managersCars',\n          join: { managerId: 'id' },\n        }\n      ],\n\n    });\n    var managers = new Managers();\n\n    var ManagersCars = declare( Store, {\n\n      schema: new Schema({\n        make     : { type: 'string', trim: 60, searchable: true, required: true },\n        model    : { type: 'string', trim: 60, searchable: true, required: true },\n      }),\n\n      storeName: 'managersCars',\n      publicURL: '/managers/:managerId/cars/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      sortableFields: [ 'make', 'model', 'managers.name' ],\n\n      nested: [\n        {\n          type: 'lookup',\n          localField: 'managerId',\n          store: 'managers',\n        }\n      ],\n    });\n    var managersCars = new ManagersCars();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n    managersCars.protocolListen( 'HTTP', { app: app } );;\n\nIn this case, I didn't define `onlineSearchSchema` nor `queryConditions`: the store will get the default ones provided by JsonRestStores.\n\nNote how `sortableFields` is an array of fields that will be taken into consideration. Each element of the array will be a field in the schema itself.\n\nIt is interesting how one of the sortable fields is `managers.name`: since `managers` is a nested table, its sub-fields can be used as sorting fields (as long as they are declared as searchable in their store's schema).\n\n## The `defaultSort` option\n\nIf the client doesn't provide any sorting options, you can decide a list of default fields that will be applied automatically. This is useful when you want to retrieve, for example, a list of comments and want to make sure that they are returned in chronological order without having to get the client to specify any sorting optinons.\n\nFor example:\n\n    var Comments = declare( Store, {\n\n      schema: new Schema({\n        subject: { type: 'string', searchable: true, trim: 60 },\n        body   : { type: 'string', searchable: true, trim: 4096 },\n        posted : { type: 'date',   searchable: true, protected: true, default: function(){ return new Date() } },\n      }),\n\n      storeName: 'comments',\n      publicURL: '/comments/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      defaultSort: {\n        posted: -1\n      },\n\n    });\n    var comments = new Comments();\n\n    JsonRestStores.init();\n    comments.protocolListen( 'HTTP', { app: app } );;\n\nThis will ensure that comments are always retrieved in reversed order, newest first. Since `sortableFields` is not defined, the default order (by `posted`) is the only possible one for this store.\n\n# The `position` attribute\n\nWhen creating a store, you can set the `position` parameter as `true`. For example:\n\n````Javascript\n    var Managers= declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', trim: 60 },\n      }),\n\n      position: true,\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n    var managers = new Managers();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n````\n\nThe `position` attribute means that `PUT` and `POST` calls will have to honour positioning based on `options.putBefore` and `options.putDefaultPosition`.\n\nThe main use of `position: true` is that when no sorting is requested by the client, the items will be ordered correctly depending on their \"natural\" positioning.\n\nPositioning will keep into account the store's `paramIds` when applying positioning. This means that if you have a store like this:\n\n````Javascript\n    var Managers= declare( Store, {\n\n      schema: new Schema({\n        workspaceId: { type: 'id' },\n        name       : { type: 'string', trim: 60 },\n        surname    : { type: 'string', trim: 60 },\n      }),\n\n      position: true,\n\n      storeName: 'managers',\n      publicURL: '/workspaces/:workspaceId/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n    var managers = new Managers();\n````\n\nPositioning will have to take into account `workspaceId` when repositioning: if an user in workspace `A` repositions an item, it mustn't affect positioning in workspace `B`. Basically, when doing positioning, `paramIds` define the _domain_ of repositioning (in this case, elements with matching `workspaceId`s will belong to the same domain).\n\n# `deleteAfterGetQuery`: automatic deletion of records after retrieval\n\nIf your store has the `deleteAfterGetQuery` set to `true`, it will automatically delete any elements fetched with a `getQuery` method (that is, a `GET` run without the final `id`, and therefore fetching elements based on a filter). This is done by forcing `options.delete` to `true` (unless it was otherwise defined) in `makeGetQuery()` .\n\nThis is especially useful when a store has, for example, a set of records that need to be retrieved by a user only once (like message queues).\n\n# `hardLimitOnQueries`: limit the number of records\n\nIf your store has the `hardLimitOnQueries` set, any `getQuery` method (that is, a `GET` without the final `id`, and therefore fetching elements based on a filter) will never return more than `hardLimitOnQueries` results (unless you are using JsonRestStore's API, and manually set `options.skipHardLimitOnQueries` to `true`).\n\n# Stores and collections when using SimpleDbLayerMixin\n\nWhen using SimpleDbLayerMixin (which is the most common case, unless you are [implementing data manipulation functions on your own](#naked-non-database-stores)), a SimpleDbLayer collection will be created using the following attributes passed to the store:\n\n  * `idProperty`: the same as `store.idProperty`\n  * `schema`: the same as `store.schema`\n  * `nested`: the same as `store.nested`\n  * `hardLimitOnQueries`: the same as `store.hardLimitOnQueries`\n  * `strictSchemaOnFetch`: the same as `store.strictSchemaOnFetch`\n\n  * `schemaError`: set as `store.UnprocessableEntityError`, which is the same as `e.UnprocessableEntityError` (from the `allhttperrors` module)\n  * `fetchChildrenByDefault`: set to true\n  * `positionField`: set to `__position` if `store.position` is set to `true`\n  * `positionBase`: set as a copy of `store.paramIds`, after cutting out the last item\n\nThe collection's name will match `storeName`, unless you pass a `store.collectionName` attribute.\n\nNote that _if a collection with a matching `collectionName` was already defined, then that collection is effectively reused by SimpleDbLayerMixin_. In this case, the following attribute in the JsonRestStore store will be forced to match the SimpleDbLayer's collection's attributes:\n\n  * `idProperty` (actually if the collection's idProperty doesn't match the store's, an error is thrown)\n  * `store.schema`\n  * `store.nested` (see next section)\n  * `store.hardLimitOnQueries`\n  * `store.strictSchemaOnFetch`\n\nThis allows you to potentially define SimpleDbLayer's layers beforehand, and then use them in JsonRestStores by defining a `collectionName` matching an existing table's name.\nIf you decide to do so, remember to set `fetchChildrenByDefault` to true, and `schemaError` to `e.UnprocessableEntityError` (where `e` comes from the module `allhttperrors`). You will also need to set your own `positionField` and `positionBase` manually if you want positioning to happen. Generally speaking, it's just easier and better to let JsonRestStores create your SimpleDbLayer collections.\n\n## A note on indexes\n\nUsing SimpleDbLayerMixin implies that you are using an indexed collection. SimpleDbLayer's layer have a method called `generateSchemaIndexes( options )` which will generate indexed for the collections based on the schema. These indexes are most likely all you will ever need. If not, please refer to the [Indexing section in SimpleDbLayer](https://github.com/mercmobily/simpledblayer#indexing) to know more about indexing, remembering that you can always access the SimpleDbLayer instance for a table through `store.dbLayer`.\n\nWhile developing, you should also remember to run:\n\n    store.dbLayer.generateSchemaIndexes( options, function( err ){\n    // ...\n    });\n\nAlternatively, you can just run one command that will cover all of your collections:\n\n    DbLayer.generateSchemaIndexesAllLayers( options, function( err ){\n    // ...\n    });\n\n# Automatic schema changes done by SimpleDbLayerMixin\n\nThe `searchable` attribute in the schema is really important: in SimpleDbLayer, for example, only `searchable` fields are actually searchable, and indexes are created automatically for them.\n\nWhen defining a schema in JsonRestStores with SimpleDbLayerMixin mixed in, the following happens automatically:\n\n* Any element in paramIds will be marked as `searchable` in the store's schema. This means that writing:\n\n````Javascript\n    var Managers= declare( Store, {\n\n      schema: new Schema({\n        workspaceId: { type: 'id' },\n        name       : { type: 'string', trim: 60 },\n        surname    : { type: 'string', trim: 60 },\n      }),\n\n      position: true,\n\n      storeName: 'managers',\n      publicURL: '/workspaces/:workspaceId/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n    var managers = new Managers();\n````\n\nIs the same as writing:\n\n````Javascript\n    var Managers= declare( Store, {\n\n      schema: new Schema({\n        id         : { type: 'id', searchable: true },\n        workspaceId: { type: 'id', searchable: true },\n        name       : { type: 'string', trim: 60 },\n        surname    : { type: 'string', trim: 60 },\n      }),\n\n      position: true,\n\n      storeName: 'managers',\n      publicURL: '/workspaces/:workspaceId/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n    var managers = new Managers();\n````\n\nNote that `searchable` is set both for `id` and for `workspaceId` (which are the store's `paramIds`, as they are defined in `publicURL`).\n\n* Any database field mentioned _anywhere_ in `queryConditions` will also be made searchable in the main schema. This means that writing:\n\n````Javascript\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', trim: 60 }, // Note: surname is NOT searchable\n      }),\n\n      onlineSearchSchema: new Schema( {\n        surnameSearch: { type: 'string', trim: 60 },\n      }),\n\n      queryConditions: {\n        type: 'startsWith',\n        args: [ 'surname', '#surnameSearch#']\n      },\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n\n    var managers = new Managers();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n````\n\nIs the same as writing:\n\n````Javascript\n    var Managers = declare( Store, {\n\n      schema: new Schema({\n        name   : { type: 'string', trim: 60 },\n        surname: { type: 'string', searchable: true, trim: 60 }, // Note: surname IS searchable\n      }),\n\n      onlineSearchSchema: new Schema( {\n        surnameSearch: { type: 'string', trim: 60 },\n      }),\n\n      queryConditions: {\n        type: 'startsWith',\n        args: [ 'surname', '#surnameSearch#']\n      },\n\n      storeName: 'managers',\n      publicURL: '/managers/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n    });\n\n    var managers = new Managers();\n\n    JsonRestStores.init();\n    managers.protocolListen( 'HTTP', { app: app } );;\n````\n\nThis is accomplished by SimpleDbLayerMixin by actually going through the whole `queryConditions` and checking that every database field mentioned in it is made searchable in the main schema.\n\n# Inheriting a store from another one (advanced)\n\nAt this point it's clear that stores are defined as constructor classes, which are then used -- only once -- to create a store variable. For example the constructor `Managers()` is used to create the `managers` store with `managers = new Managers()`.\n\nThis allows you to define a base store, and derive stores off that base store. For example:\n\n````Javascript\n\n    // The base WorkspacesUsersBase constructor\n    // Note that the collectionName is defined to something different to\n    // storeName\n\n    var WorkspacesUsersBase = declare( Store, {\n\n      schema: new HotSchema({\n        id         : { type: 'id', searchable: true },\n        userId     : { type: 'id', searchable: true },\n        workspaceId: { type: 'id', searchable: true },\n      }),\n\n      storeName: 'workspacesUsersBase',\n      collectionName: 'workspacesUsers',\n\n      idProperty: 'id',\n\n      // NOTE: no paramIds nor publicURL is defined.\n    });\n    stores.workspacesUsersBase = new WorkspacesUsersBase();\n\n    // The specialised WorkspacesUsers constructor, which\n    // define an onlineSearchSchema and publicURL\n\n    var WorkspacesUsers = declare( WorkspacesUsersBase, {\n\n      storeName:  'workspacesUsers',\n      collectionName: 'workspacesUsers',\n\n      publicURL: '/workspaces/:workspaceId/users/:id',\n\n      handleGetQuery: true,\n\n    });\n    stores.workspacesUsers = new WorkspacesUsers();\n\n    // The specialised UsersWorkspaces constructor, which\n    // define an onlineSearchSchema and publicURL\n\n    var UsersWorkspaces = declare( WorkspacesUsersBase, {\n\n      storeName:  'usersWorkspaces',\n      collectionName: 'workspacesUsers',\n\n      publicURL: '/users/:userId/workspaces/:id',\n\n      handleGetQuery: true,\n\n    });\n    stores.usersWorkspaces = new UsersWorkspaces();\n````\n\nIn this example, `WorkspacesUsersBase` is used as a starting point, defining `schema` and `idProperty`. Note that all `id` fields are defined in the schema manually (since there was no `paramIds` nor `publicURL` defined to do it automagically). `WorkspacesUsersBase` also defines `workspacesUsers` as `collectionName` (otherwise, `collectionName` would have been `workspacesUsersBase`). Two specialised stores are then inherited from `WorkspacesUsersBase`: `WorkspacesUsers` and `UsersWorkspaces`. They both enable `handleGetQuery` and are assigned different URLs, and therefore have different paramIds; however, they both use the same database collection called `workspacesUsers`.\n\nWhen you inherit a store using SimpleDbLayerMixin, you need to remember that **collections are always recycled if they were already defined by a previous store**.\n\nIn this particular case, when you run `stores.workspacesUsersBase = new WorkspacesUsersBase();` you are actually creating a SimpleDbLayer collection called `workspacesUsers`. Since derived constructors `WorkspacesUsers` and `UsersWorkspaces` define `workspacesUsers` as their collection, _the collection will be recycled since it already exists_.\nThis means that the following attributes of the store will be reused (and redefining them in the derived store will have no effect):\n\n* `idProperty` (from the store's `idProperty` attribute)\n* `schema` (from the store's `schema` attribute)\n* `hardLimitOnQueries` (from the store's `hardLimitOnQueries` attribute)\n* `strictSchemaOnFetch` (from the store's `strictSchemaOnFetch` attribute)\n* `indexBase` (from the store's `indexBase` attribute)\n\nAs a consequence, a derived store cannot redefine `idProperty`, `schema`, `hardLimitOnQueries`, `strictSchemaOnFetch`, `indexBase` (since they are used to create the dblayer instances when the base JsonRest store is created).\n\nThis also means that position grouping will depend on the _base_ constructor's `paramIds`, since the collection's `positionBase` will depend _only_ on the base class' `paramIds`. (Note: `positionBase` in a collection defines which fields are used to 'group' ordering, see [how repositioning works in SimpleDbLayer](https://github.com/mercmobily/simpledblayer#nested-record-positioning)). This will only affect you if you are creating derived stores with positioning.\n\n# Artificial delays\n\nWhen testing the application locally, everything is fast and zippy. However, stores don't tend to behave like that in real life. If your application implements things like drag&drop, form saving, etc, you often want to see how it behaves in \"real life\" -- in a situation where responses can take anything between 1 and 8 seconds.\n\nIn order for force JsonRestStores to add an artificial delay to _every_ online request (it won't apply to API), just assign a value to JsonRestStores.artificialDelay, like this:\n\n    var JsonRestStores = require('jsonreststores');\n    JsonRestStores.artificialDelay = 8000;\n\nThis will apply to _every_ online request, which will be delayed by 8 seconds.\n\n# Errors returned and error management\n\nJsonRestStores has very careful error management.\n\n## The error objects\n\nThis is the comprehensive list of errors the class can create:\n\n  * `BadRequestError` Like this: `new BadRequestError( { errors: errors } )`\n  * `UnauthorizedError`\n  * `ForbiddenError`\n  * `NotFoundError`\n  * `PreconditionFailedError`\n  * `UnprocessableEntityError` Like this: `UnprocessableEntityError( { errors: errors } )`\n  * `NotImplementedError`\n  * `ServiceUnavailableError`. Like this: `ServiceUnavailableError( { originalErr: error } )`\n\nThese error constructors are borrowed from the [Allhttperrors](https://npmjs.org/package/allhttperrors) module -- you should its short and concise documentation. The short version is that `errorObject.httpError` will be set, and the constructor can have either a string or an object as parameters.\n\nThe error objects are all pretty standard. However:\n\n* `ServiceUnavailableError` errors will be created with an `originalErr` parameter containing the original error object. For example if the database server goes down, the module will return a `ServiceUnavailableError` error object which will include the original MongoDB error in its `originalErr` parameter.\n\n* `UnprocessableEntityError` and `BadRequestError` are both created when field validation fails. They error objects will always have an `errors` attribute, which will represent an array of errors as they were returned by SimpleSchema. For example:\n\n\n````Javascript\n    [\n      { field: 'nameOfFieldsWithProblems', message: 'Message to the user for this field' },\n      { field: 'nameOfAnotherField', message: 'Message to the user for this other field' },\n    ]\n````\n\nJsonRestStores only ever throws (generic) Javascript errors if the class constructor was called incorrectly, or if an element in `paramIds` is not found within the schema. So, it will only ever happen if you use the module incorrectly. Any other case is chained through.\n\n## Error management\n\nAt some point in your program, one of your callbacks might have the dreaded `err` first parameter set to an error rather than null. This might happen  with your database driver (for example your MongoDB process dies), or within your own module (validation after a `PUT` fails).\n\nJsonRestStores allows you to decide what to do when this happens.\n\n### `chainErrors`\n\nYou can control what happens when an error occurs with the `chainErrors` attribute. There are three options:\n\n#### `all`\n\nIf you have `chainErrors: all` in your class definition: JsonRestStores will simply call `next( error )` where `error` is the error object. This means that it will be up to another Express middleware to deal with the problem.\n\n#### `none`\n\nIf you have `chainErrors: none` in your class definition: if there is a problem, JsonRestStores will _not_ call the `next()` callback at all: it will respond to the client directly, after formatting it with the object's `self.formatErrorResponse()` method (see below).\n\nDo this if you basically want to make absolute sure that every single request will end right there, whether it went well or not. If you do this, you might want to define your own `self.formatErrorResponse()` method for your store classes, so that the output is what you want it to be.\n\n#### `nonhttp`\n\nIf you have `chainErrors: nonhttp` in your class definition, JsonRestStores will only call `next( err ) ` for non-HTTP errors --  any other problem (like your MongoDB server going down) will be handled by the next Express error management middleware. Use this if you want the server to respond directly in case of an HTTP problem (again using `self.formatErrorResponse()` to send a response to the client), but then you want to manage other problems (for example a MongoDB problem) with Express.\n\n### `self.formatErrorResponse()`\n\nIn those cases where you decide to send a response to the client directly (with `chainErrors` being `none` or `nonhttp`), the server will send a response to the client directly. The body of the response will depend on what you want to send back.\n\nThe stock `self.formatErrorResponse()` method will simply return a Json representation of the error message and, if present, the `errors` array within the error.\n\n### `self.logError()`\n\nWhenever an error happens, JsonRestStore will run `self.logError()`. This happens regardless of what `self.chainErrors` contains (that is, whether the error is chained up to Express or it's managed internally). Note that there is no `callback` parameter to this method: since it's only a logging method, if it fails, it fails.\n\n# Data preparation hooks\n\nWith JsonRestStores, you are able to redefine specific methods to enrich the functionality of your stores. There are two classes of methods:\n\n* Methods to manipulate data fetched from external sources. They are:\n\n````Javascript\n    prepareBody: function( request, method, body, cb ){ cb( null, preparedBody ); }\n    extrapolateDoc: function( request, method, doc, cb ){ cb( null, extrapolatedDoc ); }\n    prepareBeforeSend: function( request, method, doc, cb ){ cb( null, preparedDoc ); }\n````\n\n* Methods to hook code at specific stages in the request's lifecycle. They are:\n\n````Javascript\n    afterValidate: function( request, method, p, cb ){ cb( null ); }\n    afterCheckPermissions: function( request, method, p, cb ){ cb( null ); }\n    afterDbOperation: function( request, method, p, cb ){ cb( null ); }\n    afterEverything: function( request, method, p, cb ) { cb( null ); }\n````\n## Data manipulation methods\n\nThese hooks share the same signature (the third parameter is always the data to be manipulated), and must call the callback passing an object containing computed data; to minimise side effects, it's best to base the new data on a new object; to facilitate the shallow copying process, JsonRestStores provides the `_co()` method (which stands for _C_opy _O_bject). For example, to implement `prepareBody()` you would write:\n\n    prepareBody: function( request, method, body, cb ){\n\n      // Make a copy of body into newBody\n      var newBody = this._co( body );\n\n      // Some elaboration.\n      newBody.headerName = newBody.headerName + \".\" + newBody.name;\n\n      // Forces `createdBy` to the value passed to the session\n      if( request.remote ) newBody.createdBy = request.session.userId;\n\n      cb( null, newBody );\n    },\n\nIn some cases, you will want to run the _original_ `prepareBody()` method, and then do more processing. In this case, you would write:\n\n    prepareBody: function f( request, method, body, cb ){\n\n      this.inheritedAsync( f, arguments, function( err, newBody ){\n\n        // Make a copy of body into newBody\n        var newBodyAgain = this._co( newBody );\n\n        // Some elaboration.\n        newBodyAgain.headerName = newBodyAgain.headerName + \".\" + newBodyAgain.name;\n\n        // Forces `createdBy` to the value passed to the session\n        if( request.remote ) newBodyAgain.createdBy = request.session.userId;\n\n        cb( null, newBodyAgain );\n\n      });\n\n    },\n\nHere, the original `preparebody()` is run through `this.inheritedAsync()`, and processing is done on its resulting `newBody`.\n\nFor more information about `inheritedAsync()`, have a look at [SimpleDeclare's documentation on calling asynchronous parent methods](https://github.com/mercmobily/simpleDeclare#calling-the-super-function-with-node-style-callback).\n\nThroughout the request's life cycle, `request.data` will be enriched by each data preparation hook. This will allow any hook to access the processed data\n\n###  `prepareBody( request, method, body, cb )`\n\n`prepareBody()` is called with the data passed from the client _as is_ (no casting, nor anything). Any manipolation done by `prepareBody()` will need to satisfy the schema, or validation will actually fail. This hook is useful if you want to force some fields to specific values, maybe depending on a session variable for the specific user. For example, when a record is created, you will have `creatorId` in the schema, but you won't want users to be able to specify any ID there. So, you can simply assign body.creatorId in the `prepareBody()` hook.\n\nThe parameters are:\n\n * `request`. The `request` object for this REST call.\n * `method`. It can be `post` or `put`.\n * `body`. The request's body.\n * `cb( err, body ) `. The callback, which will need to be passed a `body` object as its second parameter.\n\n### `extrapolateDoc( request, method, doc, cb )`\n\nYou can use this method to manipulate your data every time it's fetched from the data source. Fetching can happen for a number of reasons:\n\n* in `post`: after a new item is written, it's then fetched and then sent it to the client after `extrapolateDoc()`\n* in `putNew`: after a new item is written, it's then fetched and then sent it to the client after `extrapolateDoc()`\n* in `putExisting`: `extrapolateDoc()` is actually called twice: the first time after the item is fetched, and then again when it's re-fetched after writing it to the database\n* in `get`: when an item is fetched\n* in `getQuery`: when several items are fetched\n* in `delete`: when an item is about to be deleted, it's fetched first\n\nBasically, think of `extrapolateDoc` as a hook to manipulate whatever is in the database in order to add fields or dynamic information as needed.\n\nThe parameters are:\n\n * `request`. The `request` object for this REST call.\n * `method`. It can be `post`, `putNew`, `putExisting`, `get`, `getQuery`, `delete`\n * `doc`. The record after fetching\n * `cb( err, doc ) `. The callback, which will need to be passed a `doc` object as its second parameter.\n\nNote that if the method is being called on nested data, `request.nested` will be set to `true`.\n\n### `prepareBeforeSend( request, method, doc, cb )`\n\nYou can use this method to manipulate your data just before it's sent over to the client requesting it.\n\nThink of `extrapolateDoc` as a hook to make very-last-nanosecond changes to the result object before it's sent over to the client.\n\nThe difference from `extrapolateDoc()` is conceptual: `extrapolateDoc()` extracts the right information from the data source, whereas `prepareBeforeSend()` makes very-last-nanosecond changes to keep the client happy.\n\nThe parameters are:\n\n * `request`. The `request` object for this REST call.\n * `method`. It can be `post`, `putNew`, `putExisting`, `get`, `getQuery`, `delete`\n * `doc`. The entry after fetching\n * `cb( err, doc ) `. The callback, which will need to be passed a `doc` object as its second parameter.\n\nNote that if the method is being called on nested data, `request.nested` will be set to `true`.\n\n## Stage methods\n\nStage methods allow you to hook yourself to several stages of the request processing stages. You can manipulate the `request` object, or can simply make things happen.\n\nThey all share the same signature: (`request, method, cb`). Each method has access to the `request` object, which has the `request.data` filled in with the data as it's fetched from the database and manipulated.\n\nTo really use the stage hooks (and to extend JsonRestStores in general), it's important to know exactly [what happens in each request](#what-happens-exactly-in-each-request). Note how values are assigned to `request.data` as the request progresses. In general, the record fetched from the database will be `fullDoc`; once it's extrapolated, it's `doc`.\n\n### `afterValidate()`\n\nThis method is called once validation is completed.\n\n * `request`. The `request` object for this REST call.\n * `method`. It can be `post`, `put` or `getQuery`.\n * `cb( err ) `. The callback\n\n### `afterCheckPermissions()`\n\nThis method is called once permission checks have passed.\n\n * `request`. The `request` object for this REST call.\n * `method`. It can be `post`, `putNew`, `putExisting`, `get`, `getQuery`, `delete`.\n * `cb( err ) `. The callback.\n\n### `afterDbOperation()`\n\nThis method is called once data is read from, or written to, the data source for that request.\n\n * `request`. The `request` object for this REST call.\n * `method`. It can be `post`, `putNew`, `putExisting`, `get`, `getQuery`, `delete`.\n * `cb( err ) `. The callback.\n\n### `afterEverything()`\n\nThis method is the very last one called before sending the response out.\n\n * `request`. The `request` object for this REST call.\n * `method`. It can be `post`, `putNew`, `putExisting`, `get`, `getQuery`, `delete`.\n * `cb( err ) `. The callback.\n\n# Permissions\n\nBy default, everything is allowed: stores allow pretty much anything and anything; anybody can DELETE, PUT, POST, etc. Furtunately, JsonRestStores allows you to decide exactly what is allowed and what isn't, by overriding specific methods.\n\nEvery method runs the method `checkPermissions()` before continuing. If everything went fine, `checkPermissions()` will call the callback with `true`: `cb( null, true )`; otherwise, to fail, `cb( null, false )`.\n\nThe `checkPermissions()` method has the following signature:\n\n    checkPermissions: function( request, method, cb )\n\nHere:\n\n* `request`. It is the request object\n* `method`. It can be `post`, `putNew`, `putExisting`, `get`, `getQuery`, `delete`\n\nHere is an example of a store only allowing deletion only to specific admin users:\n\n````Javascript\n    // The basic schema for the WorkspaceUsers table\n    var WorkspaceUsers = declare( Store, {\n\n      schema: new Schema({\n        email     :  { type: 'string', trim: 128, searchable: true, sortable: true  },\n        name      :  { type: 'string', trim: 60, searchable: true, sortable: true  },\n      }),\n\n      storeName:  'WorkspaceUsers',\n      publicURL: '/workspaces/:workspaceId/users/:id',\n\n      handlePut: true,\n      handlePost: true,\n      handleGet: true,\n      handleGetQuery: true,\n      handleDelete: true,\n\n      checkPermissions: function( request, method, cb ){\n\n        // This will only affect `delete` methods\n        if( method !== 'delete' ) return cb( null, true );\n\n        // User is logged in: all good\n        if( request._req.session.user ){\n          cb( null, true );\n\n        // User is not logged in: fail!\n        } else {\n          cb( null, false );\n        }\n      },\n\n    });\n    var workspaceUsers = new WorkspaceUsers();\n    workspaceUsers.protocolListen( 'HTTP', { app: app } );;\n````\n\nPermission checking can be as simple, or as complex, as you need it to be.\n\nNote that if your store is derived from another one, and you want to preserve your master store's permission model, you can run `this.inheritedAsync(arguments)` like so:\n\n      checkPermissions: function f( request, method, cb ){\n\n        this.inheritedAsync( f, arguments, function( err, granted ) {\n          if( err ) return cb( err, false );\n\n          // The parent's checkPermissions() method failed: this will honour that fail\n          if( ! granted) return cb( null, false );\n\n          // This will only affect `delete` methods\n          if( method !== 'delete' ) return cb( null, true );\n\n          // User is admin (id: 1 )\n          if( request._req.session.user === 1){\n            cb( null, true );\n\n          // User is not logged in: fail!\n          } else {\n            cb( null, false );\n          }\n       }\n     },\n\nThis will ensure that the inherited `checkPermissionsDelete()` method is called and followed, and _then_ further checks are carried on.\n\nPlease note that `checkPermissions()` is only run for local requests, with `remote` set to false. All requests coming from APIs will ignore the method.\n\n# Store APIs\n\nJsonRestStores allows you to run store methods from within your programs, rather than accessing them via URL. This is especially useful if you have a store and want to simulate an HTTP request within your own programs. Note that for database-backed methods you should use SimpleDbLaye methods (you can access the SimpleDbLayer table object in your store via `store.dbLayer`).\n\nThe API is really simple:\n\n* `Store.Get( id, options, next( err, doc ) {})`\n* `Store.GetQuery( options, next( err, queryDocs ){} )`\n* `Store.Put(  body, options, next( err, doc ){} )`\n* `Store.Post( body, options, next( err, doc ){} )`\n* `Store.Delete( id, options, next( err, doc ){} )`\n\nThe `next()` call is the callback called at the end.\n\nWhen using the API, the `options` object is especially important, as it defines how the API will work. When a request comes from a remote operation, the `options` object is populated depending on the requested URL and HTTP headers. When using the API, you need to popuate `options` manually in order to obtain what you desire. `options` is especially important while querying, as that's where you define what you filter and order the results by. (If you are curious, when a remote connection is established the function `_initOptionsFromReq()` is the one responsible of getting headers and URL, and populating `options` before running the appropriate function).\n\nSince there is no HTTP connection to extrapolate options from, the `options` parameter in every API call is assigned directly to `request.options`. For all of the available options, refer to the [The options object](the-options-object) section in this guide.\n\nAll normal hooks are called when using these functions. However:\n\n* Any check on `paramIds` is turned off: you are free to query a store without any pre-set automatic filtering imposed by `paramIds`. If your store has a `publicURL` of `/workspaces/:workspaceId/users/:id`, and you request `GET /workspaces/10/user/11`, in remote requests the `user` data source will be looked up based on _both_ `workspaceId` and `id`. In API (non-remote) requests, the lookup will only happen on `id`.\n* `request.params` is automatically set to a hash object where the `idProperty` attribute matches the passed object's ID property. For example, for `{ id: 10, colour: 'red' }`, the `request.params` object is automatically set to  { `id: 10 }`. (This is true for all methods except `getQuery` and `post`, which don't accept objects with IDs). Note that you can pass `options.apiParams` to force `request.params` to whatever you like.\n* All `store.handleXXX` properties are ignored: all methods will work\n* The `request.remote` variable is set to false\n* Permissions checking methods are not called at all: permission is always granted\n* When the request is done, rather than using `self.sendData()`, the `next()` callback is called with the results.\n\n# Naked, non-database stores\n\nJsonRestStores is powerful thanks to `SimpleDbLayerMixin`, which allows you to create database-backed stores in seconds. However, there are times when you want to write a store from scratch without mixing in `SimpleDbLayerMixin`. You might want to create a store that returns virtual values (like the number of online users), or a store that returns a dataset that is fetched from a different backed (a text file, for example) etc.\n\nTo do that, you will need to write a store that implements the `implement***` methods, which are:\n\n * `implementFetchOne( request, cb )`. Required for methods `put`, `get`, `delete`.\n * `implementInsert( request, forceId, cb )`. Required for methods `post` and `put` (`putNew`).\n * `implementUpdate( request, deleteUnsetFields, cb )`. Required for method `put` (`putExisting`).\n * `implementDelete( request, cb )`. Required for method `delete`.\n * `implementQuery( request, next )`. Required for methods `getQuery`.\n * `implementReposition( doc, where, beforeId, cb )`. Required for methods `post` and `put`.\n\nLooking it from a different perspective, here are the `implement***` methods you will need to implement for each method to work properly:\n\n * `get`: `implementFetchOne()`.\n * `getQuery`: `implementQuery()`\n * `put`: `implementFetchOne()`, `implementInsert()`, `implementUpdate()`, `implementReposition()`\n * `post`: `implementInsert()`, `implementReposition()`\n * `delete`: `implementDelete()`\n\nWhen developing these methods, it's important to make sure that they function exactly as expected.\n\n## `implementFetchOne( request, cb )`\n\nThis method is used to fetch a single record from the data source. The attributes taken into consideration in `request` are:\n\n* `request.remote`.\n* `request.params`. Sets the filter to search for the record to be fetched. For local request, it's acceptable to just match the key in `request.params` matching `self.idProperty`. For remote requests, it's best to filter data so that every key in `request.params` matches the equivalent key in the record.\n\nThe callback `cb()` must be called with the fetched element as its second parameter, or `null` if a match wasn't found.\n\n## `implementInsert( request, forceId, cb )`\n\nThis method is used to add a single record to the data source. No attribute is taken into consideration in `request`.\n\nIf `forceId` is set, then a shallow copy of the record should be made (with `this._co()`) and the object's `idProperty` key should be forced to be `forceId`.\n\nThe callback `cb()` must be called with the record once written on the data source.\n\n## `implementUpdate( request, deleteUnsetFields, cb )`.\n\nThis method is used to update a single record in the data source. The attributes taken into consideration in `request` are:\n\n* `request.remote`.\n* `request.params`. Sets the filter to search for the record to be updated. For local request, it's acceptable to just match the key in `request.params` matching `self.idProperty`. For remote requests, it's best to filter data so that every key in `request.params` matches the equivalent key in the record.\n* `request.body`. The fields to be updated in the data source.\n\nIf `deleteUnsetFields` is set to `true`, then all fields that are not set in `request.body` must be deleted from the matched record in the data source.\n\nThe callback `cb()` must be called with the updated element as its second parameter, or `null` if a match wasn't found.\n\n## `implementDelete( request, cb )`\n\nThis method is used to delete a single record from the data source. The attributes taken into consideration in `request` are:\n\n* `request.remote`.\n* `request.params`. Sets the filter to search for the record to be deleted. For local request, it's acceptable to just match the key in `request.params` matching `self.idProperty`. For remote requests, it's best to filter data so that every key in `request.params` matches the equivalent key in the record.\n\nThe callback `cb()` must be called with the fetched element as its second parameter, or `null` if a match wasn't found.\n\n## `implementQuery( request, next )`\n\nThis method is used to fetch a set of records from the data source. The attributes taken into consideration in `request` are:\n\n* `request.remote`.\n* `request.params`. For remote requests, adds filtering restrictions to the query so that only matching records will be fetched. For local request, such extra filtering should be avoided.\n* `request.options`. The options object that will define what data is to be fetched. Specifically:\n  * `request.options.conditions`: an object specifying key/value criteria to be applied for filtering\n  * `request.options.sort`: an object specifying how sorting should happen. For example `{ surname: -1, age: 1  }`.\n  * `request.options.range`: an object with up to attributes: `limit` must make sure that only a limited number of records are fetched; `skip` must make sure that a number of records are skipped.\n  * `request.options.delete`: if set to `true`, each fetched record will be deleted after fetching. The default is the store's own `self.deleteAfterGetQuery` attribute (which is itself `false` by default).\n  * `request.options.skipHardLimitOnQueries`: if set to `true`, the limitation set by the store's own attribute `hardLimitOnQueries` will not be applied.\n\nNote that two store attributes must be taken into consideration:\n\n* `self.hardLimitOnQueries`. This is the maximum number of results that must be returned. Note that `implementQuery()` might have `request.options.skipHardLimitOnQueries` set to `true`: in this case, the limit mustn't be applied.\n* `self.deleteAfterGetQuery`. Acts as a default for the `request.options.delete` attribute: if `request.options.delete` is not set, whatever `self.deleteAfterGetQuery` is set to must be used as a default.\n\nThe callback `cb()` must be called with the fetched elements as its second parameter, or an empty array if nothing was found.\n\nWhile filtering by `request.params` is straightforward, as it must just make sure that every attribute set in `request.params` matches the corresponding attribute in the object, `request.options.conditions` is a little more complex; `conditions` is a hash of key/value following the `onlineSearchSchema`, and their meaning is set by the `queryConditions` attribute in the store (see the [queryConditions section](#custom-queryconditions) in this guide).\n\nSo, in a naked, non-database store you should still make sure that `queryConditions` is set properly, and that queries will honour what's specified in it. If your `queryConditions` is:\n\n    queryConditions: {\n      type: 'startsWith',\n      args: [ 'surname', '#surname#']\n    },\n\nIf `request.options.conditions` has as `surname` key, you should filter your data so that only records where the `surname` attribute starts with `request.options.conditions.surname` are returned.\n\nThis is what SimpleDbLayerMixin does automatically (it recursively visits `queryConditions` and creates the appropriate query for the right database). However, in a naked non-database store, writing a function that parses `queryConditions` is definitely an overkill.\n\nThis does have the implication that inheriting from a naked store is possible, but if you change `queryConditions` you will also have to re-write `implementQuery` so that filtering matches what `queryConditions` says.\n\nWhile there is no practical reason, server side, to make sure that `queryConditions` matches the way queries are carried out by the store, it's also true that other components, are aware of how the store works in terms of searching; a client-store fetching data, for example, might want to be able to emulate the store's behaviour in terms of searching to keep refreshing of data at minimum.\n\n## `implementReposition( doc, where, beforeId, cb )`\n\nThis method is used to reposition a field in the data source. It's the only call to the API with a slightly different signature. This function should only do anything if `store.position` is set to `true`.\n\nIts parameters are:\n\n* `doc`. The record that needs to be moved. Most implementation will only ever taken into account `doc[ self.idProperty ]`.\n* `where`. Where to place the element. It can be:\n * `start`. Place the element first.\n * `end`. Place the element last.\n * `before`. Place the element before the one with ID `beforeId`.\n* `beforeId`. Only used when `where` is `before`: it's the ID of the element.\n\nThe callback only have the `err` parameter.\n\n# What happens exactly in each request\n\nIt's important to understand what happens in each request, so that you know exactly what you know when your hooks are called in the request's life cycle.\n\nJsonRestStores does all of the boring stuff for you -- the kind things that you would write over and over and over again while developing a server store. However, it's important to know \"how\" the boring stuff is done.\n\n(When you read these, think about all of the boring work JsonRestStores is doing for you for every store you define!)\n\n### `_makeGetQuery()` (for GET requests, no ID)\n\n* (CHECK) check that `self.handleGetQuery` is true for remote requests. If false, send `NotImplementedError`\n* (CHECK) incoming `request.params` (`:ids` from URL) match types of `store.paramIds` array (type is taking from schema). If fail, send `BadRequestError`\n* (HOOK) `self.checkPermissions( request, 'getQuery' )` is run. If fail, send `ForbiddenError`\n* (CHECK) Search terms (request.options.conditions) are cast against the onlineSearchSchema. If fail, send `BadRequestError`\n* (HOOK) `self.afterValidate( request, 'getQuery' )` is run\n* (INTERFACE) `implementQuery( request )` is run. => `request.data.fullDocs`, `request.data.total`, `request.data.grandTotal`\n* (HOOK) `self.afterDbOperation( request, 'get' )` is run\n* (DATA) `self.extrapolateDoc( fulldocs )` and `self.prepareBeforeSend( request, doc )` are run for each element in `fullDocs` => `request.data.docs`, `request.data.preparedDocs`\n* (HOOK) `self.afterEverything( request )` is run\n* (DATA) `preparedDocs` is sent as array (status: 200)/returned as array (for API). Party!\n\n### `_makeGet()` (for `GET` requests, with ID)\n\n* (CHECK) check that `self.handleGet` is true for remote requests. If false, send `NotImplementedError`\n* (CHECK) incoming `request.params` (`:ids` from URL) match types of `store.paramIds` array (type is taking from schema). If fail, send `BadRequestError`\n* (INTERFACE) `implementFetchOne( request )` is run. If record isn't therem send `NotFoundError` => `request.data.fullDoc`\n* (HOOK) `self.afterDbOperation( request, 'get' )` is run\n* (DATA) `self.extrapolateDoc( request, 'get', fullDoc )` is run against the record just fetched => `request.data.doc`\n* (HOOK) `self.checkPermissions( request, 'get' )` is run. If fail, send `ForbiddenError`\n* (HOOK) `self.afterCheckPermissions( request, 'get' )` is run\n* (DATA) `self.prepareBeforeSend( request, 'get', doc )` is run => `request.data.preparedDoc`\n* (HOOK) `self.afterEverything( request, 'get' )` is run\n* (DATA) `doc` is sent (status: 200)/returned (for API). Party!\n\n### `_makeDelete()` (for DELETE requests)\n* (ATTR) check that `self.handleDelete` is true for remote requests. If false, send `NotImplementedError`\n* (CHECK) incoming `request.params` (`:ids` from URL) match types of `store.paramIds` array (type is taking from schema). If fail, send `BadRequestError`\n* (INTERFACE) `implementFetchOne( request )` is run. If record isn't therem send `NotFoundError` => `request.data.fullDoc`\n* (DATA) `self.extrapolateDoc( request, 'delete', fullDoc )` is run against the record just fetched => `request.data.doc`\n* (HOOK) `self.checkPermissions( request, 'delete' )` is run. If fail, send `ForbiddenError`\n* (INTERFACE) `implementDelete( request )` is run. If record isn't therem send `Error`\n* (HOOK) `self.afterDbOperation( request, 'delete' )` is run\n* (DATA) `self.prepareBeforeSend( request, 'delete', doc )` is run => `request.data.preparedDoc`\n* (HOOK) `self.afterEverything( request, 'delete' )` is run\n* (DATA) `preparedDoc` is sent (status: 200, if remote)/returned (for API). Party!\n\n\n### `_makePost()` (for POST requests)\n* (ATTR) check that `self.handlePost` is true for remote requests. If false, send `NotImplementedError`\n* (CHECK) incoming `request.params` (`:ids` from URL) match types of `store.paramIds` array (type is taking from schema). If fail, send `BadRequestError`\n* (HOOK) `self.prepareBody( request, 'post', request.body)` is run => preparedBody\n* (DATA) `request.body` is assigned to `prepareBody`; the original `body` is still available as `request.bodyBeforePrepare\n* (DATA) For remote requests, `body` is enriched with the elements in `request.params`. Existing attributes will be overwritten.\n* (CHECK) Body (`request.body`) is cast against the store's schema (skipping `idProperty`, since it's a post and `idProperty` isn't set). If fail, send `BadRequestError` => validatedBody\n* (CHECK) If fields with `protected` set to `true` in the schema are present in the body, return `UnprocessableEntityError`\n* (DATA) `request.body` is assigned to `validatedBody`; the original `body` is still available as `request.bodyBeforeValidation\n* (HOOK) `self.afterValidate( request, 'post' )` is run\n* (HOOK) `self.checkPermissions( request, 'post' )` is run. If fail, send `ForbiddenError`\n* (HOOK) `self.afterCheckPermissions( request, 'post' )` is run\n* (DATA) All fields with `doNotSave` set to `true` in the schema are purged from `request.body`\n* (INTERFACE) `implementInsert( request, forceId )` is run. If record isn't therem send `Error` => `request.data.fullDoc`\n* (INTERFACE) `implementReposition( request, ... )` is run. Parameters will depend on `request.options.putBefore` and `request.options.putDefaultPosition`.\n* (HOOK) `self.afterDbOperation( request, 'post' )` is run\n* (DATA) `self.extrapolateDoc( request, 'post', fullDoc )` is run against the record just added => `request.data.doc`\n* (DATA) `self.prepareBeforeSend( request, 'post', doc )` is run => `request.data.preparedDoc`\n* (HOOK) `self.afterEverything( request, 'post' )` is run\n* (DATA) `preparedDoc` is sent (status: 201, if remote and `echoAfterPost`)/returned (for API). Party!\n\n### `_makePut()` (for PUT requests)\n\n* (ATTR) check that `self.handlePut` is true for remote requests. If false, send `NotImplementedError`\n* (CHECK) incoming `request.params` (`:ids` from URL) match types of `store.paramIds` array (type is taking from schema). If fail, send `BadRequestError`\n* (HOOK) `self.prepareBody( request, 'put', request.body )` is run => preparedBody\n* (DATA) `request.body` is assigned to `prepareBody`; the original `body` is still available as `request.bodyBeforePrepare\n* (DATA) For remote requests, `body` is enriched with the elements in `request.params`. Existing attributes will be overwritten.\n* (CHECK) Body (`request.body`) is cast against the store's schema. If fail, send `BadRequestError` => validatedBody\n* (CHECK) If fields with `protected` set to `true` in the schema are present in the body, return `UnprocessableEntityError`\n* (DATA) `request.body` is assigned to `validatedBody`; the original `body` is still available as `request.bodyBeforeValidation\n* (HOOK) `self.afterValidate( request, 'put' )` is run\n* (INTERFACE) `implementFetchOne( request )` is run => `request.data.fullDoc`\n* (CHECK) Check if `request.options.overwrite` is set. If it is, then apply restraints: 1) if `overwrite` is `true`, then `fullDoc` _must_ be set (existing record) 2) if `overwrite` is `false`, then `fullDoc` _must_ be null (new record)\n\n#### ...and then, for NEW records (`implementFetchOne` returned `fullDoc` as `null`)\n\n* (HOOK) `self.checkPermissions( request, 'putNew' )` is run. If fail, send `ForbiddenError`\n* (HOOK) `self.afterCheckPermissions( request, 'post' )` is run\n* (DATA) All fields with `doNotSave` set to `true` in the schema are purged from `request.body`\n* (INTERFACE) `implementInsert( request, null )` is run. If record isn't therem send `Error` => `request.data.fullDoc`\n* (INTERFACE) `implementReposition( request, ... )` is run. Parameters will depend on `request.options.putBefore` and `request.options.putDefaultPosition`.\n* (HOOK) `self.afterDbOperation( request, 'putNew' )` is run\n* (DATA) `self.extrapolateDoc( request, 'putNew', fullDoc )` is run against the record just added => `request.data.doc`\n* (DATA) `self.prepareBeforeSend( request, 'putNew', doc )` is run => `request.data.preparedDoc`\n* (HOOK) `self.afterEverything( request, 'putNew' )` is run\n* (DATA) `preparedDoc` is sent (status: 201, if remote and `echoAfterPutNew`)/returned (for API). Party!\n\n#### ...or  then, for EXISTING records (`implementFetchOne` returned `fullDoc` not `null`):\n\n* => `request.data.fullDoc`\n* (DATA) `self.extrapolateDoc( request, 'putExisting', fullDoc )` is run against the record just fetched => `request.data.doc`\n* (HOOK) `self.checkPermissions( request, 'putExisting' )` is run. If fail, send `ForbiddenError`\n* (HOOK) `self.afterCheckPermissions( request, 'post' ) is run\n* (DATA) All fields with `doNotSave` set to `true` in the schema are purged from `request.body`\n* (INTERFACE) `implementUpdate( request, true )` is run. If record isn't therem send `Error` => `request.data.fullDocAfter`\n* (INTERFACE) `implementReposition( request, ... )` is run. Parameters will depend on `request.options.putBefore` and `request.options.putDefaultPosition`.\n* (HOOK) `self.afterDbOperation( request, 'putExisting' )` is run\n* (DATA) `self.extrapolateDoc( request, 'putExisting', fullDocAfter )` is run against the record just added => `request.data.docAfter`\n* (DATA) `self.prepareBeforeSend( request, 'putExisting', docAfter )` is run => `request.data.preparedDoc`\n* (HOOK) `self.afterEverything( request, 'putExisting' )` is run\n* (DATA) `preparedDoc` is sent (status: 200, if remote and `echoAfterPutExisting`)/returned (for API). Party!\n\n# Implementing protocol mixins\n\nJsonRestStores is protocol-agnostic: both listening for requests, and sending data out, is 100% abstracted. Even the reference HTTP mixin, `HTTPMixin`, is replecable if you want to change the way JsonRestStores provides headers, or if you'd like to manipulate data before sending it out.\n\nIn order to work, a protocol mixin needs to implement the following methods:\n\n## protocolListenNAME( params )\n\nHere, `NAME` is the name of the protocol. For example, when you write `protocolListen( 'HTTP', { app: app } );`, you are actually running `protocolListenHTTP( { app: app } )`.\n\nIn `params`, you need to pass the parameters specific for that protocol. For example, in case of `HTTP`, the function is expecting an `app` parameter (so that it can add the Express routes exported by the store).\n\nFor each REST request, this method is expected to create a `request` object (with `new Object()`) and set the following attributes:\n\n* `remote`: set to `true`;\n* `protocol`: set to the protocol's name (e.g. `HTTP`)\n* `params`: set to the URL parameters. For example, a request like this: `PUT /managers/10/cars/20` will have `params` set as `{ managerId: 10, id: 20 }`\n* `body`: set to the request's `body`\n* `session`: a variable that is going to keep between requests made by the same client. The mechanism will depend on the protocol used.\n* `options`: the options, based on the request itself. With HTTP, they are worked out from query string and headers. Note that if `request.options.delete` is not set, and the store's `this.deleteAfterGetQuery` is `true`, then request.options.delete should be honoured and set to `true`.\n\nAt that point, the function will need to call the right request handler (`makeGet()`, `makeGetQuery()`, etc.) depending on the request received, honouring the store's `this.artificialDelay` attribute.\n\nSpecific protocols can set extra attributes. For example HTTP sets `_req` and _res` as the Express' `req` and `res` objects. Doing so is important, because `request._res.json()` and `request._res.send()` will be used by the the protocol's sending function to send data to the client.\n\n## protocolSendNAME ( request, method, data, cb )\n\nOnce the request handler has finished processing the request, calls the store's method  `self.sendData(  request, method, returnObject );` to get it delivered to the client.\n\n`sendData()`, in turn, will call `protocolSendNAME()` where `NAME` is `request.protocol`. So, for `HTTP` requests, `protocolSendHTTP( request, method, returnObject )` will be called. This method has access to the `request` attribute, which (as mentioned earlier) was assigned `_req` and `_res`. `req._res` is used by `protocolSendHTTP()` to set the right HTTP headers and deliver the response to the client.\n\nThere is a special case in terms of the `method` argument: it can be the method used, or it could be `'error'` (a string literal with the word `error` in it): in this case, it means that something went wrong while processing the request, and that JsonRestStores is actually running `self.sendData( request, 'error', error );`, where the last `error` parameter is the error object itself. So, in this case `data` will actually be an error object with the following extras:\n\n* `responseBody`: what JsonRestStores wants to return in terms of data. This is the result of the store's `self.formatErrorResponse()`,  which you can redefine\n* `originalMethod`: the original method that originated the error\n\nFor example, HTTPMixin does this to handle the error:\n\n    // Sets status and responseBody\n    var status = 200;\n    var responseBody = data;\n    switch( method ){\n      case 'post': case 'putNew': status = 201; break;\n      case 'delete': if( data == '' ) status = 204; break;\n      case 'error': status = data.httpError; responseBody = data.responseBody; break;\n    };\n\n### Internal hooks\n\nSending data is the end of the road in terms of requests. So, you don't actually get the benefit of being able to have a callback with `err` set if things go wrong.\n\nThis is why `sendData()` is implemented like this:\n\n    sendData: function( request, method, data ){\n\n      var n = 'protocolSend' + request.protocol;\n      var f = this[ n ];\n\n      var self = this;\n\n      // The method must be implemented\n      if( !f ) throw (\"Error: function self.\" + n + \" not implemented!\");\n\n      // Call the `internalBeforeSendData()` hook\n      self._internalBeforeSendData( request, method, data, function( err ){\n        if( err ) return self.errorInSending( request, method, data, 'before', err );\n\n        // Call the function that _actually_ sends data\n        f.call( self, request, method, data, function( err ){\n          if( err ) return self.errorInSending( request, method, data, 'during', err );\n\n          // Call the `internalAfterSendData()` hook\n          self._internalAfterSendData( request, method, data, function( err ){\n            if( err ) return self.errorInSending( request, method, data, 'after', err );\n\n            // No-op. This is the end of the call chain.\n          });\n        });\n      })\n    },\n\nSo, two \"internal\" hooks are called: `_internalBeforeSendData()` and `internalAfterSendData()`. They have the `internal` prefix because these hooks should only really be redefined by protocol handlers (like HTTPMixin).\nProtocol mixins can decide to redefine these methods, making sure that `this.inheritedAsync()` is called while doing so.\n\nIf those methods return with an error, the store's method `errorInSending()` is called:\n\n    errorInSending: function( request, method, data, when, error ){\n      self.logError( error );\n    },\n\nBy default, this method simply logs the problem. However, in a real application you may want to consider a more careful approach.\n\n# Conclusion\n\nI started writing this module to make it easy to write stores. While it _is_ really easy to create stores with JsonRestStores, and the module itself is quite simple in the way it works, there _is_ a lot to learn, especially if you want to use its more advanced features.\n",
  "readmeFilename": "README.md",
  "gitHead": "3ccf53bcd163ef7ea848b80ed5b06e0c6bd5f669",
  "bugs": {
    "url": "https://github.com/mercmobily/JsonRestStores/issues"
  },
  "homepage": "https://github.com/mercmobily/JsonRestStores#readme",
  "_id": "jsonreststores@0.3.47",
  "_shasum": "e0159ada7ff87a1f08d7ac4d6ef8d1d8dd908eb1",
  "_from": "jsonreststores@>=0.3.0 <0.4.0"
}
