{
  "name": "simpleschema",
  "description": "The simplest, most extendible schema class you will ever come across",
  "keywords": [
    "javascript",
    "database",
    "db",
    "schema",
    "validation"
  ],
  "main": "SimpleSchema.js",
  "version": "0.3.14",
  "private": false,
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mercmobily/SimpleSchema.git"
  },
  "author": {
    "name": "Tony Mobily"
  },
  "dependencies": {
    "simpledeclare": "0.3.x"
  },
  "readme": "SimpleSchema\n=============\n\nSimpleSchema is a _simple_ library to validate objects and cast their attributes according to their (schema) types.\n\nIt uses [SimpleDeclare - Github](https://github.com/mercmobily/simpleDeclare) in order to define a constructor function (see: 'class'). I strongly recommend using SimpleDeclare to create derivative schemas (which are very easy to create).\n\nSimpleSchema is a required module when you try and use [JsonRestStores - Github](https://github.com/mercmobily/JsonRestStores). SimpleSchema was in fact part of JsonRestStores, and then \"taken out\" as it's useful in its own right.\n\nMain features:\n\n* It's easy to use and extend\n* It's tailored for `req.body`, built for casting simple (not nested) data strucures\n* Allows sync an async validation\n* It provides DB-specific layers to handle database IDs\n* It's actively used in a complex project, [JsonRestStores](https://github.com/mercmobily/JsonRestStores)\n* It down-to-earth code: no trickery and complex object structures\n* Fully unit-tested\n\n# Brief introduction\n\nHere is how to use SimpleSchema:\n\n    var Schema = require( 'simpleschema' );\n\n    personSchema = new Schema( {\n      name: { type: 'string', trim: 20 },\n      age:  { type: 'number', default: 30, max: 140 },\n      rank: { type: 'number', default: 99, max: 99, doNotSave: true },\n    });\n\nIn a normal node/Express application, you would simply use the `validate()` method of personSchema against `req.body`:\n\n    // Definition of a standard callback\n\n    formSubmit( req, res, next ){\n\n      // Apply async, record-wise validation to req.body\n      personSchema.validate( req.body, {}, function( err, newBody, errors ){\n\n        if( err ){\n          next( err );\n        } else {\n\n          if( errors.length) {\n             // Do what you normally do when there is an error,\n             // ...\n          } else {\n            // ...\n\n            // The newBody.rank and newBody.age attributes are now proper Javascript numbers\n\n            // Imagine that the field `rank` is not to be part of the DB.\n            // `personSchema.cleanup()` will delete from `newBody` all fields with `doNotSave` defined in the schema\n            personSchema.cleanup( newBody, 'doNotSave' );\n\n            // Write `newBody` to the database\n            // ...\n          }\n        }\n      })\n\nThis ensures that all values are cast appropriately (everything in `req.body` comes as a string, whereas you will want `age` and `rank` as proper Javascript numbers).\n\nNote that in this field:\n\n      rank: { type: 'number', default: 99, max: 99, doNotSave: true },\n\n* `type` is the field type. It means that when running personSchema.validate(), `rank` will be cast as a number\n* `default`, `max`, `doNotSave` are the \"field parameters\".\n\n## The schema description: all features\n\nHere is a schema which covers _every_ single feature in terms of types and parameters (parameters will not be repeated):\n\n    // If there is an error, the validator function will need to return a string describing it.\n    // otherwise, return nothing.\n    var fieldValidatorFunc =  function( obj, value, fieldName ){\n      if( value == 130 ) return 'Age cannot be 130';\n      return;\n    };\n\n    complexSchema = new Schema({\n      name:    { type: 'string', default: 'SOMETHING', uppercase: true, trim: 4, required: true, notEmpty: true },\n      surname: { type: 'string', lowercase: true },\n      age:     { type: 'number', default: 15, min: 0, max: 130, validator: fieldValidatorFunc, extraParameter: true },\n      id:      { type: 'id' },\n      date:    { type: 'date' },\n      list:    { type: 'array' },\n      various: { type: 'serialize', required: false },\n      location:{ type: 'geo', geoType: 'Point'}\n    }\n    },\n    {\n      // Validation function called by schema.validate() for async validation\n      validator: function( object, originalObject, castObject, options, done ){\n        var errors = [];\n\n        if( object.surname == 'Smith' ){\n           errors.push( { field: 'name', message: 'Smith is not an acceptable name' } );\n        }\n        done( null, errors );\n      }\n    });\n\nNote:\n\n * Casting to the field's type (depending on `type`) always happens first; parameters are applied afterwards\n * If casting fails, the parameters for that field will not be applied (and `errors` will have the casting error on that field)\n * The order of parameters matters. Parameters are processed in the order they are encountered. If you have `{ default: 'something', uppercase: true }`, the result will be `Something`.\n * the `serialize` type will convert an object into a string. You need to use the option `{ deserialize: true }` if you want to do the opposite.\n * `min`, `max` on `string`s will check the string length; on `number`s will check number value\n * `uppercase`, `lowercase`, `trim` will only apply to `string`s\n * `required` will fail if the  object's corresponding attribute (before casting) was `undefined` and will never fail for arrays;\n * `notEmpty` will fail if the  object's corresponding attribute was `v == ''` (note the weak `==`) and will never fail for arrays\n * If `fieldValidatorFunc` returns a string, then an error will be added for that field. Note that this function is synchronous\n * The `validator()` function is applied at object level and is asynchronous.\n * Type `geo` only accepts `Point` as `GeoType` at this stage. The passed value is an object with key \"coordinates\", like so: `{ coordinates: [ x, y ] }`. You can also pass a string, which will be interpreted as JSON.\n\n\n\n# Validating against a schema\n\nValidation happens with the `schema.validate()` function:\n\n    complexSchema.validate( object, {}, function( err, validatedObject, errorsArray ){\n\nThe `validate()` function takes the following parameters:\n\n * The object to validate\n * An optional `options` object with extra options\n * A callback, called with `validatedObject` (the new object with validation applied) and `errors` (an array with the list of errors triggered during validation)\n\nHere is an example of basic usage:\n\n    p = {\n      name: 'TOnyName',\n      surname: 'MOBILY',\n      age: '37',\n      id: 3424234424,\n      date: '2013-10-10',\n      list: [ 'one', 'two', 'three' ],\n      various: { a: 10, b: 20 }\n    }\n\n    complexSchema.validate( p, function( err, newP, errors ){\n      // ...\n    });\n\n`newP` will be:\n\n    { name: 'TONY',\n      surname: 'mobily',\n      age: 37,\n      id: 3424234424,\n      date: Thu Oct 10 2013 08:00:00 GMT+0800 (WST),\n      list: [ 'one', 'two', 'three' ] },\n      various: '{\"a\":10,\"b\":20}'\n    }\n\nAnd `errors` will be empty. Note that `name` is uppercase and trimmed to 4, `surname` is lowercase, `age` is now a proper Javascript number, `date` is a proper date.\n\n## The unidirectional `serialize` parameter\n\nIn some cases, you might want `serialize` to work the other way around: you want to convert a JSON string into an object. This is common if, for example, you want to 1) Receive the data via `req.body` 2) Store the data after `schema.validate()` (any `serialize` field will be serialized) 3) Later on, fetch the data from the database 4) Validate that data against the same schema (in which case, you will use the option `{ deserialize: true }`).\n\nFor example:\n\n    var Schema = require( 'simpleschema' );\n    var declare = require( 'simpledeclare' );\n    var MongoSchemaMixin = require('simpleschema-mongo')\n\n   personSchema = new Schema( {\n      name: { type: 'string', trim: 20 },\n      surname: { type: 'string', trim: 20 },\n      data: { type: 'serialize', required: true },\n    });\n\n    p = {\n      name: 'Tony',\n      surname: 'Mobily',\n      data: { a: 10, b: 20 }\n    }\n\n    personSchema.validate( p, function( err, newP, errors ){\n      if( err ) {\n        console.log(\"Err!\");\n        console.log( err );\n      } else {\n\n        // At this point, newP.data is '{\"a\":10,\"b\":20}'\n        if( errors.length ){\n          console.log(\"Validation errors!\");\n          console.log( errors );\n        } else {\n\n          console.log(\"newP:\");\n          console.log( newP );\n\n          personSchema.validate( newP, { deserialize: true }, function( err, newerP, errors ){\n            if( err ) {\n              console.log(\"Err!\");\n              console.log( err );\n            } else {\n\n              // At this point, newP.data is an object\n              if( errors.length ){\n                console.log(\"Validation errors!\");\n                console.log( errors );\n              } else {\n                console.log(\"newerP:\");\n                console.log( newerP );\n              }\n            }\n          })\n       }\n      }\n    });\n\n## The return `errors` array\n\nThe `errors` variable is an array of objects; each element contains `field` (the field that had the error) and `message` (the error message for that field). For example:\n\n    [\n      { field: 'age', message: 'Age cannot be 150' },\n      { field: 'name', message: 'Name not valid' }\n    ]\n\nA field can potentially have more than one error message attached to it.\n\n## The `options` object\n\nThe second parameter of `schema.validate()` is an (optional) options object. Possible values are:\n\n### `onlyObjectValues`\n\nThis option allows you to apply `schema.validate()` only to the fields that are actually defined in the object, regardless of what was required and what wasn't. This allows you to run `schema.validate()` against partial objects. For example:\n\n    p = {\n      name: 'MERCMOBILY',\n    }\n\n    complexSchema.validate( p, { onlyObjectValues: true }, function( err, newP, errors ){\n      // ...\n    });\n\n\n`newP` will be:\n\n    { name: 'MERC' }\n\nNote that only what \"was there\" was processed (it was cast and had parameters assigned).\n\n### `skip`\n\nIf `skip` is true, BOTH casting and validation will be skipped altogether. The callback will be called directly, no validation done. This is useful if you want to turn off validation in your program, but don't want to change the program's flow.\n\nNote that a _copy_ of the object will be passed to the callback (since the same thing would happen if `validate()` was called).\n\n### `skipValidation`\n\nIf `skipValidation` is true, casting will happen but validation won't.\n\n### `skipCast`\n\nThe option `skipCast` is used when you want to skip casting for specific fields.\n\n    p = {\n      name: 'TOny',\n      surname: 'MOBILY',\n      age: '37',\n      id: 3424234424,\n      date: '2013-10-10',\n      list: [ 'one', 'two', 'three' ]\n    }\n\n    complexSchema.validate( p, { skipCast: [ 'age' ] }, function( err, newP, errors ){\n      // ...\n    });\n\n`newP` will be (note that '37' is still a string):\n\n    { name: 'TONY',\n      surname: 'mobily',\n      age: '37',\n      id: 3424234424,\n      date: Thu Oct 10 2013 08:00:00 GMT+0800 (WST),\n      list: [ 'one', 'two', 'three' ] },\n    }\n\n\n### `skipParams`\n\nThe option `skipParams` is used when you want to decide which parameters you want to skip for which fields.\n\n    p = {\n      name: 'Chiara',\n      surname: 'MOBILY',\n      age: '37',\n      id: 3424234424,\n      date: '2013-10-10',\n      list: [ 'one', 'two', 'three' ]\n    }\n\n    complexSchema.validate( p, { skipParams: { name: [ 'uppercase', 'trim' ] } }, function( err, newP, errors ){\n      // ...\n    });\n\n`newP` will be:\n\n    { name: 'Chiara',\n      surname: 'mobily',\n      age: 37,\n      id: 3424234424,\n      date: Thu Oct 10 2013 08:00:00 GMT+0800 (WST),\n      list: [ 'one', 'two', 'three' ] },\n    }\n\nNote that `name` is still unchanged: it didn't get lowercased, nor trimmed.\n\n### `ignoreFields`\n\nThe option `ignoreFields` is used when you want some fields to be completely ignored by SimpleSchema.\n\n    p = {\n      name: 'TOny',\n      surname: 'MOBILY',\n      age: '37',\n      id: 3424234424,\n      date: '2013-10-10',\n      list: [ 'one', 'two', 'three' ],\n      spurious: 10,\n    }\n\n    complexSchema.validate( p, { ignoreFields: [ 'spurious' ] }, function( err, newP, errors ){\n      // ...\n    });\n\n`newP` will be:\n\n    { name: 'TONY',\n      surname: 'mobily',\n      age: 37,\n      id: 3424234424,\n      date: Thu Oct 10 2013 08:00:00 GMT+0800 (WST),\n      list: [ 'one', 'two', 'three' ] },\n    }\n\nNote that `spurious` was taken ot of the picture, and that `errors` is be empty (whereas it would normally complain about the extra `spurious` field being there)\n\n### `ignoreFieldsWithAttributes`\n\nThe option `ignoreFieldsWithAttributes` is used when you want to ignore all fields that have, in the schema, one of the attributes set to `true`.\n\n    p = {\n      name: 'Tony',\n      surname: 'MOBILY',\n      age: '37',\n      id: 3424234424,\n      date: '2013-10-10',\n      list: [ 'one', 'two', 'three' ],\n    }\n\n    complexSchema.validate( p, { ignoreFieldsWithAttributes: [ 'extraParameter' ] }, function( err, newP, errors ){\n      // ...\n    });\n\n`newP` will be:\n\n    { name: 'TONY',\n      surname: 'mobily',\n      id: 3424234424,\n      date: Thu Oct 10 2013 08:00:00 GMT+0800 (WST),\n      list: [ 'one', 'two', 'three' ] },\n    }\n\nNote that `age` is out of the picture, because it has `extraParameter` set to true.\n\n### `deserialize`\n\nThis option, if set to `true`, will make `serialize` work the opposite way: data will be converted back to Javascript Objects (see explanation above).\n\n## The 'required' parameter is special\n\nAll field types and parameters are completely equal as far as `validate()` is concerned -- except one: `required`.\n\nWhen dealing with `required`, remember that:\n\n1) `validate()` won't attempt to cast an object value if it's `undefined` and `required` is `false`. If `required` weren't special, casting (and therefore validation as a whole) would (erroneously) fail for values that are both optional and missing.\n\n2) If the `required` constraint is not met, then other parameters (`max`, `default`, etc.) will not be applied (obviouly)\n\n3) If you want to safely skip `required` as a parameter, you will also need to turn off casting for that field. If you don't, then casting will possibly fail (as it will try to cast from `undefined`, with possibly strange results). If for example you wanted to override `id`'s schema definition making it optional rather than required, you would run `validate()` this way:\n\n    complexSchema.validate( p, { skipCast: 'id', skipParams: { id: [ 'required' ] } }, function( err, newP, errors ){\n\n## (Per-field) sync and (object-wide) async validation\n\nYou can use functions to validate data. There are two cases:\n\n### Per field, sync validation\n\nIn the schema, you can define a field as follows:\n\n    age:  { type: 'number', default: 15, min: 10, max: 40, validator: fieldValidatorFunc },\n\nWhere `fieldValidatorFunc` is:\n\n    var fieldValidatorFunc =  function( obj, value, fieldName ){\n      if( value == 150 ) return 'Age cannot be 150';\n      return;\n    };\n\nIn `fieldValidatorFunc`, the `this` variable is the schema object. If the function returns a string, that will be the error. If it returns nothing, then validation went through.\n\nNote that this validation is synchronous. It's meant to be used to check field sanity.\n\n### Object-wide, async validation\n\nThe second parameter of the construction object is a hash. If the `validator` key is set, that function will be used for validation. One bonus of this function is that it's asynchronous. This function is there in cases where you need more complex, asynchronous validation that relies on running asynchronous functions.\n\nFor example:\n\n    complexSchema = new Schema({\n      name:    { type: 'string', lowercase: true, trim: 30, required: true, notEmpty: true },\n      surname: { type: 'string', uppercase: true, trim: 50, required: true, notEmpty: true },\n    },\n    {\n      validator: function( object, originalObject, castObject, options, done ){\n        var errors = [];\n\n        db.collection.bannedNames.find( { name: object.name }, function( err, docs ){\n          if( err ){\n            done( err );\n          } else {\n            if( docs.length ){\n              errors.push( { field: 'name', message: 'Name not valid or not allowed' } );\n            }\n            done( null, errors );\n          }\n        });\n\n      }\n    });\n\nNote that you have several versions of the object: `object` is the object once all casting and all parameters are applied to it; `originalObject` is the one passed originally to `validate()`; `castObject` is the object with only casting applied to it.\n\nYou also have access to the `options` passed when you did run `validate()`. For example, you could do:\n\n    asyncValidatedSchema = new Schema({\n      name:    { type: 'string', lowercase: true, trim: 30, required: true, notEmpty: true },\n      surname: { type: 'string', uppercase: true, trim: 50, required: true, notEmpty: true },\n    },\n    {\n      validator: function( object, originalObject, castObject, options, done ){\n        var errors = [];\n\n        // Check options, skip check if `skipDbCheck` was passed\n        if( options.skipDbCheck ){ return done( null, [] ) }\n\n        db.collection.bannedNames.find( { name: object.name }, function( err, docs ){\n          if( err ){\n            done( err );\n          } else {\n            if( docs.length ){\n              errors.push( { field: 'name', message: 'Name not valid or not allowed' } );\n            }\n            done( null, errors );\n          }\n        });\n\n      }\n    });\n\n    var p = { name: 'Tony', surname: 'Mobily' };\n\n    asyncValidatedSchema.validate( p, { skipDbCheck: true }, function( err, newP, errors ){\n      if( err ){\n        console.log('Callback failed:\");\n        console.log( err );\n      } else {\n        console.log(\"Validation errors:\");\n        console.log( errors );\n    });\n\n#### For the curious minds\n\n`validate()` actually works in two phases:\n\n  * Runs `_cast()` to cast object values to the right type. Casting is actually delegated to _casting functions_ (for example, `booleanTypeCast()` for the type `boolean`). `_cast()` will take into account the options `onlyObjectValues` (which will make `_cast()` only work on fields that actually already exist in the object to be cast, allowing you to cast partial objects), `skipCast` (an array of fields for which casting will be skipped), `ignoreFields` and `ignoreFieldsWithAttributes` (instructs which fields are to be ignored altogether).\n\n  * Runs `_params()` to apply schema parameters to the corresponding object fields. Just like `_cast()`, this function simply delegates all functionalities to the _schema params functions_ (for example, `uppercaseTypeParam()`). `_params()` will take into account of the options `onlyObjectValues` (applying parameters only to fields that already exist in the object), `skipParams` (which allows you to decide what parameters should _not_ be applied to specific fields), `ignoreFields` and `ignoreFieldsWithAttributes` (instructs which fields are to be ignored altogether).\n\n## Extending a schema\n\nThe basic schema is there to be extended. It's very easy to define new types (casting) and new parameters (field manipulation): all you need to do is create a new constructor that inherits from Schema, and add appropriately named methods.\n\nThe easiest way to extend a schema is by using [SimpleDeclare - Github](https://github.com/mercmobily/simpleDeclare).\n\nFor example:\n\n    var Schema = require( 'simpleschema' );\n    var NewSchema = declare( Schema, {\n\n      incrementByTypeParam: function( p ){\n        if( typeof( p.value ) !== 'number' ) return; // Only works with numbers\n        return p.value = p.value + p.parameterValue;\n      },\n\n      booleanTypeCast: function( definition, value, fieldName, failedCasts ){\n        return !!value;\n      },\n    });\n\nNow in your schema you can have entries like:\n\n    age:     { type: 'number', incrementBy: 10 },\n    enabled: { type: 'boolean' },\n\nYou can also create new schema without using SimpleDeclare, but the good old nodejs way:\n\n    var Schema = require( 'simpleschema' );\n\n    function NewSchema( structure, options ){\n      Schema.apply( this, arguments );\n    }\n    require('util').inherits( NewSchema, Schema );\n\n    NewSchema.prototype.incrementByTypeParam = function( p ){\n      if( typeof( p.value ) !== 'number' ) return; // Only works with numbers\n      return p.value = p.value + p.parameterValue;\n    }\n    NewSchema.prototype.booleanTypeCast = function( definition, value, fieldName, failedCasts ){\n      return !!value;\n    }\n\nI cannot really write this code without a cringing feeling in my stomach. But, it's up to you.\n\n### Extending types\n\nTypes are defined by casting functions. When `validate()` encounters:\n\n    surname: { type: 'string', lowercase: true },\n\nIt looks into the schema for a function called `stringTypeCast`. It finds it, so it runs:\n\n    stringTypeCast: function( definition, value, fieldName, options, failedCasts ){\n\n      // Undefined: return '';\n      if( typeof( value ) === 'undefined' ) return '';\n\n      // No toString() available: failing to cast\n      if( typeof( value.toString ) === 'undefined' ){\n        failedCasts[ fieldName ] = true;\n        return;\n      }\n\n      // Return cast value\n      return value.toString();\n    },\n\nNote that the casting function must:\n\n* EITHER return the cast value\n* OR return nothing, and add an entry to the failedCasts hash\n\nThe parameters passed to the function are:\n\n* `definition`. The full definition for that field. For example, `{ type: 'string', lowercase: true }`\n* `value`. The value of the record for that field\n* `fieldName`. The field's name\n*  `options`: Options passed to the `validate()` function\n* `failedCasts`. A hash variable, that needs to be \"enriched\" if a cast fails (see above)\n\n### Extending parameters\n\nParameters are based on the same principle. So, when `validate()` encounters:\n\n    surname: { type: 'string', lowercase: true },\n\nit will look for `this.lowercaseTypeParam()`, which is:\n\n    lowercaseTypeParam: function( p ){\n      if( typeof( p.value ) !== 'string' ) return;\n      return  p.value.toLowerCase();\n    },\n\nNote that the checking function must:\n\n* EITHER return the new value (which will replace the old one)\n* OR return nothing (the original value won't be changed)\n\nThe `p` parameter is a hash with the following values:\n\n *  `value`: The value of that field for the passed object. Note that parameters are applied sequentially. So, if you have a field defined as `{ type: 'string', trim: 10, uppercase: true }`, by the time `uppercase` is applied, `value` will already be trimmed.\n *  `valueBeforeParams`: The value of that field before _any_ parameters were applied\n *  `object`: The full passed object. The same concept of parameters applied sequentially applies.\n *  `objectBeforeCast`: The full object before casting was applied\n *  `objectBeforeParams`: The full object before _any_ params were applied.\n *  `fieldName`: The field's name\n *  `definition`: The full definition for that schema field (`{ type: 'number', incrementBy: 10 }`)\n *  `parameterName`: The name of this particular parameter in the definition. For example, for `{ default: 'some', max: 10 }` while processing `max`, `parameter` will be `max`.\n *  `parameterValue`: The value for this particular parameter in the definition (for example, for `max` it would be `10`).\n *  `errors`: The errors array that will be \"augmented\" with errors if necessary (new errors will need to be `push()`ed\n *  `options`: Options passed to the `validate()` function\n\n# API description\n\nThis is the full list of functions available with this module:\n\n## `constructor()`\n\nMake up the schema object, assigning the `this.structure` field.\n\nParameters:\n\n  * `schemaObject` The schema structure\n  * `options` An optional `options` object which can have:\n    * `validator` -- The validator function\n    * (that's it for now)\n\n## `xxxTypeCast( definition, value, fieldName, options, failedCasts )`\n\nHelper function that will define the type `xxx`. Used when you have, in your schema, something like `field1: { type: 'xxx' }`\n\n# `xxxTypeParam( p )`\n\nHelper function to define possible parameters (other than \"type\"). Note that a parameter can apply to _any_ type -- it's up to the parameter helper function to decide what to do.\n\n## `validate( object, options, callback)`\n\nApplies schema casting and parameters to the passed object.\n\nParameters:\n\n  * `object`. The object to cast and check\n  * `options`. Options received by all param and casting functions\n  * `callback`. The callback to call once validation is done\n\n## `cleanup()`\n\nClean up fields with a specific parameter defined.\n\nParameters:\n\n  * `object` The object to cleanup\n  * `parameterName` The name of the parameter that will be hunted down. Any field that in the schema structure has thar parameter fill be deleted from `object`\n\n## `makeId()`\n\nFunction that returns a generated unique ID. It could be `ObjectId()` (mongoDB) or a new SEQUENCE number (MariaDB). Specific drivers will tend to rewrite this function.\n\nParameters:\n\n  * `object` The object for which the unique ID will be created\n  * `cb` The callback to call once the ID is created\n\nNOTE: the `makeId()` function is likely to be overridden by driver-specific ones.\n\n## \"Class\" (or \"constructor function\") functions\n\nThe \"Class\" itself has the method `makeId()` available. They are useful as \"Class\" functions as they might get used by an application while _creating_ an object.\n\n# Driver-specific Mixins\n\nSimpleSchema comes with pre-defined mixins that allow you to extend the type and parameters available to SimpleSchema.\n\n## MongoSchemaMixin\n\nMongoSchemaMixin is available from [SimpleSchema-MongoDb](https://github.com/mercmobily/simpleschema-mongodb). When you use MongoSchemaMixin:\n\n* The type `id` will be a proper MondoDb ObjectId object\n* The object _and_ class function `makeId()` will return a new MongoDb ObjectId object\n",
  "readmeFilename": "README.md",
  "gitHead": "7266f798ba2a6631ae58c7a504d5c27bbb675edc",
  "bugs": {
    "url": "https://github.com/mercmobily/SimpleSchema/issues"
  },
  "homepage": "https://github.com/mercmobily/SimpleSchema#readme",
  "_id": "simpleschema@0.3.14",
  "scripts": {},
  "_shasum": "039bc8fbe4e1f8d85ab1470a1220a18c95d20743",
  "_from": "simpleschema@>=0.3.0 <0.4.0"
}
