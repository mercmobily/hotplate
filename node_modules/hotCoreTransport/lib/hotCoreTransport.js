"use strict";

var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , declare = require('simpledeclare')
  , async = require('async')
  , debug = require('debug')('hotplate:hotCoreTransport:main')

  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )
  , logger = hotCoreServerLogger
;

/**
Provides tranport functionalities (SMS an email) to hotplate modules

@module hotCoreTransport
@main hotCoreTransport
@class hotCoreTransport
@static
*/


// The stores variable is module-wide as some functions use them
var stores = {}

// Set some sane defaults

hotplate.config.set('hotCoreTransport', {
  outgoingQueueInterval: 5000,
  pollInterval: 5000,

  activeTransports: {
    'email-default': {
      attachmentSizeLimit: 200000
    },
    //'sms-twilio': {},
    'sms-plivo': {
      signatureHost: null,

    },
  } 
});


hotplate.hotEvents.on( 'stores', 'hotCoreTransport', hotplate.cachable( function( done ){

  hotCoreJsonRestStores.get( function( err, s ){
    if( err ) return done( err );

    var HotStore = s.HotStore;
    var HotSchema = s.HotSchema;
    var BasicDbStore = s.BasicDbStore;
    var BasicSchema = s.BasicSchema;
 
    var Messages = declare( [ BasicDbStore ],  {

      schema: new HotSchema({
        id          : { type: 'id',     searchable: true },

        foreignId   : { type: 'string',    searchable: true, required: false,  notEmpty: true, trim: 255 }, 
        foreignData : { type: 'serialize', searchable: false, required: false,  notEmpty: true, trim: 256000 }, 

        type        : { type: 'string', searchable: true, required: true,  notEmpty: true, trim: 5 },        
        incoming    : { type: 'boolean', searchable: true, required: true },
        from        : { type: 'string', searchable: true, required: true,  notEmpty: false, trim: 255 },        
        subject     : { type: 'string', searchable: true, required: false, notEmpty: false, trim: 1024 },
        bodyText    : { type: 'string', searchable: true, required: false,  notEmpty: false, trim: 256000 },
        bodyHtml    : { type: 'string', searchable: true, required: false,  notEmpty: false, trim: 256000 },

     }),

      idProperty: 'id',

      storeName:  'messages',

      nested: [
        {
          layer: 'messagesTo',
          join: { 'messageId': 'id' },
          type: 'multiple'
        },

        {
          layer: 'messagesAttachments',
          join: { 'messageId': 'id' },
          type: 'multiple'
        },

        {
          layer: 'messagesDeliveryLog',
          join: { 'messageId': 'id' },
          type: 'multiple'
        },
      ],

      hotExpose: false,

    });
    stores.messages = new Messages();


    var MessagesAttachments = declare( [ BasicDbStore ],  {

      schema: new BasicSchema({
        id             : { type: 'id', searchable: true },
        messageId      : { type: 'id', searchable: true },

        foreignId      : { type: 'string', searchable: true, required: false,  notEmpty: true, trim: 255 }, 
        retrieved      : { type: 'boolean', default: false },
        fileName       : { type: 'string', searchable: false, required: false,  notEmpty: true, trim: 255 }, 
        mimeType       : { type: 'string', searchable: false, required: false,  notEmpty: true, trim: 255 },
        size           : { type: 'number', searchable: false, required: false,  notempty: true },
        embeddedId     : { type: 'string', searchable: false, required: false,  notEmpty: true, trim: 255 },

        attachmentInfo : { type: 'serialize', required: false },
        attachmentData : { type: 'blob', searchable: false, required: false },        
      }),

      idProperty: 'id',

      storeName:  'messagesAttachments',

      hotExpose: false,

      nested: [
        {
          layer: 'messages',
          join: { 'id' : 'messageId' },
          type: 'lookup',
          parentField: 'messageId',
        },
      ],

    });
    stores.messagesAttachments = new MessagesAttachments();

    // Status can be: todeliver, delivering, delivered, undeliverable, dontdeliver
    var MessagesTo = declare( [ BasicDbStore ],  {

      schema: new BasicSchema({
        id             : { type: 'id', searchable: true },
        messageId      : { type: 'id', searchable: true },

        to             : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 255 },        
        status         : { type: 'string', searchable: true, required: true, notEmpty: true, trim: 15 },
        failedAttempts : { type: 'number', searchable: true, required: true, default: 0, notEmpty: true },
        added          : { type: 'date', protected: true, default: function() { return new Date() } },
        lastChange     : { type: 'date', protected: false, default: function() { return new Date() } },
      }),

      idProperty: 'id',

      storeName:  'messagesTo',

      hotExpose: false,

      nested: [
        {
          layer: 'messages',
          join: { 'id' : 'messageId' },
          type: 'lookup',
          parentField: 'messageId',
        },
      ],

    });
    stores.messagesTo = new MessagesTo();


    var MessagesDeliveryLog = declare( [ BasicDbStore ],  {

      schema: new BasicSchema({
        id            : { type: 'id', searchable: true },

        messageToId   : { type: 'id', required: false, searchable: true },
        messageId     : { type: 'id', required: false, searchable: true }, // NN

        date          : { type: 'date', protected: true, default: function() { return new Date() } },
        level         : { type: 'number', default: 1 },
        line          : { type: 'string', searchable: false, required: true, notEmpty: true, trim: 2048 },        
        config        : { type: 'serialize' }
      }),

      onlineSearchSchema: new HotSchema({
      }),

      nested: [
        {
          layer: 'messages',
          join: { 'id' : 'messageId' },
          type: 'lookup',
          parentField: 'messageId',
        },
        {
          layer: 'messagesTo',
          join: { 'id' : 'messageToId' },
          type: 'lookup',
          parentField: 'messageToId',
        },
      ],

      idProperty: 'id',

      storeName:  'messagesDeliveryLog',

      hotExpose: false,

    });
    stores.messagesDeliveryLog = new MessagesDeliveryLog();

    done( null, stores );
  });

}))



// Utility functions to get the transport's config

var getAllTransportConfig = function( transport, done ){

  hotplate.hotEvents.emit( 'allTransportConfig', transport, function( err, results ) { 
    if( err ) { console.log("ERROR: ", err ); return done( err ); } 

    // No configuration available: return null
    if( ! Array.isArray( results ) || results.length === 0 ) return done( err, [ ] );

    // Return flattened results
    done( null, Array.prototype.concat.apply([], results.onlyResults() ));
    
  });
};

var getTransportConfig = function( messageTo, done ){

  hotplate.hotEvents.emit( 'transportConfig', messageTo, function( err, results ) { 
    if( err ) return done( err );

    // No configuration available: return null
    if( ! Array.isArray( results ) || results.length === 0 ) return done( err, null )

    // If more than one, issue a warning
    if( results.length > 1 ) debug("WARNING: more than 1 results returned for ", messageTo );

    // Return the first result
    done( null, results[ 0 ].result );
  });

};


// Functions that use the sub-layers to work.
// * getPollingStatus() (exported) calls the transport's pollingStatus() function
// * The events 'setRoute' and 'run' will trigger the corresponding functions in each active transport
// * The event 'run' will also call setTransportCron(), which:
//    - For sendMessage(), it will cycle through the message queue calling the transport's sendMessage() for each
//    - For startPolling() (exported), it will call the transport's startPolling() call
//
// Exported:
// * startPolling(). This will enable other modules to force polling for a specific transport
// * getPollingStatus(). This will enable other modules to see what the status us for a specific transport

var startPolling = exports.startPolling = function( transport, stores, config, force ){
  require('./transport/' + transport + '.js' ).startPolling( stores, config, force );
}

var getPollingStatus = exports.getPollingStatus = function( transport, config, done ){
  require('./transport/' + transport + '.js' ).getPollingStatus( config, done );
}

// Message moving functions
var sendMessage = function( transport, stores, messageTo, config, done ){
  require('./transport/' + transport + '.js' ).sendMessage( stores, messageTo, config, done );
}

/**
  @event setRoutes
*/
hotplate.hotEvents.on( 'setRoutes', 'hotCoreTransport', function( app, done ){

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
    if( err ) return done( err );

    async.eachSeries(
      Object.keys( hotplate.config.get('hotCoreTransport').activeTransports),
      function( transport, cb ){

        getAllTransportConfig( transport, function( err, configArray ){
          if( err ) return cb( err );

          var transportModule = require('./transport/' + transport + '.js' );
          // Run setRoutes for relevant module

          transportModule.setRoutes( storeRegistry, app, configArray, cb );
        });
      },
      function( err ){
        if( err ) return done( err );
        done( null );
      }
    );
  });
});


/**
  @event run
*/
hotplate.hotEvents.on( 'run', 'hotCoreTransport', function( done ){

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
    if( err ) return done( err );

    async.eachSeries(
      Object.keys( hotplate.config.get('hotCoreTransport').activeTransports ),
      function( transport, cb ){
        // Run setRoutes for relevant module

        getAllTransportConfig( transport, function( err, configArray ){
          if( err ) return cb( err );

          var transportModule = require('./transport/' + transport + '.js' ).run( storeRegistry, configArray, cb );
        });
      },
      function( err ){
        if( err ) return done( err );  

        startTransportCron(); // Set the main cron for transport
        done( null );
      }
    );
  });
});



// Runs through the message queue, attempting to send messages
function startTransportCron(){

  var inCycle = false;
  var inPollingCycle = false;

  hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
    if( err ) {
      logger.log( { error: err, system: true, logLevel: 3, message: "Error while getting all stores" } );
      return;
    };

    // INGOING: Receive messages by polling
    // This function will start once a minute, and will call
    // transportModule.startPolling() for each active module/config pair
    setInterval( function(){

      debug("**************************Running polling cron")

      // Do not run cron twice
      if( inPollingCycle) {
        debug("**********************************************************************************");
        debug("************************** Polling cron quit as the previous one was still running");
        debug("**********************************************************************************");
        return;
      }
      inPollingCycle = true;

      async.eachSeries(
        Object.keys( hotplate.config.get('hotCoreTransport').activeTransports ),
        function( transport, cb ){

          getAllTransportConfig( transport, function( err, configArray ){
            if( err ){
              logger.log( { error: err, system: true, logLevel: 3, message: "Error while running getAllTransportConfig", data: { transport: transport } } );
              // This returns "all good" as cycle will need to continue for other transports
              return cb( null );
            }

            debug("Config array:", configArray );

            // For each config attached to that transport, start polling
            configArray.forEach( function( config ){
              debug("Polling for %o", config );
              startPolling( transport, stores, config );
            })

            // This returns "all good" as cycle will need to continue for other transports configs
            return cb( null );
          })

        },
        function( err ){
          debug( "*****************************Polling cron finished! Setting inPollingCycle to false" );
          // Nothing ever sets 'err'
          // Anything wrong is dealt with by logger.log
          // All that needs to happen, is that inPollingCycle is false as the cycle is finished
          inPollingCycle = false;
        }
      )

    }, hotplate.config.get('hotCoreTransport.pollInterval' ) );
 

    // OUTGOING: Send messages using sendMessage()

    setInterval( function(){

      debug("CRON to send messages started");
      // Do not run cron twice
      if( inCycle) {
        debug("CRON to send messages quit as it was still running");
        logger.log( { system: true, logLevel: 2, message: "Cron to sent messages not started as it is marked as 'already running'" } );
        return;
      }
      inCycle = true;

      // Get the cursor for elements in messagesTo...
      stores.messagesTo.dbLayer.select( {conditions: { and: [ /*{ field: 'failedAttempts', 'type': 'lt', value: 50 }, */ { field: 'status', type: 'is', value: 'todeliver' } ]  } }, { useCursor: true , delete: false, children: true }, function( err, cursor, total, grandTotal ){

        // If the cursor cannot be obtained, set inCycle as false, log the problem and get out
        if( err ) {
          inCycle = false; 
          logger.log( { error: err, system: true, logLevel: 3, message: "Error getting cursor for queue" } );
          return;
        }; 

        // Go through the cursor asynchromously using async
        // NOTE that the cycle will not wait for each sendMessage() to finish. However,
        // if sendMessage() returns with an error, errInCycle is set and excution of the cycle
        // will be interrupted half way. The rationale is that if there is a bad error with sending
        // a message, there is no point in continuing with the others
        var i;
        async.doWhilst(

          function( callback ){

            cursor.next( function( err, messageTo ){
              if( err ) return callback( err );

              i = messageTo;

              console.log("MESSAGETO1 HERE IS:", messageTo );

              // If messageTo is null, just return. This is here because
              // cursor.next WILL return 'null' to indicate the last one
              if( messageTo === null ) return callback( null ); 

              console.log("MESSAGETO2 HERE IS:", messageTo );
            
              // ******************************************
              // THIS IS WHERE EACH MESSAGE IS EVALUATED
              // ******************************************                  

              // Get the config for that message from the application
              getTransportConfig( messageTo, function( err, transportConfig ){
                if( err ){
                  logger.log( { error: err, system: true, logLevel: 3, message: "Error while getting transport configuration", data: { config: config, messageTo: messageTo } } );
                  return;
                }
                // Send the message!
                // This will only ever return with err !== null when something goes horribly wrong.
                // Undeliverable messages, socket timeouts etc.  mustn't do that.
                console.log("MESSAGETO3 HERE IS:", messageTo, transportConfig );
                sendMessage( transportConfig.transport, stores, messageTo, transportConfig.config);
              });

              // This is in the right spot! This cycle doesn't wait for getTransportConfig or sendMessage()
              // to finish.
              callback( null );

            });
          },

          function(){ return i != null; },

          function( err ) {
            inCycle = false; 
            debug( "CRON sending message finished!" );
            return; 
          }
        );
      });     


    }, hotplate.config.get('hotCoreTransport.outgoingQueueInterval', 60000 ) );
  });

}

/* Utility functions used by sublayers 
   These functions are always availanle to sub-layers, which will use them
   to make things happen
*/

exports.transportLayerFunctions = {};

/* Note
   ----
   The following functions are _guaranteed_ to be called once the module's stores' variable
   is set, because they are only ever called by the sub-systems (sms-plivo, email-default,
   etc.), which is always required/run once hotCoreStoreRegistry.getAllStores() has been run
*/

// Log a line to messageDeliveryLog
var formatError = exports.transportLayerFunctions.formatError = function( err ){
  return err.name + ': ' + err.message;
}


// Log a line to messageDeliveryLog
// There is no callback for this function if anything goes wrong, it will call logger.log
// Note that logger.log is _always_ called to issue a system entry if logLevel is >= 3.
// These are problems that need to be looked at if they do happen
var logLine = exports.transportLayerFunctions.logLine = function( config, messageTo, logLevel, line, errInLogline ){

  debug("logLine called: ", config, messageTo, logLevel, line, errInLogline );

  // If logLine is called with an error as last parameter, it means it's indicating that
  // something failed: log it as critical
  if( errInLogline ){
    debug("Logline was called with an error parameter: ", errInLogline );

    // For errors of levels 1 and 2, show the error name and message on the log line
    // Transport layers should leep in mind that errors for levels 1 and 2 are displayed to the user
    // in form of mail delivery log. Timeouts and auth errors are fine, DB errors are not.
    if( logLevel < 3 ) {
      line += " -- Error: " + formatError( errInLogline );
  
    // For errors of levels 3 and up, absolutely log them with hotplate
    // Note that since the loglevel is high, hotCoreServerLogger will also issue
    // a hotplate. critical() ( which will display on the screen)
    } else {
      logger.log( { error: errInLogline, system: true, logLevel: logLevel, message: "hotCoreTransport.logLine logged: " + line, data: { config: config, messageTo: messageTo } } );
    }
  }

  var o = {
    level: logLevel,
    line: line,
    config: config
  }
  if( messageTo ){
    o.messageToId = messageTo.id;
    o.messageId = messageTo.messageId;
  }

  stores.messagesDeliveryLog.apiPost(o, function( err ){

    if( err ){
      // Error while adding the entry: this is an important system error, log the event
      logger.log( { error: err, system: true, logLevel: 3, message: "Error while writing on messagesDeliveryLog with apiPost", data: { lineData: o } } );
      return;
    }

    hotplate.hotEvents.emit( 'transportLog', config, messageTo, logLevel, line, errInLogline, function( err, results ) { 
      // Error while emitting transportLog: this is an important system error, log the event
      if( err ){ 
        logger.log( { error: err, system: true, logLevel: 3, message: "Error while emitting transportLog", data: { config: config, messageTo: messageTo, logLevel: logLevel, line: line, errInLogLine: errInLogLine } } );
      }
    });
  });
}

// If `failedAttempt`, and the messageTo.failedAttempt > 5, newMessageStatus is forced to `undeliverable`
// Failing to broadcast will result in logging with loglevel 3, but will not result in done( err ) as
// it's not critical (the status has actually changed)
exports.transportLayerFunctions.changeMessageStatus = function( config, messageTo, failedAttempt, newMessageStatus, done ){

  // For failed attempts or message status updates, the function will need to
  // write over messageTo. NOTE: if failedAttempts > 5, status is forced to 'undeliverable'.
  if( failedAttempt ) messageTo.failedAttempts ++;

  messageTo.status =  messageTo.failedAttempts > 5 ? 'undeliverable' : newMessageStatus;

  stores.messagesTo.dbLayer.update( { conditions: { and: [ { field: 'id', type: 'is', value: messageTo.id  } ] } }, { status: messageTo.status, failedAttempts: messageTo.failedAttempts }, function( err ){

    if( err ){
      logLine( stores, config, messageTo, 3, "Could not change the message status to " + newMessageStatus, err );
      return done( err );
    }
    
    // If the emit fails the error is logged (loglevel 3) but done(null) as it's not critical
    hotplate.hotEvents.emit( 'changeMessageStatus', config, messageTo, function( err ) {
      if( err ){
        logLine( stores, config, messageTo, 3, "Error broadcasting the change of status", err );
      } 

      done( null );
    });
  });
}

exports.transportLayerFunctions.deleteUnfinishedMessage = function( config, messageId ){

  stores.messagesTo.delete( { conditions: { and: [ { field: 'messageId', type: 'is', value: messageId  } ] } }, { multi: true }, function( err ){
    if( err ){
      logger.log( { error: err, system: true, logLevel: 3, message: "Error while deleting elements from messageTo for incomplete message", data: { config: config, messageId: messageId } } );
    }

    stores.messagesAttachments.delete( { conditions: { and: [ { field: 'messageId', type: 'is', value: messageId  } ] } }, { multi: true }, function( err ){
      if( err ){
        logger.log( { error: err, system: true, logLevel: 3, message: "Error while deleting elements from messageAttachments for incomplete message", data: { config: config, messageId: messageId } } );
      }
    });

  })

  
}
