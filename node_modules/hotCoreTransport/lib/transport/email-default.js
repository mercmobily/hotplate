"use strict";

/*
TODO:
[X] Rewrite lot so that it's two different functions
[X] Add a counter to see if the imap connection can actually be closed
[X] Rewrite logging/status functions as two separate ones, change code that use them
[X] Rework naming of some variables to be consistent in terms of text/body

[X] Close/kill connection RANDOMLY too early, and see if errors are shown properly

"LOGGING"
[X] Emit events when logging, decide what to do about events that are not message-specific
[X] Change logLine so that it only adds to messagesDeliveryLog if there is messageTo
[X] Add 'config' to message logging

"REVERSE-ADDING"
[X] Add the messages/messagesTo to the database, checking that the unique ID is not duplicated.
[X] Serialise attachment data onto the database in ad-hoc field
[X] Emit events so that app can update their shit too
[X] Make bookingDojo add messages with those signals
[X] Only when EVERYTHING is OK, mark messages as read on server
[X] Change config name of "smtpSystemEmail" to something more generic
[X] Add function to delete records in messages, messagesTo, messagesAttachments (not logs) if error
[X] If message was already in database, try to mark it as read while giving up on fetch
[X] Place full IMAP fetched headers in foreignData
[X] Chech flow of hell-ish imap-fetching function
[X] Check why socket timeout is triggered regardless of data going through, probably change to keepAlive

[Saturday]
* Fix logging before it's too late, in the WHOLE of hotplate, MongoMixin, and hotCoreTransport

[Monday]
* Move out some of the functions, decide if it's OK to pass stores as arguments
* Allow the system to return a stream rather than the part directly with different function

[Tuesday/Wednesday/Thursday]
* Figure out how the API should work -- forward thinking required. Stores? Module calls?
  Thought: since stores will need authentication etc, it should be function-based
* Add API interface (stores?) for
  1) IMAP status
  1a) IMAP force fetch 
  2) Fetching an attachment as stream
  3) Fetching an attachment and storing it locally
  4) Delete attachment data
* Check how to download things if imap credentials are gone or changed (probably impossible)
  MAYBE add way to check if download of attachments is still possible (MD5 of config object the same?)

*/

var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , declare = require('simpledeclare')
  , nodemailer = require('nodemailer')

  , inspect = require('util').inspect
  , fs      = require('fs')
  , base64  = require('base64-stream')
  , Imap    = require('imap')
  , async   = require('async')

  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )
;

function show(obj) {
  return requre('util').inspect( obj, { depth: Infinity } );
}

function die(err) {
  console.log('Uh oh: ' + err);
  process.exit(1);
}


// This function will take `struct` as a parameter, and will
// return an object where `text` and/or `html` are possibly
// set based on its contents.
function findBodyParts( struct, result ) {

  var result = result || { text: null, html: null };

  for( var i = 0, len = struct.length; i < len; i++ ) {

    // If it's an array, scan that recursively. Pass `result` to it,
    // so that it keeps on enriching the same object
    if( Array.isArray( struct[i] ) ) {
      findBodyParts( struct[i], result );

    // If it's a normal element, use it to try and enrich
    // result with `plain` or `html` (if available)
    } else {

      var s = struct[ i ];
      if( s.type.toLowerCase() === 'text' ){
        if( ! result.text && s.subtype.toLowerCase() === 'plain' ){
          result.text = s;
        }
       if( ! result.html && s.subtype.toLowerCase() === 'html' ){
          result.html = s;
        }         
      }
    }

    // Exit early if not all elements have been scanned yet, but result
    // is already complete.
    if( result.text && result.html ) return result;
  }

  return result;
}

// This function will take `struct` as a parameter, and will
// return an object where `text` and/or `html` are possibly
// set based on its contents.
function findAttachments( struct, result ) {

  var result = result || [ ];

  for( var i = 0, len = struct.length; i < len; i++ ) {

    // If it's an array, scan that recursively. Pass `result` to it,
    // so that it keeps on enriching the same object
    if( Array.isArray( struct[i] ) ) {
      findAttachments( struct[i], result );

    // If it's a normal element, use it to try and enrich
    // result with `plain` or `html` (if available)
    } else {

      var s = struct[ i ];
      if( s.type.toLowerCase() === 'application' ){
        result.push( s );
      }
    }
  }

  return result;
}



function fetchMessagePart( imap, uid, partID, done ){

  if( ! partID ) return done( null, null );

  var hadErrInMessage, hadErrInBody;
  var fullPart = { body: '', attributes: null, info: null }
  var f = imap.fetch(uid, { bodies: [ partID ] } );

  // Since this function will only ever fetch one part, it will only
  // ever receive either "message" or "error", never body. So,
  // having a 'errInFetch`  (and checking for it) would be pointless
  f.on('error', function( err) {
    done( err );
  });

  f.on('message', function( m ) {
 
    // If there is an error, note that it happened and
    // simply call the callback
    m.on( 'error', function( err ){
      hadErrInMessage = err;
      done( err );
    });

    // Get the attributes
    m.on( 'attributes', function( attributes ) {

      if( hadErrInMessage) return;

      fullPart.attributes = attributes;
    });

    // Get the body
    m.on('body', function( stream, info) {

      if( hadErrInMessage) return;

      // Assign the part info
      fullPart.info = info;

      stream.on('data', function( d ) {
        fullPart.body += d;
      });
    
      // If there is an error, note that it happened and
      // simply call the callback
      stream.on( 'error', function( err ){
        hadErrInBody = err;
        done( err );
      })

    });

    // Not catching m.on( 'end' ) nor stream.on( 'end' ) as will already catch f.on('end')
    // that always comes afterwards
  });

  f.on('end', function() {
  
    // If hadErrIn**** is set, then the callback has already been called.
    if( hadErrInBody || hadErrInMessage ){
      return;
    }

    done( null, fullPart );        

  });

}


function fetchMessageWithBodyParts( imap, uid, fetchOptions, done ){

  // Unfinished, initial fullMessage object
  var fullMessage = { uid: null, body: '', bodyHtml: '', headers: null, attachmentParts: [] };
  var hadErrInBody, hadErrInMessage;
  var attributes, messageRawBody = '';

  // Just in case. Without this, this function cannot work.
  fetchOptions.struct = true;

  // Run the imap
  var f = imap.fetch(uid, fetchOptions );

  // Since this function will only ever fetch one part, it will only
  // ever receive either "message" or "error", never body. So,
  // having a 'errInFetch`  (and checking for it) would be pointless
  f.once('error', function( err) {
    console.log("Fetch - ERROR: ", err );
    done( err );
  });

  f.once('message', function( msg, seqno) {

    var prefix = "[" + seqno + "] ";

    console.log( prefix + "Fetch - Message");

    // Set hadErrorInMessage in case of errors
    msg.once('error', function( err) {

      console.log( prefix + "Message - ERROR: ", err );

      hadErrInMessage = true;
      done( err );
    });

    // Assign 'attributes'
    msg.once('attributes', function( _attributes ) {
      console.log( prefix + "Message - attributes: " );

      if( hadErrInMessage ) return;

      attributes = _attributes;
    });
    
    // Assign 'messageRawBody'
    msg.on( 'body', function(stream, info) {

      console.log( prefix + "Message - body: " );

      if( hadErrInMessage ) return;

      stream.on( 'error', function( err ){
        console.log( prefix + "Stream - ERROR: ", err );

        hadErrInBody = err;
        cb( err );
      });
      stream.on( 'data', function( d ){
        console.log( prefix + "Stream - data: " );

        if( hadErrInBody ) return;
        messageRawBody += d;
      });

    });

    // Not catching f.on( 'end' ) nor stream.on( 'end' ) as will already catch msg.on( 'end' )
    // that is absolutely enough
    
    msg.once('end', function() {
      console.log( prefix + "Message - end: " );

      if( hadErrInMessage || hadErrInBody ) return;

      // Setting fullMessage
      fullMessage.headers = Imap.parseHeader( messageRawBody );
      fullMessage.attachmentParts = findAttachments( attributes.struct );
      fullMessage.uid = attributes.uid;

      console.log("TEMPORARY MESSAGE: ", fullMessage );
      
      var bodyParts = findBodyParts( attributes.struct );

      // At this point, we are missing "text" and "html" in fullMessage.
      // It should be easy to get it

      var partIDs = [];
      if( bodyParts.html ) partIDs.push( { type: 'bodyHtml', partID: bodyParts.html.partID } );
      if( bodyParts.text ) partIDs.push( { type: 'body', partID: bodyParts.text.partID } );

      async.eachSeries(
        partIDs,
        function( partID, cb ){

          console.log("ABOUT TO FETCH PART:");
          fetchMessagePart( imap, fullMessage.uid, partID.partID, function( err, part ){
            if( err ) return cb( err );

            console.log("PART FETCHED");

            fullMessage[ partID.type ] = part.body;
            cb( null );
          })
        },
        function( err ){
          if( err ) return done( err );

          done( null, fullMessage );
        }
      );

    })
  })  
}


  
function deleteUnfinishedMessage( stores, config, messageId ){

  stores.messagesTo.delete( { conditions: { and: [ { field: 'messageId', type: 'is', value: messageId  } ] } }, { multi: true }, function( err ){
    if( err ){
      return logLine( stores, config, null, 1, "Error while deleting elements from messagesTo for incomplete message: " + fullMessage.uid + " from the database: " + err.message );
    }

    stores.messagesAttachments.delete( { conditions: { and: [ { field: 'messageId', type: 'is', value: messageId  } ] } }, { multi: true }, function( err ){
      if( err ){
        return logLine( stores, config, null, 1, "Error while deleting elements from messagesAttachment for incomplete message: " + fullMessage.uid + " from the database: " + err.message );
      }
    });

  })

  
}



exports = module.exports = {


  setRoutes: function( stores, app, getAllTransportConfig, done ){

    getAllTransportConfig( 'email-default', function( err, configArray ){
      if( err ) return cb( null );

      done( null );
    });

  },




  run: function( stores, getAllTransportConfig, done ){

    var inProgress = {};

    //setInterval( function(){

      getAllTransportConfig( 'email-default', function( err, configArray ){
        if( err ) return cb( err );

        console.log("CONFIG ARRAY:", configArray );

        configArray.forEach( function( config ){

          if( inProgress[ config.id ] ) return;

          // Check that all settings are actually on
          if( config.imapLogin == '' ||  config.imapPassword == '' || config.imapServer == '' || config.imapPort == '' ){
            logLine( stores, config, null, 1, "IMAP not enabled as one of the parameters weren't set" );
            return;
          }
  
          // OK, it's officially in progress
          inProgress[ config.id ] = true;
        
          
          /*
          var socket = new require('net').Socket();
          //socket.setKeepAlive( true );
          socket.setTimeout( 5000, function( o ){
            console.log("SOCKET TIMEOUT!" , o);

            socket.imapObject.destroy();
            inProgress[ config.id ] = false;

            logLine( stores, config, null, 1, "Connection timeout" );

            console.log("Given up, as connection timed out" , o);
          });
          
          


          socket.on('data', function( d ){
            console.log("SOCKET HAS DATA", d.toString() );
          });
          socket.on('end', function( ){
            console.log("+++++++++++++++++++++++++++++++++++++++++++++++++++++++EEEEEENNNNNNDDDDDDDD+++++++++++++++++++++++++++++++++++++++++++++++++");
          });
          */


          /*
          var socket = new require('net').Socket();
          socket.setTimeout( 2000, function( o ){
            console.log("SOCKET1 TIMEOUT!" , o);

            socket.imapObject.destroy();
            inProgress[ config.id ] = false;

            //logLine( stores, config, null, 1, "Connection timeout" );

            //console.log("Given up, as connection timed out" , o);
          });

          socket.on('end', function(){
            console.log("SOCKET1 ENDED!");
          });
          socket.on('data', function( d ){
            console.log("SOCKET1 DATA!", d );
          });
          socket.on('timeout', function( err ){
            console.log("SOCKET1 TIMEOUT!", err );
          });
          socket.on('error', function( err ){
            console.log("SOCKET1 ERROR!", err );
          });
          */


          var imap = new Imap({
            user: config.imapLogin,
            password: config.imapPassword,
            host: config.imapServer,
            port: config.imapPort,
            tls: true,
            //socket: socket,
            //keepalive: { interval: 5000, idleInterval: 5000 },
            //tlsOptions: {
            //  socket: socket
            //},
            debug: function( msg ){
              console.log("DEBUG: ", msg)
            },
            connTimeout: 10000,
            authTimeout: 10000,
            socketTimeout: 3000,
          });

          //socket.imapObject = imap;

          imap.once('error', function( err ) {
            inProgress[ config.id ] = false;
            console.log("*********************** ERRORRRRRRRRRRRRRRRRRRR", err, config );
          });

          imap.once('end', function() {
            console.log('Connection ended');
            inProgress[ config.id ] = false;
          });

          imap.once('close', function(){
            console.log("CONNECTION CLOSED" );
            inProgress[ config.id ] = false;
          })

          imap.once('ready', function() {

            console.log("IMAP IS READY");

/*
            imap._sock.setTimeout(3000, function(){
              console.log("SOCKET2 TIMEOUT");
            })
*/

/*
            imap._sock.on('data', function( d ){
              console.log("SOCKET DATA: ", d );
            })

            imap._sock.on('error', function( e ){
              console.log("SOCKET ERROR: ", e );
            })

            imap._sock.on('end', function(){
              console.log("SOCKET END: " );
            })

            imap._sock.on('timeout', function(){
              console.log("SOCKET TIMEOUT: " );
            })
*/

            // Open INBOX in the imap server
            imap.openBox('INBOX', false, function( err, mailbox ){

              if (err){

                logLine( stores, config, null, 1, "Could not open inbox: " + config.imapHost + ":" + config.imapPort );
                // EMIT error with config
                return;    
              } 

              console.log("Inbox is open");


              imap.search([ 'UNSEEN' ], function(err, uids) {
                if( err ){
                  logLine( stores, config, null, 1, "Could not open inbox: " + config.imapHost + ":" + config.imapPort )
                  return;
                }

                console.log("Search returned");

                async.eachSeries(
                  uids,
                  function( uid, uidsIterationCb ){

                    fetchMessageWithBodyParts( imap, uid, { bodies: 'HEADER.FIELDS (FROM TO SUBJECT DATE )', struct: true }, function( err, fullMessage){

                      if( err ){
                        logLine( stores, config, null, 1, "Could not fetch body parts for message: " + err.message );
                        return uidsIterationCb( null );
                      }
                      console.log("FULL MESSAGE IN THE END: ", fullMessage );

                      stores.messages.apiGetQuery( { filters: { foreignId: fullMessage.uid } }, function( err, there ){
                        if( err ){
                          logLine( stores, config, null, 1, "Could not check if message " + fullMessage.uid + " was already in the database: " +  err.message );
                          return uidsIterationCb( null );
                        }
                        if( there.length > 0 ){
                          logLine( stores, config, null, 1, "Message " + fullMessage.uid + " was already in the database, skipping" ); 

                          // Set the message as read
                          imap.setFlags( fullMessage.uid, 'Seen', function( err ){

                            if( err ){ 
                              logLine( stores, config, null, 1, "Error while marking message as read (doing so since it was already in database) " + fullMessageRecord.uid + ": " + err.message ) 

                            }
                          });

                          return uidsIterationCb( null );

                        }

                        stores.messages.apiPost( { 
                          type       : 'email',
                          incoming   : true,
                          subject    : fullMessage.headers.subject[ 0 ],
                          body       : fullMessage.body,
                          bodyHtml   : fullMessage.bodyHtml,
                          from       : fullMessage.headers.from[ 0 ],
                          foreignId  : fullMessage.uid,
                          foreignData: fullMessage.headers,

                        }, function( err, messageRecord ){

                          if( err ){
                            logLine( stores, config, null, 1, "Error adding " + fullMessage.uid + " to the database: " + err.message ); 
                            return uidsIterationCb( null );
                          }

                          stores.messagesTo.apiPost( {
                            messageId: messageRecord.id,
                            to: config.systemEmail,
                            status: 'dontdeliver',
                            failedAttempts: 1
                          }, function( err, messageToRecord ){
                            if( err ){
                              logLine( stores, config, null, 1, "Error adding recipient " + config.systemEmail + " to message " + fullMessage.uid + " to the database: " + err.message );
                              deleteUnfinishedMessage( stores, config, messageRecord.id );
                              return uidsIterationCb( null );
                            }

                            async.eachSeries(

                              fullMessage.attachmentParts,

                              function( attachmentPart, attachmentIterationCb ){
                                stores.messagesAttachments.apiPost( {
                                  messageId: messageRecord.id,
                                  foreignId: attachmentPart.partID,
                                  retrieved: false,
                                  attachmentInfo: attachmentPart
                                }, function( err, partRecord ){
                                  if( err ){
                                    logLine( stores, config, null, 1, "Error adding attachment part data " + attachmentPart.partID + " to message " + fullMessage.uid + " to the database: " + err.message ); 
                                      return attachmentIterationCb( err );
                                  }

                                  attachmentIterationCb( null );

                                })
                              },

                              function( err ){

                                // Something went wrong adding attachment: give up on the message
                                if( err ){
                                  deleteUnfinishedMessage( stores, config, messageRecord.id );
                                  return uidsIterationCb( null );
                                }
                                
                                // Now that _everything_ went according to plan, emit the full message object
                                // (which will include `attachments` and `to` under _children) as a
                                // broadcast
                                stores.messages.apiGet( messageRecord.id, function( err, fullMessageRecord ){

                                  // If the message cannot be fetched, there is a problem --
                                  // abort the current message iteration
                                  if( err ){
                                    logLine( stores, config, null, 1, "Error re-fetching the message " + fullMessage.uid + " to broadast it: " + err.message ); 

                                    deleteUnfinishedMessage( stores, config, messageRecord.id );

                                    // Call the main cycle's cb, so that it goes to the next message
                                    return uidsIterationCb( null );
                                  }

                                  hotplate.hotEvents.emit( 'transportMessageFetched', config, fullMessageRecord, function( err ) { 
                                    if( err ){ 

                                      logLine( stores, config, null, 1, "Error after emitting the transportMessageFetched event for the message " + fullMessageRecord.uid + ": " + err.message ); 

                                      deleteUnfinishedMessage( stores, config, messageRecord.id );

                                        // Call the main cycle's cb, so that it goes to the next message
                                      return uidsIterationCb( null );
                                    }

                                    // All done, we did it! (Looking at it this way, looks like a miracle)
                                    // Go for the next message
                                    console.log("************************** VICTORY:", require('util').inspect( fullMessageRecord, { depth: Infinity } ) );

                                    // Set the message as read
                                    imap.setFlags( fullMessage.uid, 'Seen', function( err ){

                                      if( err ){ 
                                        logLine( stores, config, null, 1, "Error while marking message as read:  " + fullMessageRecord.uid + ": " + err.message ); 

                                        // Call the main cycle's cb, so that it goes to the next message
                                        return uidsIterationCb( null );
                                      }


                                      // All was fine: next message!
                                      uidsIterationCb( null );


                                    });

                                  });

                                });
                           
                              }
                            );
                          // End of async.eachSeries to add records to messagesTo
                          })
                        })
                      });                    
                    });

                  },
                  function( err ){

                    // Err cannot be set here as iterating function will never cb( err )
                    console.log("END OF PROCESSING MESSAGES!" );

                    // Close the imap connection. A side effect is that
                    // inProgress[ config.id ] will be set to false
                    imap.end();
                  }
                );

              });
            });
          });
          imap.connect();

          // Get new email, add them to `messages`, emit a signal with
          // FULL config _plus_ `message` object.

          console.log("CONFIG ITEM: ", config );    


        });
      });



    //}, 60000 );

    // That's it -- interval set, time to go home
    done( null );

  },



  sendMessage: function( stores, messageTo, config, done ){

    console.log("LAYER SENDING: ", messageTo, config );;

    // SMTP server not configured: end of the story
    if( config.smtpServer == '' ){
      logLine( storesRegistry, config, messageTo, 1, "Error: SMTP is not configured" );
      changeMessageStatus( storeRegistry, config, messageTo, true, 'todeliver' );
      done( null );
    }

    var o = {
      host: config.smtpServer,
      port: config.smtpPort,
      secure: true,
      debug: true      
    };

    if( config.smtpLogin ){
      o.auth = {
        user: config.smtpLogin,
        pass: config.smtpPassword,
      };
    }

    // Create an SMTP transporter
    var transporter = nodemailer.createTransport( o );

    var c = transporter.sendMail({
      from: config.systemName + " <" + config.systemEmail + ">",
      //from: config.systemEmail,
      to: messageTo.to,
      subject: messageTo._children.messageId.subject,
      html: messageTo._children.messageId.body,
    }, function( err ){

      // There was an error: log it
      if( err ){
        logLine( storesRegistry, config, messageTo, 1, "Could not send email: [" + err.name + "] " + err.message ? err.message : '' );
        changeMessageStatus( storeRegistry, config, messageTo, true, 'todeliver' );
        return done( null );
      }

      // All good: change the status to delivered, log sending
      logLine( storesRegistry, config, messageTo, 1, "Email delivered successfully!" );
      changeMessageStatus( storeRegistry, config, messageTo, true, 'delivered' );

      return done( null );
    });

    transporter.on( 'log', function( o1, o2 ){
      logLine( storesRegistry, config, messageTo, 1, "[mailer] "+ o1 );
    })

  },
};


// Log a line to messageDeliveryLog, if messageTo is set.
// In whichever case (messageTo set or not), it will emit a
// transportLogError so that other modules can actually
// log the problem as well.
function logLine( stores, config, messageTo, logLevel, logLine ){

  console.log("************* LOGLINE CALLED: ", logLevel, logLine );

  var o = {
  //  messageToId: messageTo.id,
  //  messageId: messageTo.messageId,
    level: logLevel,
    line: logLine,
    config: config
  }
  if( messageTo ){
    o.messageToId = messageTo.id;
    o.messageId = message.id;

    stores.messagesDeliveryLog.apiPost(o, function( err ){

      if( err ){
        console.log("Error while adding record to messagesDeliveryLog: ", err  )
        // TODO: Express' Log if err happened 
      }
      restOfFunction();
    });
  } else {
    restOfFunction();
  }
  
  function restOfFunction(){

    hotplate.hotEvents.emit( 'transportLog', config, messageTo, logLevel, logLine, function( err, results ) { 
      if( err ){ 
        console.log("Error while emitting transportLog ", err  );
        // TODO: Express' Log if err happened 
      }
    });
  }
}

// If `failedAttempt`, and the messageTo.failedAttempt > 5, newMessageStatus is forced to `undeliverable`
function changeMessageStatus( stores, config, messageTo, failedAttempt, newMessageStatus ){

  // For failed attempts or message status updates, the function will need to
  // write over messageTo. NOTE: if failedAttempts > 5, status is forced to 'undeliverable'.
  if( failedAttempt ) messageTo.failedAttempts ++;

  messageTo.status =  messageTo.failedAttempts > 5 ? 'undeliverable' : newMessageStatus;

  stores.messagesTo.dbLayer.update( { conditions: { and: [ { field: 'id', type: 'is', value: messageTo.id  } ] } }, { status: messageTo.status, failedAttempts: messageTo.failedAttempts }, function( err ){

      if( err ){
        logLine( stores, config, messageTo, 1, "Error while updating status to " + messageTo.status );
      }
      return;
  });

}
