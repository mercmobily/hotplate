"use strict";

/*
TODO:
[X] Rewrite lot so that it's two different functions
[X] Add a counter to see if the imap connection can actually be closed
[X] Rewrite logging/status functions as two separate ones, change code that use them
* Rework naming of some variables to be consistent in terms of text/body
* Close connection RANDOMLY too early, and see if errors are shown properly
* Add the messages/messagesTo to the database, checking that the unique ID is not duplicated.
* Emit events so that app can update their shit too, make bookingDojo add messages
* Only when EVERYTHING is OK, mark messages as read on server
* Serialise attachment data onto the database in ad-hoc field
* Allow the system to return a stream rather than the part directly with different function
* Add API interface (stores?) for
  1) IMAP status
  1a) IMAP force fetch 
  2) Fetching an attachment as stream
  3) Storing an attachment locally
  4) Delete attachment
* Check how to download things if imap credentials are gone or changed (probably impossible)
  MAYBE add way to check if download of attachments is still possible (MD5 of config object the same?)

*/

var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , declare = require('simpledeclare')
  , nodemailer = require('nodemailer')

  , inspect = require('util').inspect
  , fs      = require('fs')
  , base64  = require('base64-stream')
  , Imap    = require('imap')
  , async   = require('async')

  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )

;

function show(obj) {
  return requre('util').inspect( obj, { depth: Infinity } );
}

function die(err) {
  console.log('Uh oh: ' + err);
  process.exit(1);
}


// This function will take `struct` as a parameter, and will
// return an object where `text` and/or `html` are possibly
// set based on its contents.
function findText( struct, result ) {

  var result = result || { text: null, html: null };

  for( var i = 0, len = struct.length; i < len; i++ ) {

    // If it's an array, scan that recursively. Pass `result` to it,
    // so that it keeps on enriching the same object
    if( Array.isArray( struct[i] ) ) {
      findText( struct[i], result );

    // If it's a normal element, use it to try and enrich
    // result with `plain` or `html` (if available)
    } else {

      var s = struct[ i ];
      if( s.type.toLowerCase() === 'text' ){
        if( ! result.text && s.subtype.toLowerCase() === 'plain' ){
          result.text = s;
        }
       if( ! result.html && s.subtype.toLowerCase() === 'html' ){
          result.html = s;
        }         
      }
    }

    // Exit early if not all elements have been scanned yet, but result
    // is already complete.
    if( result.text && result.html ) return result;
  }

  return result;
}

// This function will take `struct` as a parameter, and will
// return an object where `text` and/or `html` are possibly
// set based on its contents.
function findAttachments( struct, result ) {

  var result = result || [ ];

  for( var i = 0, len = struct.length; i < len; i++ ) {

    // If it's an array, scan that recursively. Pass `result` to it,
    // so that it keeps on enriching the same object
    if( Array.isArray( struct[i] ) ) {
      findAttachments( struct[i], result );

    // If it's a normal element, use it to try and enrich
    // result with `plain` or `html` (if available)
    } else {

      var s = struct[ i ];
      if( s.type.toLowerCase() === 'application' ){
        result.push( s );
      }
    }
  }

  return result;
}



function fetchMessagePart( imap, uid, partID, done ){

  if( ! partID ) return done( null, null );

  var hadErrInFetch, hadErrInMessage, hadErrInBody;
  var fullPart = { body: '', attributes: null, info: null }
  var f = imap.fetch(uid, { bodies: [ partID ] } );

  // QUESTION #1: Since I am only fetching one part, I assume I will
  // either get the signals (in order) 'message,end' or 'error,end', and never
  // 'message,error,end'. Am I right in my assumption?
  // If that is the case, I can get rid of `hadErrInFetch` since the 'message'
  // event will never actually get called if there was an error  

  // If there is an error fetching, note that it happened and
  // simply call the callback
  f.on('error', function( err) {
    hadErrInFetch = err;
    done( err );
  });

  f.on('message', function( m ) {
 
    if( hadErrInFetch) return;

    // If there is an error, note that it happened and
    // simply call the callback
    m.on( 'error', function( err ){
      hadErrInMessage = err;
      done( err );
    });

    // Get the attributes
    m.on( 'attributes', function( attributes ) {

      if( hadErrInMessage) return;

      fullPart.attributes = attributes;
    });
    

    // Get the body
    m.on('body', function( stream, info) {

      if( hadErrInMessage) return;

      // Assign the part info
      fullPart.info = info;

      stream.on('data', function( d ) {
        fullPart.body += d;
      });
      stream.on('end', function() {
        // QUESTION: Is not having anything here OK? Rationale:
        // No need to have anything here since the fetch's 'end' event
        // will be called after this one, and that's when we return the
        // body as string
      });

      // If there is an error, note that it happened and
      // simply call the callback
      stream.on( 'error', function( err ){
        hadErrInBody = err;
        done( err );
      })

    });
  });


  f.on('end', function() {
  
    // If hadErrIn**** is set, then the callback has already been called.
    if( hadErrInFetch || hadErrInBody || hadErrInMessage ){
      return;
    }

    done( null, fullPart );        

  });

}


function fetchMessageWithTextParts( imap, uid, fetchOptions, done ){

  // Unfinished, initial fullMessage object
  var fullMessage = { uid: null, text: '', html: '', headers: null, attachmentParts: [] };
  var hadErrInFetch, hadErrInBody, hadErrInMessage;
  var attributes, messageBody = '';

  // Just in case. Without this, this function cannot work.
  fetchOptions.struct = true;

  // Run the imap
  var f = imap.fetch(uid, fetchOptions );

  // If there was an error, note it and call the callback with err
  f.once('error', function( err) {
    hadErrInFetch = err;
    done( err );
  });

  // Not really using this for anything since the function will only ever
  // download one message
  f.once( 'end', function(){
  });

  f.once('message', function( msg, seqno) {

    // QUESTION: 
    // This should be useless, as node-imap's fetch() should never emit
    // 'error' and them 'message'. Right?
    if( hadErrInFetch ) return;

    var prefix = '(#' + seqno + ') ';

    // Set hadErrorInMessage in case of errors
    msg.once('error', function( err) {

      hadErrInMessage = true;
      done( err );
    });

    // Assign 'attributes'
    msg.once('attributes', function( _attributes ) {
      if( hadErrInMessage ) return;

      attributes = _attributes;
    });
    
    // Assign 'messageBody'
    msg.on( 'body', function(stream, info) {
      if( hadErrInMessage ) return;

      stream.on( 'error', function( err ){
        hadErrInBody = err;
        cb( err );
      });
      stream.on( 'data', function( d ){
        if( hadErrInBody ) return;
        messageBody += d;
      });

      stream.on( 'end', function(){
        if( hadErrInBody ) return;

        // Not doing anything with this it, using the 'end' signal of the message
        // to continue the flow
      });
    });
    
    msg.once('end', function() {
      if( hadErrInMessage || hadErrInBody ) return;

      // Setting fullMessage
      fullMessage.headers = Imap.parseHeader( messageBody );
      fullMessage.attachmentParts = findAttachments( attributes.struct );
      fullMessage.uid = attributes.uid;

      var textParts = findText( attributes.struct );

      // At this point, we are missing "text" and "html" in fullMessage.
      // It should be easy to get it

      var partIDs = [];
      if( textParts.html ) partIDs.push( { type: 'html', partID: textParts.html.partID } );
      if( textParts.text ) partIDs.push( { type: 'text', partID: textParts.text.partID } );

      async.eachSeries(
        partIDs,
        function( partID, cb ){

          fetchMessagePart( imap, fullMessage.uid, partID.partID, function( err, part ){
            if( err ) return cb( err );

            fullMessage[ partID.type ] = part.body;
            cb( null );
          })
        },
        function( err ){
          if( err ) return done( err );

          done( null, fullMessage );
        }
      );

    })
  })  
}





exports = module.exports = {

  setRoutes: function( stores, app, getAllTransportConfig, done ){

    getAllTransportConfig( 'email-default', function( err, configArray ){
      if( err ) return cb( null );



      done( null );
    });

  },




  run: function( stores, getAllTransportConfig, done ){

    var inProgress = {};

    //setInterval( function(){

      getAllTransportConfig( 'email-default', function( err, configArray ){
        if( err ) return cb( err );

        console.log("CONFIG ARRAY:", configArray );

        configArray.forEach( function( config ){

          if( inProgress[ config.id ] ) return;

          var imap = new Imap({
            user: config.imapLogin,
            password: config.imapPassword,
            host: config.imapServer,
            port: config.imapPort,
            tls: true
          });

          console.log("ATTEMPT:", {
            user: config.imapLogin,
            password: config.imapPassword,
            host: config.imapServer,
            port: config.imapPort,
            tls: true
          });

          imap.once('error', function( err ) {
            console.log("*********************** ERRORRRRRRRRRRRRRRRRRRR", err, config );
          });

          imap.once('end', function() {
            console.log('Connection ended');
          });


          imap.once('ready', function() {

            // Open INBOX in the imap server
            imap.openBox('INBOX', true, function( err, mailbox ){

              if (err){

                logLine( stores, null, 1, "Could not open inbox: " + config.imapHost + ":" + config.imapPort );
                // EMIT error with config
                return;    
              } 

              imap.search([ 'UNSEEN' ], function(err, uids) {
                if( err ){
                  logLine( stores, null, 1, "Could not open inbox: " + config.imapHost + ":" + config.imapPort )
                  return;
                }

                async.eachSeries(
                  uids,
                  function( uid, cb ){

                    fetchMessageWithTextParts( imap, uid, { bodies: 'HEADER.FIELDS (FROM TO SUBJECT DATE )', struct: true }, function( err, fullMessage){

                      if( err ){
                        console.log("fetchMessageWithTextParts returned with error: ", err );
                        // LOG THE ERROR
                      }
                      console.log("FULL MESSAGE IN THE END: ", fullMessage );

                      // TODO: Add message to messages/messagesTo, emit event with full config so that
                      // applications can add info to their own table (worspacesMessages, workspacesMessagesTo)
                      // NOTE: workspaceID is taken from config which is also broadcast

                      cb( null );

                    });

                  },
                  function( err ){

                    // Err cannot be set here
                    console.log("END OF PROCESSING MESSAGES!" );
                    imap.end();

                    // 

                  }
                );

              });
            });
          });
          imap.connect();

          // Get new email, add them to `messages`, emit a signal with
          // FULL config _plus_ `message` object.

          console.log("CONFIG ITEM: ", config );    


        });
      });



    //}, 60000 );

    // That's it -- interval set, time to go home
    done( null );

  },



  sendMessage: function( stores, messageTo, config, done ){

    console.log("LAYER SENDING: ", messageTo, config );;

    // SMTP server not configured: end of the story
    if( config.smtpServer == '' ){
      logLine( storesRegistry, messageTo, 1, "Error: SMTP is not configured" );
      changeMessageStatus( storeRegistry, messageTo, true, 'todeliver' );
      done( null );
    }

    // Create an SMTP transporter
    var transporter = nodemailer.createTransport({
      auth: {
        user: config.smtpLogin,
        pass: config.smtpPassword,
      },
      host: config.smtpServer,
      port: config.smtpPort,
      secure: true,
      debug: true
    });

    var c = transporter.sendMail({
      //from: config.smtpSystemName + " <" + config.smtpSystemEmail + ">",
      from: config.smtpSystemEmail,
      to: messageTo.to,
      subject: messageTo._children.messageId.subject,
      html: messageTo._children.messageId.body,
    }, function( err ){

      // There was an error: log it
      if( err ){
        logLine( storesRegistry, messageTo, 1, "Could not send email: [" + err.name + "] " + err.message ? err.message : '' );
        changeMessageStatus( storeRegistry, messageTo, true, 'todeliver' );
        return done( null );
      }

      // All good: change the status to delivered, log sending
      logLine( storesRegistry, messageTo, 1, "Email delivered successfully!" );
      changeMessageStatus( storeRegistry, messageTo, true, 'delivered' );

      return done( null );
    });

    transporter.on( 'log', function( o1,o2 ){
      console.log("********************************", o1, o2 );
    })

  },
};




// Log a line to messageDeliveryLog, and emits an event
// detailing the current config for which the line was added
// (so that other parts of the program can add, for example, workspace-specific
// records )
function logLine( stores, messageTo, logLevel, logLine ){

  var o = {
  //  messageToId: messageTo.id,
  //  messageId: messageTo.messageId,
    level: logLevel,
    line: logLine
  }
  if( messageTo ){
    o.messageToId = messageTo.id;
    o.messageId = message.id;
  }
  
  stores.messagesDeliveryLog.apiPost(o, function( err ){

    if( err ){
      console.log("ERRORS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", err1, err2 )
      // TODO: Express' Log if err happened 
    }
  
  });
}

// If `failedAttempt`, and the messageTo.failedAttempt > 5, newMessageStatus is forced to `undeliverable`
function changeMessageStatus( stores, messageTo, failedAttempt, newMessageStatus ){

  // For failed attempts or message status updates, the function will need to
  // write over messageTo. NOTE: if failedAttempts > 5, status is forced to 'undeliverable'.
  if( failedAttempt ) messageTo.failedAttempts ++;

  messageTo.status =  messageTo.failedAttempts > 5 ? 'undeliverable' : newMessageStatus;

  stores.messagesTo.dbLayer.update( { conditions: { and: [ { field: 'id', type: 'is', value: messageTo.id  } ] } }, { status: messageTo.status, failedAttempts: messageTo.failedAttempts }, function( err ){

      if( err ){
        console.log("ERRORS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", err1, err2 )
        // TODO: Express' Log if err happened 
      }
      return;
  });

}

/*
  If there is a logLine, log it
  If it is a failedAttempt, or there is a newStatus, update messageTo
   -- If it IS a failedAttempt, and it's >5, force new status to 'undeliverable'
*/

