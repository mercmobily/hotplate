"use strict";

/*
TODO:
[X] Study node-imap module to see how it all works
[X] Write first rough function to fetch messages via IMAP
[X] Patch IMAP module so that it handles socket timeouts properly
[X] Rewrite lot so that it's two different functions
[X] Add a counter to see if the imap connection can actually be closed
[X] Rewrite logging/status functions as two separate ones, change code that use them
[X] Rework naming of some variables to be consistent in terms of text/body

[X] Close/kill connection RANDOMLY too early, and see if errors are shown properly

"LOGGING"
[X] Emit events when logging, decide what to do about events that are not message-specific
[X] Change logLine so that it only adds to messagesDeliveryLog if there is messageTo
[X] Add 'config' to message logging

"REVERSE-ADDING"
[X] Add the messages/messagesTo to the database, checking that the unique ID is not duplicated.
[X] Serialise attachment data onto the database in ad-hoc field
[X] Emit events so that app can update their shit too
[X] Make bookingDojo add messages with those signals
[X] Only when EVERYTHING is OK, mark messages as read on server
[X] Change config name of "smtpSystemEmail" to something more generic
[X] Add function to delete records in messages, messagesTo, messagesAttachments (not logs) if error
[X] If message was already in database, try to mark it as read while giving up on fetch
[X] Place full IMAP fetched headers in foreignData
[X] Chech flow of hell-ish imap-fetching function
[X] Check why socket timeout is triggered regardless of data going through, probably change to keepAlive

[Sunday]
* Fix logging before it's too late, in the WHOLE of hotplate, MongoMixin, and hotCoreTransport
  [X] Finish off hotCoreError, making sure that _all_ JSON rest stores calls it
  [X] Finish off hotCoreStoreLogger
  [X] Finish off description document
  [X] Add log entries here and there in the program, when user logs in, for example
  [X] Move out some of the functions, decide if it's OK to pass stores as arguments
  [X] Allow the system to return a stream rather than the part directly with different function
  [X] Figure out how the API should work -- forward thinking required. Stores? Module calls?

[Wednesday]
  [X] Make sure changeMessageStatus is emitted every time a message changes its status
  [X] Implement attachmentOnStoreSave and attachmentOnStoreDelete (Add MD5 on configID for attachments)
  [X] Make sure attachments are downloaded on the spot
  [X] Do not download large attachments, giving a warning

[Thursday]
  [X] Check individual intervals for IMAP
  [X] Fully reorganise code for hotCoreTransport
  [X] Decide on logLine, does the err parameter make sense? Fully undertand difference bw logLine and debug
  [ ] Full code audit, especially in terms of what to do in case of errors (logging/debug)
  [ ] Test that fetching/sending emails actually works, finish off things, audit code, check comments, etc.

*/

var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , declare = require('simpledeclare')
  , nodemailer = require('nodemailer')
  , DeepObject = require('deepobject')

  , fs      = require('fs')
  , base64  = require('base64-stream')
  , Imap    = require('imap')
  , async   = require('async')
  , debug = require('debug')('hotplate:hotCoreTransport:email-default')

  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
  , hotCoreTransport = require( 'hotCoreTransport')
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )
  , logger = hotCoreServerLogger

;


// These variables are module-wide, as are  used to update the status
// of each configId's polling
// They are objects as there is one element per configId
var pollingInProgress = {};
var lastPolling = {};

// Transport layer functions. These are made available to transport layers
// by hotCoreTransport. Very common, and very handy
var tlf = hotCoreTransport.transportLayerFunctions;
var logLine = tlf.logLine;
var formatError = tlf.formatError;
var changeMessageStatus = tlf.changeMessageStatus;
var deleteUnfinishedMessage = tlf.deleteUnfinishedMessage;


// This is the API, exposed through exports.
// Each transport module needs to implement all of these methods
// even if they are left empty


exports = module.exports = {

  setRoutes: function( stores, app, configArray, done ){
    done( null );
  },

  run: function( stores, configArray, done ){
    done( null );
  },

  sendMessage: function( stores, messageTo, config, done ){
    sendMessage( stores, messageTo, config, done );
  },

  // MUST: emit( 'transportMessageFetched', config, fullMessageRecord ) for every
  // fetched message, so that other parts of the application can update their own tables
  startPolling: function( stores, config, done ){
    poll( stores, config, done );
  },

  getPollingStatus: function( configId, done ){
    done( null, pollingInProgress[ configId ] ? "ONGOING" : "IDLE" ); // OR "NOTIMPLEMENTED"
  },

};


// Function to send an email
// NOTE: an error in sending the email should NOT result in done( err ) as
// at layer-level there might be many reasons why the email wasn't delivered, but
// that shouldn't stop the flow of sending emails (whereas a system error should)

function sendMessage( stores, messageTo, config, done ){

  debug("Layer email-default sending: ", messageTo, config );;

  // SMTP server not configured: end of the story
  if( config.smtpServer == '' ){
    logLine( storesRegistry, config, messageTo, 1, "Error: SMTP is not configured" );
    changeMessageStatus( config, messageTo, true, 'todeliver', function( err ){
      if( err ) return done( err );

      done( null );
    });
    return;
  }

  changeMessageStatus( config, messageTo, true, 'delivering', function( err ){
    if( err ) return done( err );

    var o = {
      host: config.smtpServer,
      port: config.smtpPort,
      secure: true,
      debug: true      
    };

    if( config.smtpLogin ){
      o.auth = {
        user: config.smtpLogin,
        pass: config.smtpPassword,
      };
    }

    // Create an SMTP transporter
    var transporter = nodemailer.createTransport( o );

    var c = transporter.sendMail({
      from: config.systemName + " <" + config.systemEmail + ">",
      //from: config.systemEmail,
      to: messageTo.to,
      subject: messageTo._children.messageId.subject,
      html: messageTo._children.messageId.body,
    }, function( err ){

      // There was an error: log it, but DO NOT done( err) as it shouldn't get
      // propagated up
      if( err ){
        logLine( storesRegistry, config, messageTo, 1, "Could not send email", err );
        changeMessageStatus( config, messageTo, true, 'todeliver', function( err ){
          if( err ) return done( err );
          return done( null );
        });
        return;
      }

      // All good: change the status to delivered, log sending
      logLine( storesRegistry, config, messageTo, 1, "Email delivered successfully!" );
      changeMessageStatus( config, messageTo, true, 'delivered', function( err ){
        if( err ) return done( err );
        return done( null );
      });
    });

    transporter.on( 'log', function( msg ){
      debug( "EMAILER LOG: ", msg );
    })

  });
}


// Functions to deal with incoming messages


// This function will take `struct` as a parameter, and will
// return an object where `text` and/or `html` are possibly
// set based on its contents.
function findBodyParts( struct, result ) {

  var result = result || { text: null, html: null };

  for( var i = 0, len = struct.length; i < len; i++ ) {

    // If it's an array, scan that recursively. Pass `result` to it,
    // so that it keeps on enriching the same object
    if( Array.isArray( struct[i] ) ) {
      findBodyParts( struct[i], result );

    // If it's a normal element, use it to try and enrich
    // result with `plain` or `html` (if available)
    } else {

      var s = struct[ i ];
      if( s.type.toLowerCase() === 'text' ){
        if( ! result.text && s.subtype.toLowerCase() === 'plain' ){
          result.text = s;
        }
       if( ! result.html && s.subtype.toLowerCase() === 'html' ){
          result.html = s;
        }         
      }
    }

    // Exit early if not all elements have been scanned yet, but result
    // is already complete.
    if( result.text && result.html ) return result;
  }

  return result;
}

// This function will take `struct` as a parameter, and will
// return an object where `text` and/or `html` are possibly
// set based on its contents.
function findAttachments( struct, result ) {

  var result = result || [ ];

  for( var i = 0, len = struct.length; i < len; i++ ) {

    // If it's an array, scan that recursively. Pass `result` to it,
    // so that it keeps on enriching the same object
    if( Array.isArray( struct[i] ) ) {
      findAttachments( struct[i], result );

    // If it's a normal element, use it to try and enrich
    // result with `plain` or `html` (if available)
    } else {

      var s = struct[ i ];
      if( s.type.toLowerCase() === 'application' ){
        result.push( s );
      }
    }
  }

  return result;
}



function fetchMessagePart( imap, uid, partID, done ){

  if( ! partID ) return done( null, null );

  var hadErrInMessage, hadErrInBody;
  var fullPart = { body: '', attributes: null, info: null }
  var f = imap.fetch(uid, { bodies: [ partID ] } );

  // Since this function will only ever fetch one part, it will only
  // ever receive either "message" or "error", never body. So,
  // having a 'errInFetch`  (and checking for it) would be pointless
  f.on('error', function( err) {
    done( err );
  });

  f.on('message', function( m ) {
 
    // If there is an error, note that it happened and
    // simply call the callback
    m.on( 'error', function( err ){
      hadErrInMessage = err;
      done( err );
    });

    // Get the attributes
    m.on( 'attributes', function( attributes ) {

      if( hadErrInMessage) return;

      fullPart.attributes = attributes;
    });

    // Get the body
    m.on('body', function( stream, info) {

      if( hadErrInMessage) return;

      // Assign the part info
      fullPart.info = info;

      stream.on('data', function( d ) {
        fullPart.body += d;
      });
    
      // If there is an error, note that it happened and
      // simply call the callback
      stream.on( 'error', function( err ){
        hadErrInBody = err;
        done( err );
      })

    });

    // Not catching m.on( 'end' ) nor stream.on( 'end' ) as will already catch f.on('end')
    // that always comes afterwards
  });

  f.on('end', function() {
  
    // If hadErrIn**** is set, then the callback has already been called.
    if( hadErrInBody || hadErrInMessage ){
      return;
    }

    done( null, fullPart );        

  });

}


function fetchFullMessage( config, imap, uid, fetchOptions, done ){

  // Unfinished, initial fullMessage object
  var fullMessage = { uid: null, body: '', bodyHtml: '', headers: null, attachments: [] };
  var hadErrInBody, hadErrInMessage;
  var attributes, messageRawBody = '';

  // Just in case. Without this, this function cannot work.
  fetchOptions.struct = true;

  // Run the imap
  var f = imap.fetch(uid, fetchOptions );

  // Since this function will only ever fetch one part, it will only
  // ever receive either "message" or "error", never body. So,
  // having a 'errInFetch`  (and checking for it) would be pointless
  f.once('error', function( err) {
    debug("Fetch - ERROR: ", err );
    done( err );
  });

  f.once('message', function( msg, seqno) {

    var prefix = "[" + seqno + "] ";

    debug( prefix + "Fetch - Message");

    // Set hadErrorInMessage in case of errors
    msg.once('error', function( err) {

      debug( prefix + "Message - ERROR: ", err );

      hadErrInMessage = true;
      done( err );
    });

    // Assign 'attributes'
    msg.once('attributes', function( _attributes ) {
      debug( prefix + "Message - attributes: " );

      if( hadErrInMessage ) return;

      attributes = _attributes;
    });
    
    // Assign 'messageRawBody'
    msg.on( 'body', function(stream, info) {

      debug( prefix + "Message - body: " );

      if( hadErrInMessage ) return;

      stream.on( 'error', function( err ){
        debug( prefix + "Stream - ERROR: ", err );

        hadErrInBody = err;
        cb( err );
      });
      stream.on( 'data', function( d ){
        debug( prefix + "Stream - data: " );

        if( hadErrInBody ) return;
        messageRawBody += d;
      });

    });

    // Not catching f.on( 'end' ) nor stream.on( 'end' ) as will already catch msg.on( 'end' )
    // that is absolutely enough
    
    msg.once('end', function() {
      debug( prefix + "Message - end: " );

      if( hadErrInMessage || hadErrInBody ) return;

      // Setting fullMessage
      fullMessage.headers = Imap.parseHeader( messageRawBody );
      fullMessage.uid = attributes.uid;

      debug("TEMPORARY MESSAGE: ", fullMessage );
      
      var bodyParts = findBodyParts( attributes.struct );

      // FETCH BODY PARTS

      // At this point, we are missing "text" and "html" in fullMessage.
      // It should be easy to get it

      var partIDs = [];
      if( bodyParts.html ) partIDs.push( { type: 'bodyHtml', partID: bodyParts.html.partID } );
      if( bodyParts.text ) partIDs.push( { type: 'body', partID: bodyParts.text.partID } );

      async.eachSeries(
        partIDs,
        function( partID, cb ){

          debug("ABOUT TO FETCH PART:");
          fetchMessagePart( imap, fullMessage.uid, partID.partID, function( err, part ){
            if( err ) return cb( err );

            debug("PART FETCHED");

            fullMessage[ partID.type ] = part.body;
            cb( null );
          })
        },
        function( err ){
          if( err ) return done( err );


          // FETCH ATTACHMENT PARTS

          var attachmentPartsInStruct = findAttachments( attributes.struct );
     
          debug("Attachment parts in struct: %o", attachmentPartsInStruct );
          
          async.eachSeries(
            attachmentPartsInStruct,
            function( partInStruct, cb ){

              // Get the filename, Use DeepObject as it's quite deep into partInStruct
              var fileName = DeepObject.get( partInStruct, 'disposition.params.filename');

              // Get the size limit from the configuration
              var sizeLimit = hotplate.config.get('hotCoreTransport.activeTransports.email-default.attachmentSizeLimit');
                              

              debug("sizeLimit is: ", sizeLimit );
;
              debug("Comparing: %d && %d > %d", sizeLimit, partInStruct.size, sizeLimit );

              // If it's too big, do not download it
              if( sizeLimit && partInStruct.size > sizeLimit ){
                logLine( config, null, 1, "Attachment " + fileName + " wasn't fetched as it was too big --  " + partInStruct.size + " bytes against a " + sizeLimit + "limit" );

                // Make up the attachment object
                var p = {
                  id: partInStruct.partID,
                  mimeType: partInStruct.type+ '/' + partInStruct.subtype,
                  retrieved: false,
                  size: partInStruct.size,
                };
                if( fileName ) p.fileName = fileName;
                if( partInStruct.id ) p.embeddedId = partInStruct.id;

                // Add the object to the attachment array
                fullMessage.attachments.push( p );

                return cb( null );
              }

              debug("ABOUT TO FETCH ATTACHMENT PART %o:", partInStruct);
              fetchMessagePart( imap, fullMessage.uid, partInStruct.partID, function( err, downloadedPart ){
                if( err ) return cb( err );
               
                downloadedPart.body = downloadedPart.body.substr( 0, 400 );
                debug("ATTACHMENT PART FETCHED:", downloadedPart );

                // Make up the attachment object
                var p = {
                  id: partInStruct.partID,
                  data: downloadedPart.body,
                  mimeType: partInStruct.type+ '/' + partInStruct.subtype,
                  size: partInStruct.size,
                  retrieved: true,
                };
                if( fileName ) p.fileName = fileName;
                if( partInStruct.id ) p.embeddedId = partInStruct.id;

                // Add the object to the attachment array
                fullMessage.attachments.push( p );
                cb( null );
              })
            },
            function( err ){
              if( err ) return done( err );

              done( null, fullMessage );
            }
          );

        }
      );

    })
  })  
}



// Polling is always handled, at API-level, for one specific config
function poll( stores, config, done ){

  if( pollingInProgress[ config.id ] ) return;

  if( lastPolling[ config.id ] && ( ( new Date() ) - lastPolling[ config.Id ]  ) / 1000 < config.imapPollInterval ){
    debug("It hasn't been long enough since last poll for %o, not doing it just yet");
    return;
  }

  // Check that all settings are actually on
  if( config.imapLogin == '' ||  config.imapPassword == '' || config.imapServer == '' || config.imapPort == '' ){
    logLine( config, null, 1, "IMAP not enabled as one of the parameters weren't set" );
    return;
  }

  // OK, it's officially in progress
  pollingInProgress[ config.id ] = true;

  var imap = new Imap({
    user: config.imapLogin,
    password: config.imapPassword,
    host: config.imapServer,
    port: config.imapPort,
    tls: true,
    debug: function( msg ){
      debug( msg )
    },
    connTimeout: 10000,
    authTimeout: 10000,
    socketTimeout: 3000,
  });


  imap.once('error', function( err ) {
    pollingInProgress[ config.id ] = false;
    debug("IMAP error: ", err, config );
  });

  imap.once('end', function() {
    debug('Connection ended');
    pollingInProgress[ config.id ] = false;
  });

  imap.once('close', function(){
    debug("Connection closed" );
    pollingInProgress[ config.id ] = false;
  })

  imap.once('ready', function() {

    debug("IMAP is ready");

    // Open INBOX in the imap server
    imap.openBox('INBOX', false, function( err, mailbox ){

      if (err){

        logLine( config, null, 1, "Could not open inbox: " + config.imapHost + ":" + config.imapPort, err );
        // EMIT error with config
        return;    
      } 

      debug("Inbox is open");


      imap.search([ 'UNSEEN' ], function(err, uids) {
        if( err ){
          logLine( config, null, 1, "Could not search inbox: " + config.imapHost + ":" + config.imapPort, err );
          return;
        }

        debug("Search returned");

        async.eachSeries(
          uids,
          function( uid, uidsIterationCb ){

            fetchFullMessage( config, imap, uid, { bodies: 'HEADER.FIELDS (FROM TO SUBJECT DATE )', struct: true }, function( err, fullMessage){

              if( err ){
                logLine( config, null, 1, "Could not fetch body parts for message " + uid, err );
                return uidsIterationCb( null );
              }
              debug("FULL MESSAGE: ", fullMessage );

              stores.messages.apiGetQuery( { filters: { foreignId: fullMessage.uid } }, function( err, there ){
                if( err ){
                  logLine( config, null, 3, "Could not check if message " + fullMessage.uid + " was already in the database.", err );
                  return uidsIterationCb( null );
                }
                if( there.length > 0 ){
                  logLine( config, null, 1, "Message " + fullMessage.uid + " was already in the database, skipping" ); 

                  // Set the message as read
                  imap.setFlags( fullMessage.uid, 'Seen', function( err ){

                    if( err ){ 
                      logLine( config, null, 1, "Error while marking message as read (doing so since it was already in database) " + fullMessageRecord.uid, err ) 

                    }
                  });

                  return uidsIterationCb( null );

                }

                stores.messages.apiPost( { 
                  type       : 'email',
                  incoming   : true,
                  subject    : fullMessage.headers.subject[ 0 ],
                  body       : fullMessage.body,
                  bodyHtml   : fullMessage.bodyHtml,
                  from       : fullMessage.headers.from[ 0 ],
                  foreignId  : fullMessage.uid,
                  foreignData: fullMessage.headers,

                }, function( err, messageRecord ){

                  if( err ){
                    logLine( config, null, 3, "Error storing message " + fullMessage.uid, err ); 
                    return uidsIterationCb( null );
                  }

                  stores.messagesTo.apiPost( {
                    messageId: messageRecord.id,
                    to: config.systemEmail,
                    status: 'dontdeliver',
                    failedAttempts: 1
                  }, function( err, messageToRecord ){
                    if( err ){
                      logLine( config, null, 3, "Error attaching recipient " + config.systemEmail + " to message " + fullMessage.uid, err );
                      deleteUnfinishedMessage( config, messageRecord.id );
                      return uidsIterationCb( null );
                    }

                    async.eachSeries(

                      fullMessage.attachments,

                      function( attachment, attachmentIterationCb ){
                        debug("Attachment: %o", attachment );

                        var a = {
                          messageId: messageRecord.id,
                          foreignId: attachment.id,
                          size: attachment.size,
                          mimeType: attachment.mimeType,
                          retrieved: attachment.retrieved,
                          attachmentData: attachment.data
                        };
                        if( attachment.fileName ) a.fileName = attachment.fileName;
                        if( attachment.embeddedId ) a.embeddedId = attachment.embeddedId;

                        debug("About to add record to db: %o", a );

                        stores.messagesAttachments.apiPost(a, function( err, partRecord ){
                          if( err ){
                            logLine( config, null, 3, "Error attaching attachment " + attachmentPart.partID + " to message " + fullMessage.uid, err ); 
                              return attachmentIterationCb( err );
                          }

                          attachmentIterationCb( null );

                        })
                      },

                      function( err ){

                        // Something went wrong adding attachment: give up on the message
                        if( err ){
                          deleteUnfinishedMessage( config, messageRecord.id );
                          return uidsIterationCb( null );
                        }
                        
                        // Now that _everything_ went according to plan, emit the full message object
                        // (which will include `attachments` and `to` under _children) as a
                        // broadcast
                        stores.messages.apiGet( messageRecord.id, function( err, fullMessageRecord ){

                          // If the message cannot be fetched, there is a problem --
                          // abort the current message iteration
                          if( err ){
                            logLine( config, null, 3, "Error re-reading the message once sent: " + fullMessage.uid + " to broadast it", err ); 

                            deleteUnfinishedMessage( config, messageRecord.id );

                            // Call the main cycle's cb, so that it goes to the next message
                            return uidsIterationCb( null );
                          }

                          hotplate.hotEvents.emit( 'transportMessageFetched', config, fullMessageRecord, function( err ) { 
                            if( err ){ 

                              logLine( config, null, 3, "Error after message " + fullMessage.uid + "processed", err ); 

                              deleteUnfinishedMessage( config, messageRecord.id );

                                // Call the main cycle's cb, so that it goes to the next message
                              return uidsIterationCb( null );
                            }

                            // All done, we did it! (Looking at it this way, looks like a miracle)
                            // Go for the next message
                            debug("************************** VICTORY: %o", fullMessageRecord );

                            // Set the message as read
                            imap.setFlags( fullMessage.uid, 'Seen', function( err ){

                              if( err ){ 
                                logLine( config, null, 1, "Error while marking message as read:  " + fullMessageRecord.uid, err ); 

                                // Call the main cycle's cb, so that it goes to the next message
                                return uidsIterationCb( null );
                              }


                              // All was fine: next message!
                              uidsIterationCb( null );


                            });

                          });

                        });
                   
                      }
                    );
                  // End of async.eachSeries to add records to messagesTo
                  })
                })
              });                    
            });

          },
          function( err ){

            // Err cannot be set here as iterating function will never cb( err )
            debug("END OF PROCESSING MESSAGES!" );

            // Close the imap connection. A side effect is that
            // pollingInProgress[ config.id ] will be set to false
            imap.end();
          }
        );

      });
    });
  });
  imap.connect();
}