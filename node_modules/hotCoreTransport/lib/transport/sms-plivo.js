"use strict";

/*
TODO:

Hotplate's end:

X Configure router so that incoming requests work for testing
X Get an example text and print req
X Check request signature, signature code (do not use Plivo's module, copy code)
X - If signature is wrong, log level 3 and exit
X Add email to database
X Emit signal about message received
X Fix huge config mistake: config entry needs to match, first one is not good enough
* Add URL for message status update (add URL to sms request)
* MAYBE make 2 URLs configurable via GUI (check first)
* That's it!

BookingDojo's end:

FIRST:
* Lookup phone number in PhoneNumbers
* If exclusive for workspace:
  - wsArray[ wid ] = true;
* If shared:
  - wsArray[ wid ] = true for every workspace that sent a message in the last week
  - if Object.keys( wsArray) > 1 log level 3 with warning to admin
THEN:
* For each wsArray:
    - add message to workspacesMessages
    - run assignContactsToWorkspaceMessage()


*/

var dummy
  , path = require('path')
  , hotplate = require('hotplate')
  , declare = require('simpledeclare')
  , request = require('request')
  , DeepObject = require('deepobject')
  , e = require( 'allhttperrors' )

  , fs      = require('fs')
  , base64  = require('base64-stream')
  , Imap    = require('imap')
  , async   = require('async')
  , debug = require('debug')('hotplate:hotCoreTransport:sms-plivo')

  , SimpleDbLayer = require( 'simpledblayer' )
  , SimpleSchema = require( 'simpleschema' )
  , JsonRestStores = require( 'jsonreststores' )

  , hotCoreJsonRestStores = require( 'hotCoreJsonRestStores' )
  , hotCoreStoreRegistry = require( 'hotCoreStoreRegistry' )
  , hotCoreTransport = require( 'hotCoreTransport')
  , hotCoreServerLogger = require( 'hotCoreServerLogger' )
  , crypto = require('crypto')
  , logger = hotCoreServerLogger
;


// These variables are module-wide, as are  used to update the status
// of each configId's polling
// They are objects as there is one element per configId
var pollingInProgress = {};
var lastPolling = {};

// Transport layer functions. These are made available to transport layers
// by hotCoreTransport. Very common, and very handy
var tlf = hotCoreTransport.transportLayerFunctions;
var logLine = tlf.logLine;
var formatError = tlf.formatError;
var changeMessageStatus = tlf.changeMessageStatus;
var deleteUnfinishedMessage = tlf.deleteUnfinishedMessage;

// This is the API, exposed through exports.
// Each transport module needs to implement all of these methods
// even if they are left empty

exports = module.exports = {

  setRoutes: function( stores, app, configArray, done ){


    // Set route for incoming SMSes
    app.all('/app/incomingsms/plivo', function( req, res, next ){

      var body = req.body;

      var host = hotplate.config.get( 'hotCoreTransport.activeTransports.sms-plivo.signatureHost', null ) || req.headers.host;
      var data, url;

      // Prepare the data and the url -- they will depend on the method
      if( req.method === 'GET' ){
        var u = require( 'url').parse( req.url, true );
        data = u.query;
        url = req.protocol + '://' + host + u.pathname;
      } else if( req.method === 'POST' ) {
        url = req.protocol + '://' + host + req.url;
        var data = req.body;
      } else {
        next( new Error("Protocol not supported"));
      }


      // Gets the plivo configuration matching that number
      var config = null, item;
      for( var i = 0, l = configArray.length; i < l; i ++){
        item = configArray[ i ];
        if( body.To == item.fullNumber ){
          config = item;
          break;
        }
      }
      if( ! config ){
        return next( new Error( "Plivo message received, but no plivo configuration set"));  
      }

      var token = config.token;

      // At this point, 'url' and 'data' and 'token' are all set

      // Create the signature, and check it against the token passed
      var toSign = url;
      Object.keys( data ).sort().forEach( function( key ) {
        toSign += key + data[ key ];
      });
      var signature = crypto.createHmac('sha1', token ).update( toSign ).digest('base64');
      if( signature !== req.headers[ 'x-plivo-signature' ] ){
        return next( new e.UnauthorizedError() );
      }

      stores.messages.apiPost( { 
        type       : 'sms',
        incoming   : true,
        bodyText   : body.Text,
        from       : body.From,
        foreignId  : body.MessageUUID,
        foreignData: {
          TotalRate: body.TotalRate,
          To: body.To,
          Units: body.Units,
        },
      }, function( err, messageRecord ){
        if( err ){
          logLine( config, null, 3, "Error storing message " + fullMessage.foreignId, err ); 
          return next( err );
        }
          
        stores.messagesTo.apiPost( {
          messageId: messageRecord.id,
          to: body.To,
          status: 'dontdeliver',
          failedAttempts: 1
        }, function( err, messageToRecord ){

          // If there was DB error, clean up and return error
          if( err ){
            logLine( config, null, 3, "Error attaching recipient " + body.To + " to message " + fullMessage.foreignId, err );
            deleteUnfinishedMessage( config, messageRecord.id );
            return next( err );;
          }

          // Now that _everything_ went according to plan, emit the full message object
          // (which will include `attachments` and `to` under _children) as a
          // broadcast
          stores.messages.apiGet( messageRecord.id, function( err, fullMessageRecord ){

            // If the message cannot be fetched, there is a problem --
            // abort the current message iteration
            if( err ){
              logLine( config, null, 3, "Error re-reading the message once sent: " + fullMessage.foreignId + " to broadast it", err ); 

              deleteUnfinishedMessage( config, messageRecord.id );

              // Call the main cycle's cb, so that it goes to the next message
              return next( err );
            }

            hotplate.hotEvents.emit( 'transportMessageFetched', config, fullMessageRecord, function( err ) { 
              if( err ){ 

                logLine( config, null, 3, "Error after message " + fullMessage.foreignId + "processed", err ); 

                deleteUnfinishedMessage( config, messageRecord.id );

                return next( err );
              }

              // It actually all worked

              debug("TOSIGN:", toSign );
              debug("URL: ", url );
              debug("DATA:", data );
              debug("TOKEN:", token );

              debug("EXPECTING: ", signature );
              debug("RECEIVED: ", req.headers[ 'x-plivo-signature' ] );

              res.send( 200, '');
            });
          });
        });
      })
    })

    // End of setRoutes
    done( null );
  },

  run: function( stores, configArray, done ){
    done( null );
  },

  // No callback: will initiate sending and log events with logLine
  sendMessage: function( stores, messageTo, config ){
    _sendMessage( stores, messageTo, config );
  },

  // No callback: will initiate sending and log events with logLine
  // MUST: emit( 'transportMessageFetched', config, fullMessageRecord ) for every
  // fetched message, so that other parts of the application can update their own tables
  startPolling: function( stores, config ){
    _startPolling( stores, config );
  },

  getPollingStatus: function( configId, done ){
    _getPollingStatus( configId, done );
  },

};


function _getPollingStatus( configId, done ){
  done( null, pollingInProgress[ configId ] ? "ONGOING" : "IDLE" ); // OR "NOTIMPLEMENTED"
}

// Function to send an SMS
function _sendMessage( stores, messageTo, config ){

  debug("Layer sms-plivo sending: ", messageTo, config );;

  // Plivo account not configured: end of the story
  if( config.account == '' ){
    logLine( storesRegistry, config, messageTo, 1, "Plivo account (account) not configured" );
    changeMessageStatus( config, messageTo, true, 'todeliver', function(){} );
    return;
  }
  if( config.token == '' ){
    logLine( storesRegistry, config, messageTo, 1, "Plivo account (token) not configured" );
    changeMessageStatus( config, messageTo, true, 'todeliver', function(){} );
    return;
  }


  changeMessageStatus( config, messageTo, true, 'delivering', function( err ){
    if( err ) return;


    var message = messageTo._children.messageId;
    var sms = {
      src: config.fullNumber,
      dst: messageTo.to,
      text: message.bodyHtml 
    };

    debug("MAKING REQUEST: ", { url:'https://api.plivo.com/v1/Account/' +  config.account + '/Message/', qs: sms });
    debug("REQUEST PARAMETERS:",
      {
        'auth': {
          'user': config.account,
          'pass': config.token,
          'sendImmediately': true
        },
      }
    );

    request.post(
      {
        uri:'https://api.plivo.com/v1/Account/' +  config.account + '/Message/',
        json: sms,
        'auth': {
          'user': config.account,
          'pass': config.token,
          'sendImmediately': true
        }
      },
        
      function( err, response, body ){

        // There was an error: log it, but DO NOT done( err) as it shouldn't get
        // propagated up
        if( err ){
          logLine( config, messageTo, 1, "Could not send SMS", err );
          changeMessageStatus( config, messageTo, true, 'todeliver', function(){} );
          return;
        }

        // All good: change the status to delivered, log sending
        logLine( config, messageTo, 1, "SMS delivered successfully!" );
        changeMessageStatus( config, messageTo, true, 'delivered', function(){} );
      }
    );
    
  });
}


// Functions to deal with incoming messages


// Polling is used to check for messages that have been undeliverable for a very long time,
// to see if they have been delivered and we just don't know about it
function _startPolling( stores, config, force ){


  return;

  if( force ){
    logLine( config, null, 1, "Polling happening regardless of configured timeout" );
  }

  if( pollingInProgress[ config.id ] ){
    logLine( config, null, 1, "Polling requested while another one still in progress, aborting request" );
    return;
  }

  if( !force && lastPolling[ config.id ] && ( ( new Date() ) - lastPolling[ config.Id ]  ) / 1000 < config.imapPollInterval ){
    debug("It hasn't been long enough since last poll for %o, not doing it just yet");
    return;
  }


  // Check that all settings are actually on
  if( config.imapLogin == '' ||  config.imapPassword == '' || config.imapServer == '' || config.imapPort == '' ){
    logLine( config, null, 1, "IMAP not enabled as one of the parameters weren't set" );
    return;
  }

  // OK, it's officially in progress
  pollingInProgress[ config.id ] = true;
  lastPolling[ config.id ] = new Date();


  // Create the imap object
  var imap = new Imap({
    user: config.imapLogin,
    password: config.imapPassword,
    host: config.imapServer,
    port: config.imapPort,
    tls: true,
    debug: function( msg ){
      debug( "IMAP DEBUGGING MESSAGE: " + msg )
    },
    connTimeout: 30000,
    authTimeout: 30000,
    socketTimeout: 30000,
  });


  imap.once('error', function( err ) {
    //logLine( config, null, 2, "IMAP error", err );
    pollingInProgress[ config.id ] = false;
    debug("IMAP error: ", err, config );
  });

  imap.once('end', function() {
    //logLine( config, null, 1, "IMAP connection ended" );
    pollingInProgress[ config.id ] = false;
    debug('Connection ended');
  });

  imap.once('close', function(){
    //logLine( config, null, 1, "IMAP connection closed" );
    pollingInProgress[ config.id ] = false;
    debug("Connection closed" );
  })

  imap.once('ready', function() {

    //logLine( config, null, 1, "IMAP connection established" );

    debug("IMAP is ready");

    // Open INBOX in the imap server
    imap.openBox('INBOX', false, function( err, mailbox ){

      if (err){
        logLine( config, null, 1, "Could not open inbox: " + config.imapHost + ":" + config.imapPort, err );
        return;    
      } 

      debug("Inbox is open");

      imap.search([ 'UNSEEN' ], function(err, uids) {
        if( err ){
          logLine( config, null, 1, "Could not search inbox: " + config.imapHost + ":" + config.imapPort, err );
          return;
        }

        debug("Search returned");

        async.eachSeries(
          uids,
          function( uid, uidsIterationCb ){

            fetchFullMessage( config, imap, uid, { bodies: 'HEADER.FIELDS (FROM TO SUBJECT DATE )', struct: true }, function( err, fullMessage){

              if( err ){
                logLine( config, null, 1, "Could not fetch body parts for message " + uid, err );
                return uidsIterationCb( null );
              }
              debug("FULL MESSAGE: ", fullMessage );

              stores.messages.apiGetQuery( { filters: { foreignId: fullMessage.uid } }, function( err, there ){
                if( err ){
                  logLine( config, null, 3, "Could not check if message " + fullMessage.uid + " was already in the database.", err );
                  return uidsIterationCb( null );
                }
                if( there.length > 0 ){
                  logLine( config, null, 1, "Message " + fullMessage.uid + " was already in the database, skipping" ); 

                  // Set the message as read
                  imap.setFlags( fullMessage.uid, 'Seen', function( err ){

                    if( err ){ 
                      logLine( config, null, 1, "Error while marking message as read (doing so since it was already in database) " + fullMessageRecord.uid, err ) 

                    }
                  });

                  return uidsIterationCb( null );

                }

                stores.messages.apiPost( { 
                  type       : 'email',
                  incoming   : true,
                  subject    : fullMessage.headers.subject[ 0 ],
                  body       : fullMessage.body,
                  bodyHtml   : fullMessage.bodyHtml,
                  from       : fullMessage.headers.from[ 0 ],
                  foreignId  : fullMessage.uid,
                  foreignData: fullMessage.headers,

                }, function( err, messageRecord ){

                  if( err ){
                    logLine( config, null, 3, "Error storing message " + fullMessage.uid, err ); 
                    return uidsIterationCb( null );
                  }

                  stores.messagesTo.apiPost( {
                    messageId: messageRecord.id,
                    to: config.systemEmail,
                    status: 'dontdeliver',
                    failedAttempts: 1
                  }, function( err, messageToRecord ){
                    if( err ){
                      logLine( config, null, 3, "Error attaching recipient " + config.systemEmail + " to message " + fullMessage.uid, err );
                      deleteUnfinishedMessage( config, messageRecord.id );
                      return uidsIterationCb( null );
                    }

                    async.eachSeries(

                      fullMessage.attachments,

                      function( attachment, attachmentIterationCb ){
                        debug("Attachment: %o", attachment );

                        var a = {
                          messageId: messageRecord.id,
                          foreignId: attachment.id,
                          size: attachment.size,
                          mimeType: attachment.mimeType,
                          retrieved: attachment.retrieved,
                          attachmentData: attachment.data
                        };
                        if( attachment.fileName ) a.fileName = attachment.fileName;
                        if( attachment.embeddedId ) a.embeddedId = attachment.embeddedId;

                        debug("About to add record to db: %o", a );

                        stores.messagesAttachments.apiPost(a, function( err, partRecord ){
                          if( err ){
                            logLine( config, null, 3, "Error attaching attachment " + attachmentPart.partID + " to message " + fullMessage.uid, err ); 
                              return attachmentIterationCb( err );
                          }

                          attachmentIterationCb( null );

                        })
                      },

                      function( err ){

                        // Something went wrong adding attachment: give up on the message
                        if( err ){
                          deleteUnfinishedMessage( config, messageRecord.id );
                          return uidsIterationCb( null );
                        }
                        
                        // Now that _everything_ went according to plan, emit the full message object
                        // (which will include `attachments` and `to` under _children) as a
                        // broadcast
                        stores.messages.apiGet( messageRecord.id, function( err, fullMessageRecord ){

                          // If the message cannot be fetched, there is a problem --
                          // abort the current message iteration
                          if( err ){
                            logLine( config, null, 3, "Error re-reading the message once sent: " + fullMessage.uid + " to broadast it", err ); 

                            deleteUnfinishedMessage( config, messageRecord.id );

                            // Call the main cycle's cb, so that it goes to the next message
                            return uidsIterationCb( null );
                          }

                          hotplate.hotEvents.emit( 'transportMessageFetched', config, fullMessageRecord, function( err ) { 
                            if( err ){ 

                              logLine( config, null, 3, "Error after message " + fullMessage.uid + "processed", err ); 

                              deleteUnfinishedMessage( config, messageRecord.id );

                                // Call the main cycle's cb, so that it goes to the next message
                              return uidsIterationCb( null );
                            }

                            // All done, we did it! (Looking at it this way, looks like a miracle)
                            // Go for the next message
                            debug("VICTORY: %o", fullMessageRecord );

                            // Set the message as read
                            imap.setFlags( fullMessage.uid, 'Seen', function( err ){

                              if( err ){ 
                                logLine( config, null, 1, "Error while marking message as read:  " + fullMessageRecord.uid, err ); 

                                // Call the main cycle's cb, so that it goes to the next message
                                return uidsIterationCb( null );
                              }


                              // All was fine: next message!
                              uidsIterationCb( null );


                            });

                          });

                        });
                   
                      }
                    );
                  // End of async.eachSeries to add records to messagesTo
                  })
                })
              });                    
            });

          },
          function( err ){

            // Err cannot be set here as iterating function will never cb( err )
            debug("END OF PROCESSING MESSAGES!" );

            // Close the imap connection. A side effect is that
            // pollingInProgress[ config.id ] will be set to false
            imap.end();
          }
        );

      });
    });
  });
  imap.connect();
}
