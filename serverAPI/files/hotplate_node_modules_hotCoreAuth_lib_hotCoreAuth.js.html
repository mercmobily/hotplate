<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Hotplate API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
     <link rel="stylesheet" href="/global/header.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
 
      <!-- HEADER -->
      <div id="header_wrap" class="outer">
  
          <div class="main_menu">
               <span><a href="/">Home</a></span>
               <span><a href="/guide.html">Guide</a></span>
               <span><a href="/serverAPI/index.html">Server API</a></span>
               <span><a href="/clientAPI/index.html">Client API</a></span>
          </div>
  
          <header class="inner">
            <a id="forkme_banner" href="https://github.com/mercmobily/hotplate">View on GitHub</a>
  
              
            <h1 id="project_title">Hotplate server API</h1>
            <h2 id="project_tagline">Framework to create multi-homed SaaS with NodeJs, Express</h2>
  
              <section id="downloads">
 
                <a class="zip_download_link" href="https://github.com/mercmobily/hotplate/zipball/master">Download this project as a .zip file</a>
                <a class="tar_download_link" href="https://github.com/mercmobily/hotplate/tarball/master">Download this project as a tar.gz file</a>
              </section>
          </header>
      </div>



<div id="doc">

    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1><a href="../index.html">Hotplate&#x27;s API: hotplate/node_modules/hotCoreAuth/lib/hotCoreAuth.js</a></h1>
            <!--<h1><a href="../index.html"><img src="../assets/css/logo.png" width="117" height="52">Hotplate&#x27;s API: hotplate/node_modules/hotCoreAuth/lib/hotCoreAuth.js</a></h1> -->
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.1</em>
        </div>
    </div>

    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../modules/hotCoreAuth.html">hotCoreAuth</a>
                            </li>
                            <li><a href="../modules/hotCoreClientFiles.html">hotCoreClientFiles</a>
                            </li>
                            <li><a href="../modules/hotCoreMultiHome.html">hotCoreMultiHome</a>
                            </li>
                            <li><a href="../modules/hotCoreTransport.html">hotCoreTransport</a>
                            </li>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/hotCoreAuth.html">hotCoreAuth</a></li>
                            <li><a href="../classes/hotCoreAuth.facebook.html">hotCoreAuth.facebook</a></li>
                            <li><a href="../classes/hotCoreClientFiles.html">hotCoreClientFiles</a></li>
                            <li><a href="../classes/hotCoreMultiHome.html">hotCoreMultiHome</a></li>
                            <li><a href="../classes/hotCoreTransport.html">hotCoreTransport</a></li>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div id="fileTree" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Files</h2>
                </div>
                <div class="bd">
                    <ul><li>hotplate/<ul><li>node_modules/<ul><li>hotCoreAuth/<ul><li>lib/<ul><li>auth/<ul><li><a href="../files/hotplate_node_modules_hotCoreAuth_lib_auth_facebook.js.html">facebook.js</a></li></ul></li><li><a href="../files/hotplate_node_modules_hotCoreAuth_lib_hotCoreAuth.js.html">hotCoreAuth.js</a></li></ul></li></ul></li><li>hotCoreClientFiles/<ul><li>lib/<ul><li><a href="../files/hotplate_node_modules_hotCoreClientFiles_lib_hotCoreClientFiles.js.html">hotCoreClientFiles.js</a></li></ul></li></ul></li><li>hotCoreMultiHome/<ul><li>lib/<ul><li><a href="../files/hotplate_node_modules_hotCoreMultiHome_lib_hotCoreMultiHome.js.html">hotCoreMultiHome.js</a></li></ul></li></ul></li><li>hotCorePage/<ul><li>lib/<ul><li><a href="../files/hotplate_node_modules_hotCorePage_lib_Vars.js.html">Vars.js</a></li></ul></li></ul></li><li>hotCoreTransport/<ul><li>lib/<ul><li><a href="../files/hotplate_node_modules_hotCoreTransport_lib_hotCoreTransport.js.html">hotCoreTransport.js</a></li></ul></li></ul></li></ul></li></ul></li></ul>
                </div>
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>hotplate/node_modules/hotCoreAuth/lib/hotCoreAuth.js</h4>

<pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**

TODO:

* [ ] Stores provided, with explanation of each
* [ ] Data management for each authentication system
* [ ] Defaults and configuration

Provides authentication abilities to Hotplate.

This module provides authentication abilities to your application by:

* Defining authentication stores to be used in your app
* Creating authentication routes to handle authentication using Passport

# The basics

Authentication is based on Passport, and it&#x27;s the most complex part of Hotplate.
There are five actions connected to authentication:

* signin -- to actually login using existing credentials
* register -- to register as a new user
* recover -- to reset credentials
* manager -- to manage credentials
* resume -- to resume an existing session if authentication is expired

There are currently two implemented strategies (although it&#x27;s trivial to create more):

* &#x60;local&#x60; -- using simply a combination of login and password
* &#x60;facebook&#x60; -- using Facebook&#x27;s authentication scheme

In hotCoreAuth, the operation that is about to be performed is defined by the pair _strategy-action_. For example, &#x60;local-signin&#x60;, or &#x60;facebook-recover&#x60;, etc.

_NOTE: &#x60;hotCoreAuth&#x60; uses passport for every authentication strategy, including &#x60;local&#x60;. This is done mainly for consistency: &#x60;local&#x60; is not a two-step authentication, and it wouldn&#x27;t need Passport stricky speaking._

While most of other authentication systems are based on username/password, and then allow you to associate other authentication methods to those username/password pairs, in hotCoreAuth _each login method is the same_. You might decide to sign up with your Facebook profile, and never bother with setting username/password or vice-versa. 

# How hotCoreAuth provides those functionalities

When it&#x27;s run, &#x60;hotCoreAuth&#x60; will scan the configuration object &#x60;hotCoreAuth.strategies&#x60;: each key in the object is a strategy name. For example, for &#x60;local&#x60; &#x60;hotCoreAuth&#x60; will require &#x60;auth/facebook.js&#x60; which in turn will define:

* /auth/signin/facebook
* /auth/register/facebook
* /auth/recover/facebook
* /auth/manager/facebook
* /auth/resume/facebook

Each URL will actually be managed completely by Passport.

## Route definitions in &#x60;hotCoreAuth&#x60;

Understanding exactly what happens with hotCoreAuth is crucial to fully understand Passport. I will explain here how the &#x60;facebook-signin&#x60; operation happens, step by step.

First of all, the configuration object &#x60;hotCoreAuth.strategies&#x60; will need to have &#x60;facebook&#x60; defined as followed:

    facebook: {
      clientID: &#x27;XXXXXXXXXXXX&#x27;,
      clientSecret: &#x27;XXXXXXXXXX&#x27;,
    }

You will need to get those values from Facebook, as they are unique to you (you will actually need to logon to Facebook to obtain them).

&#x60;hotCoreAuth&#x60; will scan &#x60;hotCoreAuth.strategies&#x60;, will find &#x60;facebook&#x60;, and will load &#x60;auth/facebook.js&#x60;.

For &#x60;signin&#x60;, &#x60;facebook.js&#x60; will first define a &#x60;named strategy&#x60; called &#x60;facebook-signin&#x60;, as well as define two routes:

    // STRATEGY DEFINITION
    strategyConfig = hotplate.config.get( &#x27;hotCoreAuth.strategies.facebook&#x27; );  
    passport.use( &#x27;facebook-signin&#x27;, new FacebookStrategy({
      clientID: strategyConfig.clientID,
      clientSecret: strategyConfig.clientSecret,
      callbackURL: callbackURLBase + &quot;/auth/signin/facebook/callback&quot;,
      passReqToCallback: true,
    },

    // This will check if &#x60;profile&#x60; is registered and therefore allowed to login
    function customAuthentication( req, accessToken, refreshToken, profile, done ) {
      // This function will return either
      done( null, false, { message: &quot;Facebook didn&#x27;t return a profile ID, procedure aborted&quot; } );
      // Or:
      done( null, false, { message: &quot;Your Facebook user is not registered&quot; } );
      // or:
      done( null, user, profile  );
    }
    ));

    // FIRST ROUTE
    app.get(&#x27;/auth/signin/facebook&#x27;, passport.authenticate(&#x27;facebook-signin&#x27;));

    // SECOND ROUTE
    app.get(&#x27;/auth/signin/facebook/callback&#x27;, function( req, res, next) {
      passport.authenticate(&#x27;facebook-signin&#x27;,  makeResponder( req, res, next, &#x27;facebook&#x27;, &#x27;signin&#x27;)  )(req, res, next);
    });

Here is what this code does in detail.

With &#x60;passport.use( &#x27;facebook-signin&#x27;, new FacebookStrategy({&#x60;, you are registering a named strategy called &#x60;facebook-signin&#x60; with a bunch of facebook-specific parameters (&#x60;clientID&#x60;, &#x60;clientSecret&#x60;, etc.) and -- most importantly -- a callback used to check whether the &#x60;profile&#x60; returned by Facebook is actually allowed to sign in. This callback will call &#x60;done()&#x60; with the following parameters:

* &#x60;err&#x60; -- as usual in node
* &#x60;user&#x60; -- the user object, or &#x60;false&#x60; if authentication didn&#x27;t work
* &#x60;info&#x60; -- additional information

The next two lines will define two routes.

The route &#x60;/auth/signin/facebook&#x60; is managed completely by Passport, which with &#x60;passport.authenticate(&#x27;facebook-signin&#x27;)&#x60; returns a valid Express route. This route, which will generally be opened in a new window in your client application, will redirect to facebook.com, passing Facebook the &#x60;clientID&#x60;, &#x60;clientSecret&#x60; and &#x60;callbackURL&#x60;. At the end of the process, Facebook will then always redirect the user&#x27;s browser to &#x60;/auth/signin/facebook/callback&#x60; (the callback URL provided earlier to Facebook), which is -- interestingly enough -- another URL managed by Passport.

This is where things get interesting.

Facebook will connect to &#x60;/auth/signin/facebook/callback&#x60;, passing it information relevant to authentication: namely whether it worked or not, and -- if it did work -- the profile information. This is when passport calls the authentication callback, with the parameters &#x60;req, accessToken, refreshToken, profile, done&#x60;.  If &#x60;profile&#x60; isn&#x27;t defined, then it means that Facebook authentication failed. If &#x60;profile&#x60; is set, then authentication in Facebook did work. Keep in mind that a successful Facebook login doesn&#x27;t mean that that Facebook profile is allowed to signin into your application.

The route definition for the second URL can look a little confusing:

    app.get(&#x27;/auth/signin/facebook/callback&#x27;, function( req, res, next) {
      passport.authenticate(&#x27;facebook-signin&#x27;,  makeResponder( req, res, next, &#x27;facebook&#x27;, &#x27;signin&#x27;)  )(req, res, next);
    });

Basically, the whole route is delegated to Passport via &#x60;passport.authenticate()&#x60;, which will:

* Receive the response from Facebook
* Call the custom authentication function passing it &#x60;req, accessToken, refreshToken, profile, done&#x60;. The custom authentication function will call its callback with &#x60;err, user, profile&#x60;
  * The custom authentication function will need to set &#x60;req.session.loggedIn&#x60; and &#x60;req.session.userId&#x60; if that specific Facebook profile is registered
* Run the function _returned by &#x60;makeResponder()&#x60;_, passing it &#x60;err, user, profile&#x60;. Here where &#x60;user&#x60; and &#x60;profile&#x60; are the same values returned by the custom authentication function.

This is probably the trickiest part of hotCoreAuth: here, &#x60;makeResponder( req, res, next, strategy, action )&#x60; is a function generator, which will return a function with the right signature &#x60;(err, user, profile )&#x60;.

Basically, &#x60;makeResponder()&#x60; is the function that will respond to the client, having all of Express&#x27; request/response variables (&#x60;req, res, next&#x60;) and the login information (&#x60;user, profile&#x60;).

# How &#x60;makeResponder()&#x60; works

&#x60;makeResponder()&#x60; is how the authentication system communicates with the client application. Interaction here is tricky, because the type of response will depend on what the client is expecting. For example, if your application allows you to click on a &quot;Facebook&quot; link, which points straight to &#x60;/auth/signin/facebook&#x60;, once the Facebook authentication process is finished you will want to be redirected to either the &quot;login successful&quot; success page, or the &quot;login failed&quot; page. If you open a new browser window for authentication, once the Facebook process is finished, you will probably want to redirect the opening window to the correct URL.
The client can define what &#x60;makeResponder()&#x60; will do by setting a cookie. For example, if after the Facebook authentication (happening in a newly opened window) you want to redirect the opening tab, you should create a cookie called &#x60;facebook-signin&#x60; and assign it &#x27;redirect-opener&#x27;: this will ensure that &#x60;makeResponder()&#x60; will return a page crafted so that the &quot;opener&quot; is redirected, and the tab itself is closed.
The cookies can be: &#x60;XXXX-signin&#x60;, &#x60;XXXX-recover&#x60;, &#x60;XXXX-register&#x60;, &#x60;XXXX-resume&#x60;, &#x60;XXXX-manager&#x60; (where &#x60;XXXX&#x60; can be &#x60;facebook&#x60;, &#x60;local&#x60;, or any other authentication strategy.

Here is a list of possible response types (that is, the cookie value):

* &#x60;content&#x60; -- The function returned by hotCoreAuth.responsePage is run with parameters &#x60;strategyId, action, user, profile&#x60;, and the result is then served to the client.

* &#x60;close&#x60; -- If &#x60;user&#x60; is set, the window is closed immediately. If &#x60;user&#x60; isn&#x27;t set and &#x60;profile&#x60; has a &#x60;message&#x60; attribute, the message is displayed with a Javascript &#x60;alert()&#x60; and the window is then closed. 

* &#x60;ajax&#x60; -- If &#x60;user&#x60; is set, it returns a page with status 200, and -- as contents -- a JSON string like so: &#x60;{ user: user, profile: profile }&#x60;.  If &#x60;user&#x60; isn&#x27;t set, it returns a page with status &#x60;403&#x60; and a JSON string like so: &#x60;{ message: error }&#x60;

* &#x60;redirect-opener&#x60; -- If &#x60;user&#x60; is set, the current window is closed and the opening window (with the main login screen) is redirected to the URL set as &#x60;hotCoreAuth.redirectURLs.success[&#x27;action&#x27;]&#x60;. If &#x60;user&#x60; isn&#x27;t set, &#x60;profile.message&#x60; is displayed as a javascript &#x60;alert()&#x60; and the current window is closed

* &#x60;redirect&#x60; -- If &#x60;user&#x60; is set, the current window redirected to the URL set as &#x60;hotCoreAuth.redirectURLs.success[&#x27;action&#x27;]&#x60;. If &#x60;user&#x60; isn&#x27;t set, &#x60;req.session.messages&#x60; is pushed &#x60;{ type: &#x27;error&#x27;, message: profile.message }&#x60; and  the window is redirected to &#x60;hotCoreAuth.redirectURLs.fail[&#x27;action&#x27;]&#x60;. Note that the new page will have access to the message via the session.

The default action is &#x60;redirect&#x60;. The client application should set the relevant cookies at login time, before actioning any of the passport-related URLs.


## Configuration parameters

    { hotCoreAuth: {

      callbackURLBase: &#x27;http://localhost:3000&#x27;,

      recoverURLexpiry: 60*30, // Seconds for which the recover URL works for

      // Only local strategy enabled by default
      strategies: {
        local: { },
      },

      redirectURLs: {
        success: {
          signin: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/pick&#x27; ),
          recover: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/pick&#x27;),
          register: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ),&#x27;/auth/pick&#x27;),
          manager: &#x27;/&#x27;,
        },

        fail: {
          signin: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/welcome&#x27; ),
          recover: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/welcome&#x27; ),
          register: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/welcome&#x27; ),
          manager: &#x27;/&#x27;,
        }
      },
      responsePage: basicResponsePage,
      appURL: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/app&#x27; ),
    };

@module hotCoreAuth
@class hotCoreAuth
@static
*/

var dummy
  , path = require(&#x27;path&#x27;)
  , hotplate = require(&#x27;hotplate&#x27;)
  , declare = require(&#x27;simpledeclare&#x27;)

  , SimpleDbLayer = require( &#x27;simpledblayer&#x27; )
  , SimpleSchema = require( &#x27;simpleschema&#x27; )
  , JsonRestStores = require( &#x27;jsonreststores&#x27; )

  , hotCoreJsonRestStores = require( &#x27;hotCoreJsonRestStores&#x27; )
  , hotCoreStoreRegistry = require( &#x27;hotCoreStoreRegistry&#x27; )
  , hotCoreServerLogger = require( &#x27;hotCoreServerLogger&#x27; )
;

// Set some sane defaults

var basicResponsePage = function( strategyId, action, user, profile ){
  var response = &#x27;&#x27;;
  response += &quot;&lt;html&gt;&lt;body&gt;&lt;script type=\&quot;text/javascript\&quot;&gt;setTimeout(function(){ window.close() }, 5000);&lt;/script&gt;RESPONSE&lt;/body&gt;&lt;/html&gt;&quot;;
  return response;
};



hotplate.config.set(&#x27;hotCoreAuth&#x27;, {

  callbackURLBase: &#x27;http://localhost:3000&#x27;,

  recoverURLexpiry: 60*30, // Seconds for which the recover URL works for

  // Only local strategy enabled by default
  strategies: {
    local: { },
  },

  redirectURLs: {
    success: {
      signin: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/pick&#x27; ),
      recover: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/pick&#x27;),
      register: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ),&#x27;/auth/pick&#x27;),
      manager: &#x27;/&#x27;,
    },

    fail: {
      signin: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/welcome&#x27; ),
      recover: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/welcome&#x27; ),
      register: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/auth/welcome&#x27; ),
      manager: &#x27;/&#x27;,
    }
  },
  responsePage: basicResponsePage,
  appURL: path.join( hotplate.config.get( &#x27;hotplate.routeUrlsPrefix&#x27; ), &#x27;/app&#x27; ),
});


/**
It returns the authentication stores 
The stores returned are:

## users

The users

## usersStrategies

The strategies

## authStrategies

The list of possible authentication strategies

## logins

The list of all possible logins


@event stores
@requires hotCoreJsonRestStores
@return {Object} An associative array of stores

*/

hotplate.hotEvents.onCollect( &#x27;stores&#x27;, &#x27;hotCoreAuth&#x27;, hotplate.cachable( function( done ){

  var stores = {}

  hotCoreJsonRestStores.get( function( err, s ){
    if( err ){
      done( err );
    } else {

      var HotStore = s.HotStore;
      var HotSchema = s.HotSchema;

      // ***********************************
      // *** USERS *************************
      // ***********************************

      var Users = declare( HotStore, {
    
        // COMMON
        schema: new HotSchema({
          recoverToken:        { type: &#x27;blob&#x27;, searchable: true, notempty: true },
          recoverTokenCreated: { type: &#x27;date&#x27;, searchable: true, notempty: true },
        }),

        // Nothing is searchable in users by default
        onlineSearchSchema: new HotSchema({
        }),
    
        storeName:  &#x27;users&#x27;,
    
        publicURL: &#x27;/users/:id&#x27;,
        hotExpose: true,

      });
      stores.users = new Users();
    
      var UsersStrategies = declare( HotStore, {
    
        schema: new HotSchema({
          strategyId:  { type: &#x27;blob&#x27;, searchable: true, required: true, trim: 30 }  ,
          field1:      { type: &#x27;blob&#x27;, searchable: true, required: false, trim: 255 } ,
          field2:      { type: &#x27;blob&#x27;, searchable: true, required: false, trim: 255 } ,
          field3:      { type: &#x27;blob&#x27;, searchable: true, required: false, trim: 255 } ,
          field4:      { type: &#x27;blob&#x27;, searchable: true, required: false, trim: 255 } ,
        }),
    
        // Nothing is searchable in usersStrategies by default
        onlineSearchSchema: new HotSchema({
        }),

        storeName:  &#x27;usersStrategies&#x27;,

        publicURL: &#x27;/users/:userId/strategies/:id&#x27;,
        hotExpose: true,

        preserveCacheOnReset: true,

        handleGet: true,
        handleGetQuery: true,
        handleDelete: true,

        checkPermissions: function( request, method, cb ){

          switch( method ){
            case &#x27;get&#x27;:
            case &#x27;getQuery&#x27;:
              // Only their own strategies
              if( request.session.userId != request.params.userId ) return cb( null, false );
              return cb( null, true );
            break;

            case &#x27;delete&#x27;:
              // Only their own strategies
              if( request.session.userId != request.params.userId ) return cb( null, false );
    
              // Don&#x27;t allow them to delete the last remaining strategy, or they will not be allowed back in
              stores.usersStrategies.dbLayer.selectByHash( { conditions: { userId: request.data.fullDoc.userId } }, { children: true }, function( err, queryDocs) {
                if( err ) return cb( err );

                if( queryDocs.length &gt; 1 ){
                  cb( null, true );
                } else {
                  cb( null, false );
                }
              });
            break;

            default:
              // Let it pass by default
              return cb( null, true );
            break;

          }
        },
       
        // Make sure that, if the request is from the web, field3 and field4 are out of the equation as
        // they often include nice goodies like passwords etc.
        extrapolateDoc: function( request, method, doc, cb ){

          var doc = this._co( doc );

          // Local request: all good
          if( ! request.remote ) return cb( null, doc );
    
          // Remote request: delete field, and return
          delete doc[ &#x27;field3&#x27; ];
          delete doc[ &#x27;field4&#x27; ];

          cb( null, doc );
          
        },
    
      });
      stores.usersStrategies = new UsersStrategies();
      
    
      var AuthStrategies = declare( JsonRestStores, JsonRestStores.HTTPMixin, {
    
        schema: new SimpleSchema({
          id:        { type: &#x27;blob&#x27;, isRequired: true, trim: 30 }  ,
        }),

        handleGet: true,
        handleGetQuery: true,
    
        storeName:  &#x27;authStrategies&#x27;,
   
        //logError: function( error ){ hotCoreServerLogger.log( error ); },
 
        publicURL: &#x27;/authstrategies/:id&#x27;,
        hotExpose: true,

        implementFetchOne: function( request, cb ){
          var strategies = hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27;);
          var doc;
    
          // No strategies defined in Hotplate, end of story
          if( typeof( strategies ) === &#x27;undefined&#x27; ){
            return cb( null, null );     
          }
     
          // Check if the strategy is one of the ones defined in Hotplate
          if( typeof( strategies[ params.id ] ) !== &#x27;undefined&#x27; ){
            doc = {}
            doc.id = params.id;
          } else {
            doc = null;
          }
    
          // Return whatever was found
          cb( null, doc );
        },
    
        implementQuery: function( request, cb ){
          var strategies = hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27;);
          var doc;
          var docs = [];
          
          for( var strategyId in strategies ){
            docs.push( { id: strategyId } );
          }      
          cb( null, docs );
        },
    
    
      });
    
      stores.authStrategies = new AuthStrategies();
    
      // This is used so that an applicaton can know in advance if a user login is already taken
      var Logins = declare( JsonRestStores, JsonRestStores.HTTPMixin, {
    
        schema: new SimpleSchema({
          login     : { type: &#x27;string&#x27;, required: true, lowercase: true, trim: 30, searchable: true },
        }),
   
        storeName:  &#x27;logins&#x27;,

        DbLayer: SimpleDbLayer,   

        handleGetQuery: true,

        publicURL: &#x27;/logins/:id&#x27;,
        hotExpose: true,
    
        implementQuery: function( request, cb ){
          
          var self = this;
    
          stores.usersStrategies.dbLayer.selectByHash( { conditions: { strategyId: &#x27;local&#x27;, field1: request.options.conditions.login } }, { children: true }, function( err, res ){
            if( err ){
              cb( err, null );
            } else {
              if( res.length ){
                cb( null, [ { login: request.options.conditions.login } ] );
                // });
              } else {
                cb( null, [ ] );
              }
            }
          });      
    
        },   
    
      });
      stores.login = new Logins();
    
      done( null, stores );

    }
  });

}))

/**
Sets recover URL &#x60;/recover/:recoverToken&#x60; (for token recovery).  
Also goes through the list of &#x60;AuthStrategies&#x60;, loads the right
files in &#x60;auth/{strategy name}.js&#x60; (e.g. {{#crossLink &quot;hotCoreAuth.facebook&quot;}}{{/crossLink}}), and runs them.
This basically ensures that all strategies have the right URLs all set for them to work.

@event setRoutes
*/
hotplate.hotEvents.onCollect( &#x27;setRoutes&#x27;, hotplate.cachable( function( app, done ){

  hotCoreStoreRegistry.getAllStores( function( err, stores ){

    function makeResponder( req, res, next, strategyId, action ) {
  
      return function(err, user, profile ) {
  
        var responseType, strategies;
  
        var k = req.cookies[ strategyId + &#x27;-&#x27; + action ];
        if( typeof( k ) !== &#x27;undefined&#x27; ){
          responseType = k;
        }
  
        // Fallback option
        if( ! responseType ) responseType = &#x27;redirect&#x27;;
  
        // Defaults to an empty profile object
        if( typeof( profile ) === &#x27;undefined&#x27; ){
          profile = {};
        }
  
        // Error: just return/next that
        if( err ) { return next( err ); }
  
        switch( responseType ){
  
          case &#x27;content&#x27;:
  
            // Work out the page&#x27;s content by calling the user-set hotCoreAuth/responsePage function
            // Note: if hotCoreAuth/responsePage is not set, it will use a placeholder fallback string
            var content;
            var contentFunction = hotplate.config.get( &#x27;hotCoreAuth.responsePage&#x27; );
            if( typeof( contentFunction ) === &#x27;function&#x27; ){
              content = contentFunction( strategyId, action, user, profile );
            } else {
              content = &quot;PLEASE SET hotCoreAuth/responsePage IN YOUR SERVER FILE TO CUSTOMIZE CONTENTS&quot;;
            }

            // Send the contents
            res.send( content );      
          break;
  
          case &#x27;close&#x27;:
  
            if( ! user &amp;&amp; typeof( profile.message) !== &#x27;undefined&#x27;  ){
              
              // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
              res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.alert(&quot;&#x27; + profile.message + &#x27;&quot;);window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
            } else {
              res.send(&#x27;&lt;html&gt;&lt;script&gt;window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
            }
          break;
  
          case &#x27;ajax&#x27;:
  
            if( user ){
              res.json( 200, { user: user, profile: profile } );
            } else {
              var error = &#x27;Authentication error&#x27;;
              if( typeof( profile.message) !== &#x27;undefined&#x27; ) error =  profile.message;
              res.json( 403, { message: error } );
            }
  
          break;
  
  
          case &#x27;redirect-opener&#x27;:
  
            if( ! user &amp;&amp; typeof( profile.message) !== &#x27;undefined&#x27;  ){
  
              // FIXME: http://stackoverflow.com/questions/17141863/escaping-error-message-in-javascript
              res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.alert(&quot;&#x27; + profile.message + &#x27;&quot;);window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
              
            } else {
              var redirectURL = hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.success.&#x27; + action) || &#x27;/&#x27;;
              res.send(&#x27;&lt;html&gt;&lt;script&gt;window.opener.location = &quot;&#x27; + redirectURL + &#x27;&quot;;window.close();&lt;/script&gt;&lt;/html&gt;&#x27;);      
            }
          break;
  
  
          case &#x27;redirect&#x27;:
          default:
  
            if( user ){
              var redirectURL = hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.success.&#x27; + action) || &#x27;/&#x27;;
              res.redirect( redirectURL );
            } else {
  
              // Add the error to the session messages
              if( typeof( profile.message) !== &#x27;undefined&#x27;  ){
                req.session.messages = req.session.messages || []; 
                req.session.messages.push( { type: &#x27;error&#x27;, message: profile.message } );
              }
  
              var redirectURL = hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.fail.&#x27; + action) || &#x27;/&#x27;;
              res.redirect( redirectURL );
            }
          break;
  
        }
  
      }
    }

    // ******************************
    // Function actually stats here
    // ******************************

    if( err ){
      done( err );
    } else {

      app.get(&#x27;/recover/:recoverToken&#x27;, function( req, res, next ){
    
        stores.users.dbLayer.selectByHash( { conditions: { recoverToken: req.params[ &#x27;recoverToken&#x27; ] } }, { children: true }, function( err, result ){
          if( err ){
            done( err, null );
          } else {
            if( result.length == 0 ){
              // Error page
    
              // Artificially create a TokenInvalid error, and next( err ) it 
              var error = new Error();
              error.name = &quot;TokenInvalidError&quot;;
              error.message = &quot;Token not valid!&quot;;
              req.hotError = error;
              next( error );
    
            } else {
            
              var user = result[0];
    
              if( ! user.recoverTokenCreated ){
    
                // Artificially create a TokenDateInvalid error, and next( err ) it 
                var error = new Error();
                error.name = &quot;TokenDateInvalidError&quot;;
                error.message = &quot;Token date invalid!&quot;;
                req.hotError = error;
                next( error );
              } else {
    
                // Get the important variables 
                var tokenAgeInSeconds = Math.round( ( (new Date() ) - user.recoverTokenCreated ) / 1000 );
                var recoverURLexpiry = hotplate.config.get( &#x27;hotCoreAuth.recoverURLexpiry&#x27; ); 
    
                var tokenIsGood = tokenAgeInSeconds &lt; recoverURLexpiry;
    
                if( ! tokenIsGood ){
    
                  // Artificially create a TokenExpired error, and next( err ) it 
                  var error = new Error();
                  error.name = &quot;TokenExpiredError&quot;;
                  error.message = &quot;Token expired!&quot;;
                  req.hotError = error;
                  next( error );
    
                } else {
    
                  delete user.recoverToken;
                  delete user.recoverTokenCreated;

                  stores.users.dbLayer.updateById( user.id, { recoverToken: undefined, recoverTokenCreated: undefined }, function( err ){    
                    if( err ){
                      next( err );
                    } else {
    
                      // Log the user in using the token!
                      req.session.loggedIn = true;
                      req.session.userId = user.id;
    
                      // Redirect to the right URL
                      res.redirect( hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.success.recover&#x27;) );
                    }
      
                  });
                }
                 
    
              }
              
            }
              
          }
        });
    
    
      }); 
    
    
      if( typeof( hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27; )) === &#x27;object&#x27; ){
        Object.keys( hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27; )).forEach( function( strategyName ) {
        
          // Get the strategy&#x27;s data
          var strategyConfig = hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27; )[strategyName];
    
          // Gets the right strategy maker and runs it
          var strategyMaker = require( &#x27;./auth/&#x27; + strategyName );
          strategyMaker( app, strategyConfig, makeResponder, stores.authStrategies, stores.users, stores.usersStrategies, stores.logins );
        });
    
      }
    
      done( null );
    }
  });

}))


hotplate.hotEvents.onCollect( &#x27;pageElements&#x27;, &#x27;hotCoreAuth&#x27;, function( done ){
  var strategyIds = Object.keys( hotplate.config.get(&#x27;hotCoreAuth.strategies&#x27;) ) || [];
  
  done( null, {
    vars: [
            { name: &#x27;strategyIds&#x27;,  value: strategyIds },
            { name: &#x27;successURLs&#x27;,  value: hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.success&#x27;) },
            { name: &#x27;failURLs&#x27;,     value: hotplate.config.get(&#x27;hotCoreAuth.redirectURLs.fail&#x27;) },
          ],
  });
});


hotplate.hotEvents.onCollect( &#x27;pageElementsPerPage&#x27;, &#x27;hotCoreAuth&#x27;, function( req, pageName, done ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.session.userId ) {
    vars.push( { name: &#x27;userId&#x27;, value: req.session.userId } );
  }

  done( null, {
    vars: vars 
  });

});



</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
</body>
</html>
