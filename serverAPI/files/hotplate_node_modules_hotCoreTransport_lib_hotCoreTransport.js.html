<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Hotplate server API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/weblookalike.css" id="site_styles">
    <link rel="stylesheet" href="global/header.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">


    <!-- HEADER -->
    <div id="header_wrap" class="outer">

        <div class="main_menu">
             <span><a href="/">Home</a></span>
             <span><a href="/guide.html">Guide</a></span>
             <span><a href="/serverAPI/index.html">Server API</a></span>
             <span><a href="/clientAPI/index.html">Client API</a></span>
        </div>

        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mercmobily/hotplate">View on GitHub</a>

            
          <h1 id="project_title">Hotplate server API</h1>
          <h2 id="project_tagline">Multi-homed SaaS with NodeJs, Express, (any)DB, Dojo</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mercmobily/hotplate/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mercmobily/hotplate/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>



<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">




           <!-- 
                <h1><img src="../assets/css/logo.png" title=""></h1>
            -->

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/hotCoreAuth.html">hotCoreAuth</a></li>
                                <li><a href="../classes/hotCoreAuth.facebook.html">hotCoreAuth.facebook</a></li>
                                <li><a href="../classes/hotCoreClientFiles.html">hotCoreClientFiles</a></li>
                                <li><a href="../classes/hotCoreMultiHome.html">hotCoreMultiHome</a></li>
                                <li><a href="../classes/hotCoreTransport.html">hotCoreTransport</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/hotCoreAuth.html">hotCoreAuth</a></li>
                                <li><a href="../modules/hotCoreClientFiles.html">hotCoreClientFiles</a></li>
                                <li><a href="../modules/hotCoreMultiHome.html">hotCoreMultiHome</a></li>
                                <li><a href="../modules/hotCoreTransport.html">hotCoreTransport</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: hotplate/node_modules/hotCoreTransport/lib/hotCoreTransport.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        &quot;use strict&quot;;
                        
                        var dummy
                          , path = require(&#x27;path&#x27;)
                          , hotplate = require(&#x27;hotplate&#x27;)
                          , declare = require(&#x27;simpledeclare&#x27;)
                          , async = require(&#x27;async&#x27;)
                          , debug = require(&#x27;debug&#x27;)(&#x27;hotplate:hotCoreTransport&#x27;)
                          , sanitize = require(&#x27;sanitize-caja&#x27;)
                        
                          , SimpleDbLayer = require( &#x27;simpledblayer&#x27; )
                          , SimpleSchema = require( &#x27;simpleschema&#x27; )
                          , JsonRestStores = require( &#x27;jsonreststores&#x27; )
                        
                          , hotCoreJsonRestStores = require( &#x27;hotCoreJsonRestStores&#x27; )
                          , hotCoreStoreRegistry = require( &#x27;hotCoreStoreRegistry&#x27; )
                          , hotCoreServerLogger = require( &#x27;hotCoreServerLogger&#x27; )
                          , logger = hotCoreServerLogger
                        ;
                        
                        /**
                        Provides tranport functionalities (SMS an email) to hotplate modules
                        
                        @module hotCoreTransport
                        @main hotCoreTransport
                        @class hotCoreTransport
                        @static
                        */
                        
                        // The stores variable is module-wide as some functions use them
                        var stores = {}
                        
                        // Set some sane defaults
                        
                        hotplate.config.set(&#x27;hotCoreTransport&#x27;, {
                          outgoingQueueInterval: 30000,
                          pollInterval: 5000,
                          defaultAttemptDelay: 60000 * 60,
                        
                          activeTransports: {
                            &#x27;email-default&#x27;: {
                              attachmentSizeLimit: 200 * 1000, // 200Kb
                              defaultAttemptDelay: 60 * 60 * 1000, // 60*60 secs
                            },
                            //&#x27;sms-twilio&#x27;: {},
                            &#x27;sms-plivo&#x27;: {
                              signatureHost: null,
                              
                              // NOTE: /app/incomingsms/plivo-update will be added as a valid incoming route!
                              updateRoute: &#x27;/app/incomingsms/plivo-update&#x27;,
                        
                              // Port and host are used to tell the plivo server where to send updates
                              updatePort: 3000,
                              updateHost: &#x27;27.33.233.17&#x27;,
                              
                              // NOTE: /app/incomingsms/plivo will be added as a valid incoming route!
                              smsRoute: &#x27;/app/incomingsms/plivo&#x27;,
                              defaultAttemptDelay: 60 * 60, // 60*60 secs
                            },
                          } 
                        });
                        
                        //hotplate.hotEvents.onCollect( &#x27;stores&#x27;,&#x27;hotCoreTransport&#x27;,  hotplate.cachable( function( done ){
                        //  done( null, {  aStore: { storeName: &#x27;aStore&#x27;, dbLayer: { dropAllIndexes: function(){} }  } } );
                        //}));
                        
                        hotplate.hotEvents.onCollect( &#x27;stores&#x27;,&#x27;hotCoreTransport&#x27;, hotplate.cachable( function( done ){
                          hotCoreJsonRestStores.get( function( err, s ){
                            if( err ) return done( err );
                        
                            var HotStore = s.HotStore;
                            var HotSchema = s.HotSchema;
                            var BasicDbStore = s.BasicDbStore;
                            var BasicSchema = s.BasicSchema;
                         
                            var Messages = declare( [ BasicDbStore ],  {
                        
                              schema: new HotSchema({
                                id          : { type: &#x27;id&#x27;,     searchable: true },
                        
                                type        : { type: &#x27;string&#x27;, searchable: true, required: true,  notEmpty: true, trim: 5 },        
                                incoming    : { type: &#x27;boolean&#x27;, searchable: true, required: true },
                                from        : { type: &#x27;string&#x27;, searchable: true, required: true,  notEmpty: false, trim: 255 },        
                                subject     : { type: &#x27;string&#x27;, searchable: true, required: false, notEmpty: false, trim: 1024 },
                                bodyText    : { type: &#x27;string&#x27;, searchable: true, required: false,  notEmpty: false, trim: 256000 },
                                bodyHtml    : { type: &#x27;string&#x27;, searchable: false, required: false,  notEmpty: false, trim: 256000 },
                                bodyHtmlSane: { type: &#x27;string&#x27;, searchable: false, protected: true  },
                        
                                appData     : { type: &#x27;serialize&#x27;, searchable: false, required: false, trim: 256000 }, 
                        
                             }),
                        
                              idProperty: &#x27;id&#x27;,
                        
                              storeName:  &#x27;messages&#x27;,
                        
                              nested: [
                                {
                                  store: &#x27;messagesTo&#x27;,
                                  join: { &#x27;messageId&#x27;: &#x27;id&#x27; },
                                  type: &#x27;multiple&#x27;
                                },
                        
                                {
                                  store: &#x27;messagesAttachments&#x27;,
                                  join: { &#x27;messageId&#x27;: &#x27;id&#x27; },
                                  type: &#x27;multiple&#x27;
                                },
                        
                                {
                                  store: &#x27;messagesDeliveryLog&#x27;,
                                  join: { &#x27;messageId&#x27;: &#x27;id&#x27; },
                                  type: &#x27;multiple&#x27;
                                },
                              ],
                        
                              hotExpose: false,
                        
                              init: function f(){
                                var self = this;
                        
                                this.inherited( f, arguments );
                        
                                // Make dead sure that, at db-layer level, bodyHtmlSane is _always_ set on insert AND update
                                // (it&#x27;s always derived from bodyHtml)
                                self.dbLayer.onCollect( &#x27;preInsert&#x27;, function( record, options, done ){
                                  record.bodyHtmlSane = sanitize( record.bodyHtml );
                                  done();
                                });
                                self.dbLayer.onCollect( &#x27;preUpdate&#x27;, function( conditions, updateObject, options, done ){
                                  if( updateObject.bodyHtml ) updateObject.bodyHtmlSane = sanitize( updateObject.bodyHtml );
                                  done();
                                });
                              },
                        
                            });
                        
                          
                            stores.messages = new Messages();
                        
                        
                        
                            var MessagesAttachments = declare( [ BasicDbStore ],  {
                        
                              schema: new BasicSchema({
                                id             : { type: &#x27;id&#x27;, searchable: true },
                                messageId      : { type: &#x27;id&#x27;, searchable: true },
                        
                                foreignId      : { type: &#x27;string&#x27;, searchable: true, required: false,  notEmpty: false, trim: 255 }, 
                                retrieved      : { type: &#x27;boolean&#x27;, default: false },
                                fileName       : { type: &#x27;string&#x27;, searchable: false, required: false,  notEmpty: true, trim: 255 }, 
                                mimeType       : { type: &#x27;string&#x27;, searchable: false, required: false,  notEmpty: true, trim: 255 },
                                size           : { type: &#x27;number&#x27;, searchable: false, required: false,  notempty: true },
                                embeddedId     : { type: &#x27;string&#x27;, searchable: false, required: false,  notEmpty: true, trim: 255 },
                        
                                attachmentInfo : { type: &#x27;serialize&#x27;, required: false },
                                attachmentData : { type: &#x27;blob&#x27;, searchable: false, required: false },        
                              }),
                        
                              idProperty: &#x27;id&#x27;,
                        
                              storeName:  &#x27;messagesAttachments&#x27;,
                        
                              hotExpose: false,
                        
                              nested: [
                                {
                                  type: &#x27;lookup&#x27;,
                                  localField: &#x27;messageId&#x27;,
                                  store: &#x27;messages&#x27;,
                                  //layerField: &#x27;id&#x27;
                                  //join: { &#x27;id&#x27; : &#x27;messageId&#x27; },
                                },
                              ],
                        
                            });
                            stores.messagesAttachments = new MessagesAttachments();
                        
                            // Status can be: todeliver, delivering, delivered, undeliverable, dontdeliver
                            var MessagesTo = declare( [ BasicDbStore ],  {
                        
                              schema: new BasicSchema({
                                id             : { type: &#x27;id&#x27;, searchable: true },
                                messageId      : { type: &#x27;id&#x27;, searchable: true },
                        
                                foreignId   : { type: &#x27;string&#x27;,    searchable: true, required: false,  notEmpty: true, trim: 255 }, 
                                foreignData : { type: &#x27;serialize&#x27;, searchable: false, required: false, trim: 256000 }, 
                        
                                appData     :  { type: &#x27;serialize&#x27;, searchable: false, required: false, trim: 256000 }, 
                        
                                to             : { type: &#x27;string&#x27;, searchable: true, required: true, notEmpty: true, trim: 255 },        
                                status         : { type: &#x27;string&#x27;, searchable: true, required: true, notEmpty: true, trim: 15 },
                                failedAttempts : { type: &#x27;number&#x27;, searchable: true, required: true, default: 0, notEmpty: true },
                                attemptAfter   : { type: &#x27;date&#x27;,   searchable: true, required: false, default: function() { return new Date() } },
                                added          : { type: &#x27;date&#x27;, protected: true, default: function() { return new Date() } },
                                lastChange     : { type: &#x27;date&#x27;, protected: false, default: function() { return new Date() } },
                              }),
                        
                              idProperty: &#x27;id&#x27;,
                        
                              storeName:  &#x27;messagesTo&#x27;,
                        
                              hotExpose: false,
                        
                              nested: [
                                {
                                  type: &#x27;lookup&#x27;,
                                  localField: &#x27;messageId&#x27;,
                                  store: &#x27;messages&#x27;,
                                  //layerField: &#x27;id&#x27;
                                  //join: { &#x27;id&#x27; : &#x27;messageId&#x27; },
                                },
                              ],
                        
                            });
                            stores.messagesTo = new MessagesTo();
                        
                        
                            var MessagesDeliveryLog = declare( [ BasicDbStore ],  {
                        
                              schema: new BasicSchema({
                                id            : { type: &#x27;id&#x27;, searchable: true },
                        
                                messageToId   : { type: &#x27;id&#x27;, required: false, searchable: true },
                                messageId     : { type: &#x27;id&#x27;, required: false, searchable: true }, // NN
                                workspaceId   : { type: &#x27;id&#x27;, searchable: true, required: false},
                        
                                date          : { type: &#x27;date&#x27;, protected: true, default: function() { return new Date() } },
                                level         : { type: &#x27;number&#x27;, default: 1 },
                                line          : { type: &#x27;string&#x27;, searchable: false, required: true, notEmpty: true, trim: 2048 },        
                                config        : { type: &#x27;serialize&#x27; },
                        
                            
                              }),
                        
                              onlineSearchSchema: new HotSchema({
                              }),
                        
                              /*
                              nested: [
                                {
                                  type: &#x27;lookup&#x27;,
                                  localField: &#x27;messageId&#x27;,
                                  store: &#x27;messages&#x27;,
                                  layerField: &#x27;id&#x27;
                                  //join: { &#x27;id&#x27; : &#x27;messageId&#x27; },
                                },
                                {
                                  type: &#x27;lookup&#x27;,
                                  localField: &#x27;messageToId&#x27;,
                                  store: &#x27;messagesTo&#x27;,
                                  layerField: &#x27;id&#x27;
                                  //join: { &#x27;id&#x27; : &#x27;messageToId&#x27; },
                                },
                              ],
                              */
                        
                              idProperty: &#x27;id&#x27;,
                        
                              storeName:  &#x27;messagesDeliveryLog&#x27;,
                        
                              hotExpose: false,
                        
                            });
                            stores.messagesDeliveryLog = new MessagesDeliveryLog();
                        
                            done( null, stores );
                          });
                        
                        }));
                        
                        
                        // Utility functions to get the transport&#x27;s config
                        
                        var getAllTransportConfig = function( transport, done ){
                        
                          hotplate.hotEvents.emitCollect( &#x27;allTransportConfig&#x27;, transport, function( err, results ) { 
                            if( err ) return done( err );
                        
                            // No configuration available: return null
                            if( ! Array.isArray( results ) || results.length === 0 ) return done( err, [ ] );
                        
                            // Return flattened results
                            done( null, Array.prototype.concat.apply([], results.onlyResults() ));
                            
                          });
                        };
                        
                        var getTransportConfig = function( messageTo, done ){
                        
                          hotplate.hotEvents.emitCollect( &#x27;transportConfig&#x27;, messageTo, function( err, results ) { 
                            if( err ) return done( err );
                        
                            // No configuration available: return null
                            if( ! Array.isArray( results ) || results.length === 0 ) return done( err, null )
                        
                            // If more than one, issue a warning
                            if( results.length &gt; 1 ) debug(&quot;WARNING: more than 1 results returned for &quot;, messageTo );
                        
                            // Return the first result
                            done( null, results[ 0 ].result );
                          });
                        
                        };
                        
                        
                        // Functions that use the sub-layers to work.
                        // * getPollingStatus() (exported) calls the transport&#x27;s pollingStatus() function
                        // * The events &#x27;setRoute&#x27; and &#x27;run&#x27; will trigger the corresponding functions in each active transport
                        // * The event &#x27;run&#x27; will also call setTransportCron(), which:
                        //    - For sendMessage(), it will cycle through the message queue calling the transport&#x27;s sendMessage() for each
                        //    - For startPolling() (exported), it will call the transport&#x27;s startPolling() call
                        //
                        // Exported:
                        // * startPolling(). This will enable other modules to force polling for a specific transport
                        // * getPollingStatus(). This will enable other modules to see what the status us for a specific transport
                        
                        var startPolling = exports.startPolling = function( transport, stores, config, force ){
                          require(&#x27;./transport/&#x27; + transport + &#x27;.js&#x27; ).startPolling( stores, config, force );
                        }
                        
                        var getPollingStatus = exports.getPollingStatus = function( transport, config, done ){
                          require(&#x27;./transport/&#x27; + transport + &#x27;.js&#x27; ).getPollingStatus( config, done );
                        }
                        
                        // Message moving functions
                        var sendMessage = function( transport, stores, messageTo, config, done ){
                          require(&#x27;./transport/&#x27; + transport + &#x27;.js&#x27; ).sendMessage( stores, messageTo, config, done );
                        }
                        
                        /**
                          @event setRoutes
                        */
                        hotplate.hotEvents.onCollect( &#x27;setRoutes&#x27;, &#x27;hotCoreTransport&#x27;, function( app, done ){
                        
                          hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
                            if( err ) return done( err );
                        
                            async.eachSeries(
                              Object.keys( hotplate.config.get(&#x27;hotCoreTransport&#x27;).activeTransports),
                              function( transport, cb ){
                        
                                getAllTransportConfig( transport, function( err, configArray ){
                                  if( err ) return cb( err );
                        
                                  var transportModule = require(&#x27;./transport/&#x27; + transport + &#x27;.js&#x27; );
                                  // Run setRoutes for relevant module
                        
                                  transportModule.setRoutes( storeRegistry, app, configArray, cb );
                                });
                              },
                              function( err ){
                                if( err ) return done( err );
                                done( null );
                              }
                            );
                          });
                        });
                        
                        
                        /**
                          @event run
                        */
                        hotplate.hotEvents.onCollect( &#x27;run&#x27;, &#x27;hotCoreTransport&#x27;, function( done ){
                        
                          hotCoreStoreRegistry.getAllStores( function( err, storeRegistry ){
                            if( err ) return done( err );
                        
                            async.eachSeries(
                              Object.keys( hotplate.config.get(&#x27;hotCoreTransport&#x27;).activeTransports ),
                              function( transport, cb ){
                                // Run setRoutes for relevant module
                        
                                getAllTransportConfig( transport, function( err, configArray ){
                                  if( err ) return cb( err );
                        
                                  var transportModule = require(&#x27;./transport/&#x27; + transport + &#x27;.js&#x27; ).run( storeRegistry, configArray, cb );
                                });
                              },
                              function( err ){
                                if( err ) return done( err );  
                        
                                startTransportCron(); // Set the main cron for transport
                                done( null );
                              }
                            );
                          });
                        });
                        
                        
                        
                        // Runs through the message queue, attempting to send messages
                        function startTransportCron(){
                        
                          var inCycle = false;
                          var inPollingCycle = false;
                        
                          hotCoreStoreRegistry.getAllStores( function( err, storeRegistry){
                            if( err ) {
                              logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error while getting all stores&quot; } );
                              return;
                            };
                        
                            // INGOING: Receive messages by polling
                            // This function will start once a minute, and will call
                            // transportModule.startPolling() for each active module/config pair
                            setInterval( function(){
                        
                              debug(&quot;**************************Running polling cron&quot;)
                        
                              // Do not run cron twice
                              if( inPollingCycle) {
                                debug(&quot;**********************************************************************************&quot;);
                                debug(&quot;************************** Polling cron quit as the previous one was still running&quot;);
                                debug(&quot;**********************************************************************************&quot;);
                                return;
                              }
                              inPollingCycle = true;
                        
                              async.eachSeries(
                                Object.keys( hotplate.config.get(&#x27;hotCoreTransport&#x27;).activeTransports ),
                                function( transport, cb ){
                        
                                  getAllTransportConfig( transport, function( err, configArray ){
                                    if( err ){
                                      logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error while running getAllTransportConfig&quot;, data: { transport: transport } } );
                                      // This returns &quot;all good&quot; as cycle will need to continue for other transports
                                      return cb( null );
                                    }
                        
                                    debug(&quot;Config array:&quot;, configArray );
                        
                                    // For each config attached to that transport, start polling
                                    configArray.forEach( function( config ){
                                      debug(&quot;Polling for %o&quot;, config );
                                      startPolling( transport, stores, config );
                                    })
                        
                                    // This returns &quot;all good&quot; as cycle will need to continue for other transports configs
                                    return cb( null );
                                  })
                        
                                },
                                function( err ){
                                  debug( &quot;*****************************Polling cron finished! Setting inPollingCycle to false&quot; );
                                  // Nothing ever sets &#x27;err&#x27;
                                  // Anything wrong is dealt with by logger.log
                                  // All that needs to happen, is that inPollingCycle is false as the cycle is finished
                                  inPollingCycle = false;
                                }
                              )
                        
                            }, hotplate.config.get(&#x27;hotCoreTransport.pollInterval&#x27; ) );
                         
                        
                            // OUTGOING: Send messages using sendMessage()
                        
                            setInterval( function(){
                        
                              debug(&quot;CRON to send messages started&quot;);
                              // Do not run cron twice
                              if( inCycle) {
                                debug(&quot;CRON to send messages quit as it was still running&quot;);
                                logger.log( { system: true, logLevel: 2, message: &quot;Cron to sent messages not started as it is marked as &#x27;already running&#x27;&quot; } );
                                return;
                              }
                              inCycle = true;
                        
                              // Get the cursor for elements in messagesTo...
                              var now = new Date();
                              stores.messagesTo.dbLayer.select(
                                { conditions: { type: &#x27;and&#x27;, args: [ 
                                  { type: &#x27;lt&#x27;, args: [ &#x27;attemptAfter&#x27;, now ] },
                                  { type: &#x27;eq&#x27;, args: [ &#x27;status&#x27;, &#x27;todeliver&#x27; ] },
                                ] } }, 
                                { useCursor: true , &#x27;delete&#x27;: false, children: true },
                                function( err, cursor, total, grandTotal ){
                        
                                // If the cursor cannot be obtained, set inCycle as false, log the problem and get out
                                if( err ) {
                                  inCycle = false; 
                                  logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error getting cursor for queue&quot; } );
                                  return;
                                }; 
                        
                                // Go through the cursor asynchromously using async
                                // NOTE that the cycle will not wait for each sendMessage() to finish. However,
                                // if sendMessage() returns with an error, errInCycle is set and excution of the cycle
                                // will be interrupted half way. The rationale is that if there is a bad error with sending
                                // a message, there is no point in continuing with the others
                                var i;
                                async.doWhilst(
                        
                                  function( callback ){
                        
                                    cursor.next( function( err, messageTo ){
                                      if( err ) return callback( err );
                        
                                      i = messageTo;
                        
                                      debug(&quot;Got message from cursor: &quot;, messageTo );
                        
                                      // If messageTo is null, just return. This is here because
                                      // cursor.next WILL return &#x27;null&#x27; to indicate the last one
                                      if( messageTo === null ) return callback( null ); 
                        
                                      debug(&quot;Message not null: dealing with it!&quot; );
                                    
                                      // ******************************************
                                      // THIS IS WHERE EACH MESSAGE IS EVALUATED
                                      // ******************************************                  
                        
                                      // Get the config for that message from the application
                                      getTransportConfig( messageTo, function( err, transportConfig ){
                                        if( err ){
                                          //logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error while getting transport configuration&quot;, data: { config: config, messageTo: messageTo } } );
                                          logLine( null, messageTo.messageId, messageTo.id, 3, &quot;Error while getting transport configuration&quot;, err );
                                          return;
                                        }
                        
                                        // Send the message!
                                        // This will only ever return with err !== null when something goes horribly wrong.
                                        // Undeliverable messages, socket timeouts etc.  mustn&#x27;t do that.
                                        debug(&quot;Config for message retrieved, result: &quot;, messageTo, transportConfig );
                        
                                        debug(&quot;About to call transportManipulateBeforeSend&quot; );
                        
                                        hotplate.hotEvents.emitCollect( &#x27;transportManipulateBeforeSend&#x27;, transportConfig.transport, messageTo, transportConfig.config, function( err ){
                        
                        
                                          debug(&quot;Message after transportManipulateBeforeSend: &quot;, messageTo );
                        
                                          // Could not pre-process messageTo
                                          if( err ){
                                            logLine( transportConfig.config, messageTo.messageId, messageTo.id, 3, &quot;Error pre-processing message&quot;, err );
                                            return;
                                          }
                        
                                        } )
                        
                                        sendMessage( transportConfig.transport, stores, messageTo, transportConfig.config);
                                      });
                        
                                      // This is in the right spot! This cycle doesn&#x27;t wait for getTransportConfig or sendMessage()
                                      // to finish.
                                      callback( null );
                        
                                    });
                                  },
                        
                                  function(){ return i != null; },
                        
                                  function( err ) {
                                    inCycle = false; 
                                    debug( &quot;CRON sending message finished!&quot; );
                                    return; 
                                  }
                                );
                              });     
                        
                        
                            }, hotplate.config.get(&#x27;hotCoreTransport.outgoingQueueInterval&#x27;, 60000 ) );
                          });
                        
                        }
                        
                        /* Utility functions used by sublayers 
                           These functions are always availanle to sub-layers, which will use them
                           to make things happen
                        */
                        
                        exports.transportLayerFunctions = {};
                        
                        /* Note
                           ----
                           The following functions are _guaranteed_ to be called once the module&#x27;s stores&#x27; variable
                           is set, because they are only ever called by the sub-systems (sms-plivo, email-default,
                           etc.), which is always required/run once hotCoreStoreRegistry.getAllStores() has been run
                        */
                        
                        // Log a line to messageDeliveryLog
                        var formatError = exports.transportLayerFunctions.formatError = function( err ){
                          return err.name + &#x27;: &#x27; + err.message;
                        }
                        
                        
                        // Log a line to messageDeliveryLog
                        // There is no callback for this function if anything goes wrong, it will call logger.log
                        // Note that logger.log is _always_ called to issue a system entry if logLevel is &gt;= 3.
                        // These are problems that need to be looked at if they do happen
                        var logLine = exports.transportLayerFunctions.logLine = function( config, messageId, messageToId, logLevel, line, errInLogline ){
                        
                          debug(&quot;logLine called: &quot;, config, messageId, messageToId, logLevel, line, errInLogline );
                        
                          // Base values
                          var o = {
                            level: logLevel,
                            line: line,
                            config: config
                          }
                          // Optional values
                          if( messageToId ) o.messageToId = messageToId;
                          if( messageId ) o.messageId = messageId;
                          if( o.config &amp;&amp; o.config.workspaceId ) o.workspaceId = o.config.workspaceId;
                        
                        
                          hotplate.hotEvents.emitCollect(&#x27;augmentMessageDeliveryLog&#x27;, o, function( err ){
                            if( err ){
                              var l = { error: err, system: true, logLevel: 3, message: &quot;Error emitting augmentMessageDeliveryLog&quot;, data: { entry: o } };
                        
                              if( o.workspaceId ) l.workspaceId = o.workspaceId;
                        
                              logger.log( l );
                            }
                        
                            // At this point, &#x27;o&#x27; is augmented in whichever way (most likely, the workspaceId was added)
                        
                            // If logLine is called with an error as last parameter, it means it&#x27;s indicating that
                            // something failed: log it as critical
                            // So, logger.log will be called with the relevant information
                            if( errInLogline ){
                              debug(&quot;Logline was called with an error parameter: &quot;, errInLogline );
                        
                              // For errors of levels 1 and 2, show the error name and message on the log line
                              // Transport layers should leep in mind that errors for levels 1 and 2 are displayed to the user
                              // in form of mail delivery log. Timeouts and auth errors are fine, DB errors are not.
                              if( logLevel &lt; 3 ) {
                                line += &quot; -- Error: &quot; + formatError( errInLogline );
                            
                              // For errors of levels 3 and up, absolutely log them with hotplate
                              // Note that since the loglevel is high, hotCoreServerLogger will also issue
                              // a hotplate. critical() (which will display on the screen)
                              } else {
                                var l = { error: errInLogline, system: true, logLevel: logLevel, message: &quot;hotCoreTransport.logLine logged: &quot; + line, data: { entry: o } };
                                if( o.workspaceId ) l.workspaceId = o.workspaceId;
                        
                                // Log the line to the main application&#x27;s logger
                                logger.log( l );
                              }
                            }
                        
                            stores.messagesDeliveryLog.dbLayer.insert(o, function( err, oRecord ){
                        
                              if( err ){
                                // Error while adding the entry: this is an important system error, log the event
                                logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error while writing on messagesDeliveryLog with dbLayer.insert&quot;, data: { lineData: o } } );
                                return;
                              }
                        
                              hotplate.hotEvents.emitCollect( &#x27;transportLog&#x27;, oRecord, function( err, results ) { 
                                // Error while emitting transportLog: this is an important system error, log the event
                                if( err ){ 
                                  logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error while emitting transportLog&quot;, data: { failedRecord: oRecord } } );
                                }
                              });
                            });
                          });
                        }
                        
                        // If &#x60;failedAttempt&#x60;, and the messageTo.failedAttempt &gt; 5, newMessageStatus is forced to &#x60;undeliverable&#x60;
                        // Failing to broadcast will result in logging with loglevel 3, but will not result in done( err ) as
                        // it&#x27;s not critical (the status has actually changed)
                        exports.transportLayerFunctions.changeMessageStatus = function( transport, config, messageTo, failedAttempt, newMessageStatus, done ){
                        
                          debug( &quot;changeMessageStatus called with parameters: &quot;, transport, config, messageTo, failedAttempt, newMessageStatus );
                        
                          // It&#x27;s NOT a failed attempt, just a change of status: in this case,
                          // the status is always set to newMessageStatus,   
                          if( !failedAttempt ){
                            messageTo.status = newMessageStatus;
                        
                          // It WAS a failed attempt: in this case, things are trickier. messageTo.failedAttempts will
                          // be incremented, and if it got too big the status will be forced to &#x27;undeliverable&#x27;. If it&#x27;s
                          // not too big, then the status will nbe set to newMessageStatus and attemptAfter set in the future
                          } else {
                        
                            messageTo.failedAttempts ++;
                        
                            // If the number of failed attempts is &gt; 5, then that&#x27;s the end of the story: the status is set
                            // to &#x27;undeliverable&#x27; (rather than what was requested) and attemptAfter is deleted.
                            if( messageTo.failedAttempts &gt; 5 ){
                              messageTo.status = &#x27;undeliverable&#x27;;
                              delete messageTo.attemptAfter;
                            } else {
                              messageTo.status = newMessageStatus;
                              var delay = hotplate.config.get(&#x27;hotCoreTransport.activeTransports.&#x27; + transport + &#x27;.defaultAttemptDelay&#x27;);
                              if( ! delay ){
                                delay = hotplate.config.get(&#x27;hotCoreTransport.defaultAttemptDelay&#x27;, 60 * 60 * 1000 );
                              }
                              messageTo.attemptAfter = new Date( new Date().getTime() + delay ); 
                        
                            };
                          }
                        
                          stores.messagesTo.dbLayer.update( { type: &#x27;eq&#x27;, args: [ &#x27;id&#x27;, messageTo.id ] }, { status: messageTo.status, failedAttempts: messageTo.failedAttempts }, function( err ){
                        
                            if( err ){
                              logLine( config, messageTo.messageId, messageTo.id, 3, &quot;Could not change the message status to &quot; + newMessageStatus, err );
                              return done( err );
                            }
                            
                            // If the emit fails the error is logged (loglevel 3) but done(null) as it&#x27;s not critical
                            hotplate.hotEvents.emitCollect( &#x27;changeMessageStatus&#x27;, transport, config, messageTo, function( err ) {
                              if( err ){
                                logLine( config, messageTo.messageId, messageTo.id, 3, &quot;Error broadcasting the change of status&quot;, err );
                              } 
                        
                              done( null );
                            });
                          });
                        }
                        
                        exports.transportLayerFunctions.deleteUnfinishedMessage = function( config, messageId ){
                        
                        
                          stores.messagesTo.dbLayer.delete( { type: &#x27;eq&#x27;, args: [ &#x27;messageId&#x27;, messageId ] }, { multi: true }, function( err ){
                            if( err ){
                              logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error while deleting elements from messagesTo for incomplete message&quot;, data: { config: config, messageId: messageId } } );
                            }
                        
                            stores.messagesAttachments.dbLayer.delete( { type: &#x27;eq&#x27;, args: [ &#x27;messageId&#x27;, messageId ] }, { multi: true }, function( err ){
                              if( err ){
                                logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error while deleting elements from messagesAttachments for incomplete message&quot;, data: { config: config, messageId: messageId } } );
                              }
                        
                              stores.messages.dbLayer.delete( { type: &#x27;eq&#x27;, args: [ &#x27;id&#x27;, messageId  ] }, { multi: true }, function( err ){
                                if( err ){
                                  logger.log( { error: err, system: true, logLevel: 3, message: &quot;Error while deleting elements from messages for incomplete message&quot;, data: { config: config, messageId: messageId } } );
                                }
                        
                              });
                            });
                          })
                        
                          
                        }
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
