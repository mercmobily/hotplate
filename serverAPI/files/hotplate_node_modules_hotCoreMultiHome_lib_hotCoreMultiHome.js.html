<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Hotplate API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.8.0pr2/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
     <link rel="stylesheet" href="/global/header.css" id="site_styles">
    <script src="http://yui.yahooapis.com/combo?3.8.0pr2/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
 
      <!-- HEADER -->
      <div id="header_wrap" class="outer">
  
          <div class="main_menu">
               <span><a href="/">Home</a></span>
               <span><a href="/guide.html">Guide</a></span>
               <span><a href="/serverAPI/index.html">Server API</a></span>
               <span><a href="/clientAPI/index.html">Client API</a></span>
          </div>
  
          <header class="inner">
            <a id="forkme_banner" href="https://github.com/mercmobily/hotplate">View on GitHub</a>
  
              
            <h1 id="project_title">Hotplate server API</h1>
            <h2 id="project_tagline">Framework to create multi-homed SaaS with NodeJs, Express</h2>
  
              <section id="downloads">
 
                <a class="zip_download_link" href="https://github.com/mercmobily/hotplate/zipball/master">Download this project as a .zip file</a>
                <a class="tar_download_link" href="https://github.com/mercmobily/hotplate/tarball/master">Download this project as a tar.gz file</a>
              </section>
          </header>
      </div>



<div id="doc">

    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1><a href="../index.html">undefined: hotplate/node_modules/hotCoreMultiHome/lib/hotCoreMultiHome.js</a></h1>
            <!--<h1><a href="../index.html"><img src="../assets/css/logo.png" width="117" height="52">undefined: hotplate/node_modules/hotCoreMultiHome/lib/hotCoreMultiHome.js</a></h1> -->
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>

    <div class="yui3-g">

        <div id="sidebar" class="yui3-u">
            <div id="modules" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Modules</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../modules/hotCoreAuth.html">hotCoreAuth</a>
                            </li>
                            <li><a href="../modules/hotCoreClientFiles.html">hotCoreClientFiles</a>
                            </li>
                            <li><a href="../modules/hotCoreMultiHome.html">hotCoreMultiHome</a>
                            </li>
                            <li><a href="../modules/hotCoreTransport.html">hotCoreTransport</a>
                            </li>
                    </ul>
                </div>
            </div>
            
            <div id="classes" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Classes</h2>
                </div>
                <div class="bd">
                    <ul>
                            <li><a href="../classes/hotCoreAuth.html">hotCoreAuth</a></li>
                            <li><a href="../classes/hotCoreAuth.facebook.html">hotCoreAuth.facebook</a></li>
                            <li><a href="../classes/hotCoreClientFiles.html">hotCoreClientFiles</a></li>
                            <li><a href="../classes/hotCoreMultiHome.html">hotCoreMultiHome</a></li>
                            <li><a href="../classes/hotCoreTransport.html">hotCoreTransport</a></li>
                    </ul>
                </div>
            </div>
            
            
            
            
            
            <div id="fileTree" class="sidebox">
                <div class="hd">
                    <h2 class="no-toc">Files</h2>
                </div>
                <div class="bd">
                    <ul><li>hotplate/<ul><li>node_modules/<ul><li>hotCoreAuth/<ul><li>lib/<ul><li>auth/<ul><li><a href="../files/hotplate_node_modules_hotCoreAuth_lib_auth_facebook.js.html">facebook.js</a></li></ul></li><li><a href="../files/hotplate_node_modules_hotCoreAuth_lib_hotCoreAuth.js.html">hotCoreAuth.js</a></li></ul></li></ul></li><li>hotCoreClientFiles/<ul><li>lib/<ul><li><a href="../files/hotplate_node_modules_hotCoreClientFiles_lib_hotCoreClientFiles.js.html">hotCoreClientFiles.js</a></li></ul></li></ul></li><li>hotCoreMultiHome/<ul><li>lib/<ul><li><a href="../files/hotplate_node_modules_hotCoreMultiHome_lib_hotCoreMultiHome.js.html">hotCoreMultiHome.js</a></li></ul></li></ul></li><li>hotCorePage/<ul><li>lib/<ul><li><a href="../files/hotplate_node_modules_hotCorePage_lib_Vars.js.html">Vars.js</a></li></ul></li></ul></li><li>hotCoreTransport/<ul><li>lib/<ul><li><a href="../files/hotplate_node_modules_hotCoreTransport_lib_hotCoreTransport.js.html">hotCoreTransport.js</a></li></ul></li></ul></li></ul></li></ul></li></ul>
                </div>
            </div>
            
        </div>

        <div id="main" class="yui3-u">
            <div class="content"><h4>hotplate/node_modules/hotCoreMultiHome/lib/hotCoreMultiHome.js</h4>

<pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
Provides multi-home abilities to Hotplate

This module&#x27;s aim is to make sure Hotplate has full multi-home abilities. The module itself:

* Defines all of the relevant stores ( &#x60;workspaces&#x60;, &#x60;workspacesUsers&#x60;, &#x60;usersWorkspaces&#x60;)
* Places important variables on the rendered page ( &#x60;vars.hotCoreMultiHome.enabled&#x60; and &#x60;.multiHomeURL&#x60;)
* Places the crucial &#x60;vars.hotCoreMultiHome.workspaceId&#x60; variable on the rendered page

However, given the nature of this module, there are _several_ other modules in Hotplate that interact with it.

## SUMMARY: modules that deal with multihome environments:

* hotCoreJsonRestStores -- it will broadcast comet messages only to workspace users
* hotCoreStoreConfig -- if the url has &#x60;:workspaceId&#x60;, it will set config stores&#x27; records in the page for that workspace
* hotDojoGlobals -- will set global variable workspaceId if it&#x27;s set within the page
* hotDojoStoreConfig -- will call &#x60;stores()&#x60; passing &#x60;userId&#x60; and &#x60;workspaceId&#x60; in resolution hash, allowing easy workspace-bound setting lists
* hotDojoAppContainer -- fully multi-home aware, will hook to correct URL and, if &#x60;:workspaceId&#x60; is in the URL, it will check that it exists.
* hotDojoAuth -- fully multi-home aware, providing a pick mechanism etc. Gets the workspace URL from &#x60;vars.hotCoreMultiHome.multiHomeURL&#x60; 

* hotDojoComet -- will add header &#x60;X-hotplate-workspaceId&#x60; to tab messages requests
* hotCoreComet -- will use &#x60;X-hotplate-workspaceId&#x60; to return updated config records for the expired workspace

A more detailed explanation of what each module does, in terms of interaction with hotCoreMultiHome, follows. Note that any interaction happens on the basis that &#x60;hotCoreMultiHome&#x60; is enabled.

## hotCoreJsonRestStores

* ./node_modules/hotCoreJsonRestStores/lib/hotCoreJsonRestStores.js

When broadcasting changes to stores via the hook &#x60;cometBroadcast&#x60;, it will change its behavious depending on multi-home being enabled or not.

If multiHome is enabled, checks if the record has a workspaceId field -- in which case, it will only broadcast the message to users in that workspaceId (it will do so by passing a &#x60;makeTabIdHash()&#x60; function to the &#x60;cometBroadcast&#x60; hook) 

## hotCoreStoreConfig

* ./node_modules/hotCoreStoreConfig/lib/hotCoreStoreConfig.js

Implements &#x60;pageElementsPerPage&#x60; that passes &#x60;params.workspaceId&#x60; to &#x60;getConfig()&#x60; -- which means that if the URL has the &#x60;workspaceId&#x60; parameter, it will add a variable with the workspace&#x27;s configuration to the page. It also passes &#x60;session.userId&#x60; to &#x60;getConfig()&#x60;, so if the user is logged in, it will return that user&#x27;s config too.

NOTE: &#x60;getConfig()&#x60; is implemented here. Signature: &#x60;function( workspaceId, userId, cb )&#x60;. It basically will return all configs with &#x60;workspaceId&#x60; and/or &#x60;userId&#x60; set in their &#x60;store.configStore&#x60; property

## hotDojoGlobals

* ./node_modules/hotDojoGlobals/client/globals.js

Sets the global variable &#x60;workspaceId&#x60; based on &#x60;vars.hotCoreMultiHome.workspaceId&#x60; (Unrelated: it also sets &#x60;userId&#x60; based in &#x60;vars.hotCoreAuth.userId&#x60;)

## hotDojoStoreConfig

* ./node_modules/hotDojoStoreConfig/client/ConfigVars.js

Config variables are bound to &quot;nothing&quot; (system-wide settings), to a user (user-wide settings), to a workspace (workspace-wide settings) or both (user-specific settings for a specific workspace). That&#x27;s why ConfigVars will call &#x60;stores()&#x60; passing &#x60;:userId&#x60; and :&#x60;workspaceId&#x60; in resolution hash.

Note that &#x60;:workspaceId&#x60; and &#x60;userId&#x60; are the ONLY parameters allowed in a config store URL.


## hotDojoAppContainer

* ./node_modules/hotDojoAppContainer/lib/hotDojoAppContainer.js

In terms of URLs, it will attach to &#x60;hotCoreMultiHome.multiHomeURL&#x60; or &#x60;hotCoreAuth.appURL&#x60; depending on multi-home being enabled or not. Also, IF &#x60;:workspaceId&#x60; is in the URL as a parameter, it will check that the workspace actually exists or it will return an error.

## hotDojoAuth

* ./node_modules/hotDojoAuth/lib/hotDojoAuth.js

The pagePick callback is there just for multi-home environments, picking the workspace

* ./node_modules/hotDojoAuth/client/NewWorkspace.js

After adding a new workspace, it will redirect to it thanks to &#x60;vars.hotCoreMultiHome.multiHomeURL&#x60; (replacing &#x60;:workspaceId&#x60; with the id of the record that was just created) 

* ./node_modules/hotDojoAuth/client/Pick.js

After picking a workspace, it will redirect to it thanks to &#x60;vars.hotCoreMultiHome.multiHomeURL&#x60; as above

* ./node_modules/hotDojoStoreConfig/client/ConfigVars.js

## hotDojoComet

* ./node_modules/hotDojoComet/client/messages.js

It adds a header &#x60;X-hotplate-workspaceId&#x60; to tabId requests. This is ESSENTIAL so that hotCoreComet knows which workspaceId the tab belongs to. Yes, IT NEEDS to know it: if the tab is not found or it&#x27;s expired, hotCoreComet will return only one message, &#x60;resetStores&#x60;, which will INCLUDE all configuration records for that user and workspace (in order to save GETs and implement error management app-side).

## hotCoreComet

* ./node_modules/hotCoreComet/lib/hotCoreComet.js

Uses the header &#x60;X-hotplate-workspaceId&#x60; to return the config stores&#x27; records for that &#x60;workspaceId&#x60; in case the tab is expired or not there

@module hotCoreMultiHome
@main hotCoreMultiHome
@class hotCoreMultiHome
@static
*/

var dummy
  , hotplate = require(&#x27;hotplate&#x27;)

  , declare = require(&#x27;simpledeclare&#x27;)
  , JsonRestStore = require(&#x27;jsonreststores&#x27;)
  , SimpleSchema = require(&#x27;simpleschema&#x27;)

  , hotCoreJsonRestStores = require( &#x27;hotCoreJsonRestStores&#x27; )
  , hotCoreStoreRegistry = require( &#x27;hotCoreStoreRegistry&#x27; )
  , debug = require(&#x27;debug&#x27;)(&#x27;hotplate:hotCoreMultiHome&#x27;)
;

var stores = {};

// Some sane defaults

// Multihome enabled
hotplate.config.set(&#x27;hotCoreMultiHome&#x27;, {
   enabled: true,
   multiHomeURL: &#x27;/wssssssssssssssssssss/:workspaceId&#x27;, // MUST contain :workspaceId
   escapePick: true,
});




/*
  * IF workspaceId is there: return list of tabs belonging to users in that workspace
  * ELSE: return list of tabs belonging to users in workspaces common to requesting userId
  * 
*/
exports.makeTabIdHashForMultihome = function( userId, tabId, message, done ){

  var tabIdHash = {};

  debug(&quot;In makeTabIdHashForMultihome!&quot;, tabId );

  hotCoreStoreRegistry.getAllStores( function( err, allStores ){

    if( err ){
       next( err );
    } else {

      if( typeof(  allStores[ message.storeName ] ) === &#x27;undefined&#x27; ){
        debug(&quot;The message is for an undefined store, skipping comet broadcast: &quot; , message );
        done( null, {} );
        return;
      };

      // Get a list of all tabs
      allStores.tabs.dbLayer.selectByHash( { },function( err, tabs ){
        if( err ){
          done( err );
        } else {

          
          debug(&quot;TABS: &quot; , tabs );

          var hotGlobalBroadcast = allStores[ message.storeName ].hotGlobalBroadcast;

          // CASE #1

          // Global broadcast required: sending it to _every_ tab!

          if( hotGlobalBroadcast ){
            debug(&quot;Global broadcast required! &quot; );

            tabs.forEach( function( tab ){
              if( tab.id != tabId ) tabIdHash[ tab.id ] = true;
            });

            debug(&quot;TABS HASH: &quot; , tabIdHash );
            done( null, tabIdHash );
          } 

          // CASE #2

          // The record HAS a workspaceId: send it to all tabs of users belonging
          // to that specific workspaceId
          else if( typeof( message.target.workspaceId ) !== &#x27;undefined&#x27; ){
          
            debug(&quot;YES workspaceId&quot;  );
 
            var uids = {};

            // Get a list of users for that workspace
            allStores.workspacesUsersBase.dbLayer.selectByHash( { conditions: { workspaceId: message.target.workspaceId } }, { children: true }, function( err, workspacesUsers ){

              if( err ) return cb( err );
              workspacesUsers.forEach( function( wu ){
                uids[ wu.userId ] = true;
              });
              
              // Add to tabIdHash any tab that belongs to a &quot;good&quot; user
              tabs.forEach( function( t ){ if( uids[ t.userId ] &amp;&amp; t.id != tabId ) tabIdHash[ t.id ] = true; });

              debug(&quot;TABS HASH: &quot; , tabIdHash );

              // That&#x27;s it!
              done( null, tabIdHash );

            });

          // CASE #3

          // The record DOESN&#x27;T HAVE a workspaceId: send it to all tabs of users
          // who are in the same workspace as userId
          } else {

            debug(&quot;NO workspaceId&quot;  );

            var uids = {};


            // CAVEAT 3a: it doesn&#x27;t have a userId set. This means that this is a server-generated
            // message (no user) on a record without workspace. It will necessarily need to spam
            // all users about the change
            //
            if( userId == null ){
              debug(&quot;No userId (server-generated Json op) and no workspaceId, will broadcast&quot; );

              tabs.forEach( function( tab ){
                if( tab.id != tabId ) tabIdHash[ tab.id ] = true;
              });

              debug(&quot;TABS HASH: &quot; , tabIdHash );
              return done( null, tabIdHash );
            }

            // Get a list of workspaces for the requesting user
            allStores.workspacesUsersBase.dbLayer.selectByHash( { conditions: { userId: userId } }, { children: true }, function( err, workspacesUsers ){
              if( err ) return done( err );

              debug(&quot;Workspaces for user &quot;, userId,&quot;: &quot;, workspacesUsers );

              workspacesUsers.forEach( function( w ){
                  
                // Get a list of users for that workspace
                allStores.workspacesUsersBase.dbLayer.selectByHash( { conditions: { workspaceId: w.workspaceId } }, { children: true }, function( err, workspacesUsers ){
                  if( err ) return done( err );

                  debug(&quot;Users in workspace &quot;, w.id, &quot;: &quot; , workspacesUsers );

                  workspacesUsers.forEach( function( u ){
                    
                    debug(&quot;ADDING UID: &quot; , w.userId );
                    uids[ u.userId ] = true;
                  });
                  debug(&quot;UIDS: &quot; , uids );

                  // Add to tabIdHash any tab that belongs to a &quot;good&quot; user
                  tabs.forEach( function( t ){
                    if( uids[ t.userId ] &amp;&amp; t.id != tabId ) tabIdHash[ t.id ] = true; 
                  });

                  debug(&quot;TABS HASH: &quot; , tabIdHash );

                  done( null, tabIdHash );

                });
              });

            });
          }
        }
      });
    }
  });
}


var userInWorkspace = exports.userInWorkspace = function( userId, workspaceId, done ){

  stores.workspacesUsersBase.dbLayer.selectByHash( { conditions: { userId: userId, workspaceId: workspaceId } }, { children: true }, function( err, docs ){
    if( err ){
      done( err );
    } else {
      done( null, docs.length );
    }
  });

}


/*
  IN SHORT:
  * ALWAYS: User must belong to workspace (workspaceId is checked)
  * To WRITE (putExisting, putNew, post, delete), userId needs to match logged in user
*/
exports.MultiHomeBasicPermissionsMixin = declare( Object, {

  _checkWorkspaceId: function( request, cb ){
    var self = this;
 
    // User is not logged in: fail
    if( ! request.session.userId ) return cb( new self.UnauthorizedError() );

    // The request doesn&#x27;t include a workspaceId: pass it through (nothing to compare against)
    if( ! request.params.workspaceId ) return cb( null, true );

    // workspaceId is different to session&#x27;s: fail
    userInWorkspace( request.session.userId, request.params.workspaceId, function( err, there ){
      if( ! there ){
        cb( null, false );
      } else {
        cb( null, true );
      }
    });
  },

  _checkUserIdMultiHome: function( request, cb ){
    var self = this;
    // User is not logged in: fail

    if( ! request.session.userId ) return cb( new self.UnauthorizedError() );

    // The request doesn&#x27;t include a userId: pass it through (nothing to compare against)
    if( ! request.params.userId ) return cb( null, true );

    // userId is different to session&#x27;s: fail
    if( request.params.userId.toString() !== request.session.userId.toString() ){
      return cb( null, false );
    }

    // Any other cases: pass
    cb( null, true );        
  },

  _checkWorkspaceIdAndUserId: function( request, cb ){
    var self = this;

    self._checkWorkspaceId( request, function( err, res ){
      if( err ) return cb( err );
      if( ! res ) return cb( null, false );

      self._checkUserIdMultiHome( request, function( err, res ){
        if( err ) return cb( err );
        cb( null, res );
      });
    });
  },

  checkPermissions: function f( request, method, cb ){
    var self = this;

    this.inheritedAsync( f, arguments, function( err, res ){
      if( err ) return cb( err );
      if( ! res ) return cb( null, false );

      // For query methods, just check that the workspace matches
      // For writing methods, check that user id also matches
      switch( method ){
        case &#x27;getQuery&#x27;:
        case &#x27;get&#x27;:
          self._checkWorkspaceId( request, cb );
        break;

        default:
          self._checkWorkspaceIdAndUserId( request, cb );
        break;

      }

    });
  },

});


hotplate.hotEvents.onCollect( &#x27;stores&#x27;, &#x27;hotCoreMultiHome&#x27;, hotplate.cachable( function( done ){


  hotCoreJsonRestStores.get( function( err, s ){
    if( err ){
      done( err );
    } else {

      var HotStore = s.HotStore;
      var HotSchema = s.HotSchema;

      // ***********************************
      // *** WORKSPACES ********************
      // ***********************************

      var Workspaces = declare( HotStore, {

        schema: new HotSchema({
          workspaceName: { type: &#x27;string&#x27;, required: true, notEmpty: true, trim: 128, searchable: true,
                           sharedValidator: &#x27;workspaceValidator&#x27; },
          ownerUserId:   { type: &#x27;id&#x27; }, 
        }),

        storeName:  &#x27;workspaces&#x27;,

        publicURL: &#x27;/workspaces/:id&#x27;,
        hotExpose: true,

        handlePost: true,
        checkPermissions: function( request, method, cb ){

          // Only &#x27;post&#x27; considered
          if( method !== &#x27;post&#x27; ) return cb( null, true );

          // User needs to be logged in
          if( ! request.session.userId ) return cb( null, false );
     
          // Make sure that body.ownerUserId IS indeed SET as the logged in user
          request.body.ownerUserId = request.session.userId;

          cb( null, true );
        },

        // If creating a new workspace, and the user is logged in, then
        // assign the creating user to that workspace
        afterEverything: function f( request, method, cb ){

          // IN hotCoreMultiHome
          this.inheritedAsync( f, arguments, function( err ){
            if( err ) return cb( null );

            // Will only work with &#x27;post&#x27;
            if( method !== &#x27;post&#x27; ) return cb( null, true );

            if( request.remote &amp;&amp; request.session.loggedIn ){
              var userId = request.session.userId;
              if( userId ){

                 stores.workspacesUsers.apiPost( { userId: userId, workspaceId: request.data.doc.id }, cb );
              } else {
                cb( null );
              }
            }
          });
        },

      });
      stores.workspaces = new Workspaces();


/*
  var WorkspaceInvites = exports.WorkspaceInvites = declare( HotStore, {

    schema: new HotSchema({
      inviteCode:  { type: &#x27;blob&#x27; },
      email     :  { type: &#x27;blob&#x27; },
      name      :  { type: &#x27;blob&#x27; },
    }),

    handlePost: true,
    handleGet: true,
    handleGetQuery: true,
    handleDelete: true,

    storeName:  &#x27;workspaceInvites&#x27;,
    paramIds: [ &#x27;workspaceId&#x27;, &#x27;id&#x27; ],
    publicURL: &#x27;/workspaces/:workspaceId/invites/:id&#x27;,
  });
*/


      // The basic schema for the WorkspacesUsers table
      var WorkspacesUsersBase = declare( HotStore, {

        schema: new HotSchema({

          id         : { type: &#x27;id&#x27;, searchable: true },
          userId     : { type: &#x27;id&#x27;, searchable: true },
          workspaceId: { type: &#x27;id&#x27;, searchable: true },
        }),

        onlineSearchSchema: new HotSchema({
        }),

        storeName: &#x27;workspacesUsersBase&#x27;,
        collectionName: &#x27;workspacesUsers&#x27;,

        nested: [
          {
            type: &#x27;lookup&#x27;,
            localField: &#x27;workspaceId&#x27;,
            store: &#x27;workspaces&#x27;,
            //layerField: &#x27;id&#x27;
          }
        ],

        idProperty: &#x27;id&#x27;,

      });
      stores.workspacesUsersBase = new WorkspacesUsersBase();

      var WorkspacesUsers = declare( WorkspacesUsersBase, {

        storeName:  &#x27;workspacesUsers&#x27;,
        collectionName: &#x27;workspacesUsers&#x27;,

        publicURL: &#x27;/workspaces/:workspaceId/users/:id&#x27;,
        hotExpose: true,

        handleGetQuery: true,

        alsoNotify: [ &#x27;usersWorkspaces&#x27;],

        checkPermissions: function( request, method, cb ){

          // Will only filter out getQuery
          if( method !== &#x27;getQuery&#x27; ) return cb( null, true );

          userInWorkspace( request.session.userId, request.params.workspaceId, cb );
        },

      });
      stores.workspacesUsers = new WorkspacesUsers();

      var UsersWorkspaces = declare( WorkspacesUsersBase, {

        storeName:  &#x27;usersWorkspaces&#x27;,
        collectionName: &#x27;workspacesUsers&#x27;,

        publicURL: &#x27;/users/:userId/workspaces/:id&#x27;,
        hotExpose: true,

        handleGetQuery: true,
        checkPermissions: function( request, method, cb ){

          // Will only filter out getQuery
          if( method !== &#x27;getQuery&#x27; ) return cb( null, true );

          // Only their own workspaces
          if( request.session.userId != request.params.userId ) return cb( null, false );

          cb( null, true );
        },

        alsoNotify: [ &#x27;workspacesUsers&#x27;],

      });
      stores.usersWorkspaces = new UsersWorkspaces();

      done( null,  stores );

    }
  })


}));



// Place relevant config variables on the rendered page
hotplate.hotEvents.onCollect( &#x27;pageElements&#x27;, &#x27;hotCoreMultiHome&#x27;, function( done ){

  done( null, {
    vars:  [
             { name: &#x27;enabled&#x27;,      value: hotplate.config.get(&#x27;hotCoreMultiHome.enabled&#x27;) },
             { name: &#x27;multiHomeURL&#x27;, value: hotplate.config.get(&#x27;hotCoreMultiHome.multiHomeURL&#x27;) },
           ],
  });
});

// Place workspaceId on the rendered page
hotplate.hotEvents.onCollect( &#x27;pageElementsPerPage&#x27;, &#x27;hotCoreMultiHome&#x27;, function( req, pageName, done ){

  var vars = [];

  // Add the user ID to the page as a variable
  if( req.params.workspaceId ){
    vars.push( { name: &#x27;workspaceId&#x27;, value: req.params.workspaceId } );
  }

  done( null, {
    vars: vars
  });

});


</pre>

</div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/js/tabs.js"></script>
</body>
</html>
