FROM:
=====
Widget  with parameters:
messageId (obj)
contactId (obj)
=>
if contactId:
  * contactId 
if !contactId:
  * Select...
* Link email to another existing contact (contact picker)
* Link email to a new contact (create contact, add email address, take person there)
* Another contact with matching email address 1, != contactId
* Another contact with matching email address 2, != contactId
* Another contact with matching email address 3, != contactId

When selection, save to messageId on one-field table with fromContactId.
Check that change propagages properly to other tabs

TO:
===
Widget with parameters:
messageToId
contactId
=>
* ContactId (if contactId)
* Assign contact... (only internal users)

  "HOTPLATE RELOADED"
    [ ] Fix JsonRestStores with new DB Layer API, make dstore filter, make everything work
    [ ] Move Dojo itself into a module called hotClientLibDojo. Add other hotCLientLibDojo (all they do is include those JSes)
    [ ] Move all Dojo files in ONE BIG Hotplate module hotClientBridgeDojo (eventually, hotClientBridgeAngular, hotClientBridgeBackbone, hotClientBridgeAmber, hotClientBridgeKnockout)
    [ ] Create a "pure javascript" layer called "hotClientBridge" that handles messages, events, anything
    [ ] Change Dojo layer to use the hotClientBridge for features implemented there
    [ ] Maybe see if it makes sense to write Dojo mixin to make templating easier using published schema (it would be just. so. good.)

    [ ] Move all documentation to JsDoc, make sure hotplatejs' web site still works
    [ ] Write documentation for hotplate's server modules
    [ ] Write blueprint documentation for client modules

  "MESSAGES"
    
    [ ] GUI: THE BOX
      [X] Move "new message" form out of the top of the contacts info, make a button instead
      [X] Make sure that only the right tabs actually come out. For now, if empty leave blank (intnl msgs later)
      [X] Change form so that the contactId is a dropdown of all emails/ph numbers for the person

      *
      [X] Rename variables/styles to sane "to", "cc" so that it makes sense for one message or several
      [X] Redo WorkspacesMessagesTo so that it's ONE widget, which will deal with SMSes and ph numbers
      [X] Apply same drop-down changes to email
      [X] Fix CSS for email and SMS sending, completely gone by restructuring things

      **
      [X] Switch to Dgrid (NOT List!) to make a messages widget
      [X] Format "From" properly, maybe rendered from server?
      [X] Format "To" properly, maybe rendered from server?
      [X] Format "Date" like Google does it
      [X] Use common validators server-side as well
      [X] Format "Body" so that it has the subject + some of the body text in text mode
      [X] Attempt to find the beginning of the message AFTER quoting, maybe convert to text from server?
      [X] Fix problems with field validation, needs to allow empty "to" in messages, only puke in remote
      [X] Fix error, id in subject is wrong, needs to be the userId logged in
      [X] Fix bug where inbound SMSes simply don't happen

      *
      [X] Implement in smsManager.js: // TODO:  silent attempt to delete workspaceMessage
      [X] Show if message is an email or a text
      [X] Write skeleton of ViewingWidget, deciding on design

      *
      [X] Write initial version of email viewing widget based on new ViewingWidget
      [X] Fix viewing widget so that it works with message viewing widget

      *
      [X] Rename smsManager.js, check line 293, map exactly what's added in terms of text and HTML
      [X] Uniform bodyHtml and BodyText across application

      *
      [X] Make sure email is quoted-printable decoded
      [X] Complete message viewing widget, so that it looks OK
      
      *
      [X] Finish off email viewer: 
          [X] scroll only contents, not head
          [X] Take subject out if not present
          [X] Add spans to from
          [X] Have "via" only for computed ones
          [X] Have editing widgets for FROM and TO

      *
      [X] Get rid of computedFrom/computedTo, use incoming instead
      [X] Figure out why workspacesMessages records have bodyHtml, bodyText etc. empty
      
      *
      [ ] Assign contact widget
        [ ] Write link to new contact
          [ ] Update contact form so that you can add email addresses instantaneously
          [ ] Parse email address, add new contact with the address, show the editing form
        [ ] Write picker for link to existing contact
        [ ] Use same picker, with search already activated, for the picker above


      [ ] For incoming, make it possible to change contactId for messageTo[0] (make log entry)
      
      [ ] Place widget to change messageTo[0] in the main inbox, it's always useful there (first 24h)

      *
      [ ] For putNew, make sure that 'protected' fields are copied over from existing record
      [ ] Add security to server-side: only contactId can change in PUT for workspacesMessages

      *
      [ ] Place inbox in "Inbox" tab displaying only ones in `inInbox`, add `inInbox` attribute first (!)
      [ ] Add tab to "Inbox" for "archived", "All" messages (same widget, with extra option)
      [ ] Make it possible to archive messages 

      *
      [ ] Make it possible to reply to messages (include original, include subject) from list and single view
     
      **
      [ ] Make it possible to see each recipient's status for outcoung messages
      [ ] Make it possible to see logs for specific recipients
      [ ] Make it possible to see logs for full messages

      **
      [ ] Allow messages to be marked as read for specific contactIds, display bold if unread
      [ ] Allow to mark messages as unread

      *
      [ ] Implement "Internal messages" (messages sent with "inInbox" marked as false and 'outgoing' as true)

      **
      [ ] Add ability to display, download attachments, dealing with un-downloaded ones
      [ ] Make 1:n relationship between workspacesMessages and messagesAttchments
      [ ] Make ABSOLUTE sure attachment data is not downloaded when getting messages (too much info)

      *
      [ ] Implement basic search in messages


[LATER]
      *
      [ ] Add cache to the toAsString field, zap cache when a message has matching contactTo
      [ ] Make sure validation bubbles don't stay after closing dialog
      [ ] Improve look of table, icons


  ----------------------
  DEADLINE: 28 Feb 2014
  ----------------------

  "USERS AND INVITES"

  * Write an "invite user" mechanism where users can be invited into the system: they receive an email, will redirect to a screen
    which allows them to register a new user (if available, etc.) or link the workspace to their existing user.
    TO DO THIS, I can definitely get away with just 1) Adding a page that adds a session variable 1a) Redirect to the
    normal welcome page 2) Adding a hook to register and login, so that if that session variable is set, the created user will be
    added to that workspace (usersWorkspaces store)

  "WORKSPACE MANAGEMENT"

  * Add a "user management" section in settings for workspace Admins only
    - Detach/attach user from contactId by inviting

* Write a "log browser" for workspace owners and for God to see what happened, with filters
  
  ---------------------
  DEADLINE: 10 Mar 2014
  ---------------------

[LATER]
"PERMISSIONS"
  * Decide on permissions/permissions model, maybe follow Drupal's
  * Write a God permission mixin, apply to root-level stores (or everybody can write on them)
  * Make God application separate, with separate login (only God can login)

  ---------------------
  DEADLINE: 10 Dec 2014
  ---------------------

[LATER]
"GET PAID!"
  * Add accounting for SMSes: add credit, check credit before sending, check credit in queue
  * Add way to get paid and add credit (Paypal, or more likely Stripe, better API)

  ---------------------
  DEADLINE: 20 Dec 2014
  ---------------------

[LATER]
"FINAL TOUCHES"
  * Have a look at hotDojoWidgets/lib/hotDojoWidgets.js, image in head will appear, might be good for the app
  * Make simple tabbed wizard to setup smtp and imap, with credential real-time check

  ---------------------
  DEADLINE: 30 Dec 2014
  ---------------------

  "BOOKINGS"

  * Make a "booking": an abstract entity that can be owned by a contact and that has a name
  * When an email or SMS comes in, ability to match it to a booking
  ** Ability to have messages under a specific booking, setting it in the "New Message" screen
  ** Implement simple TODO list for the bookings, date/time from, date/time to, who
  ** Add calendar (Dojox's), rendering TODO items

  ---------------------
  DEADLINE: 15 Jan 2015
  ---------------------

  "CONTACTS -- INTEGRATION"

[LATER]
  * Add G+ authentication
  **** Allow to sync contacts with Facebook
  **** Allow to sync contacts with G+
  * Add buttons to re-sync all contacts from specified modules

[LATER]
  "BEAUTIFY AND FINAL TOUCHES"

  * Work on CSS, make app look better with minimal intervention
    AND:
  * Do all those things that can be done during beautification
    * Write function to run _completeRecord on each record of a collection, add it to simpleDbLayer
    * Full code audit
    * Full client-validation audit
    * Write web site text
    * Test drive possible usage

  ---------------------
  DEADLINE: 31 Jan 2015
  ---------------------

                         --------------------------------------
                          TONY, FINISH ALL THIS BY JANUARY!!!
                         --------------------------------------
  "ADVANCED BOOKINGS"

  * Ability to set available "activities" for a contact and all contacts, with cost
  * product, money lines: [ booking owner | line owner | office ] OWES (min, max price) [ booking owner | line owner | office ] / qty
    where qty can be "each", hourly, daily, with min units and unitsMultipleOf
  * Ability to match activities (with dates) for a contact in a booking, render them in the calendar

  "ACCOUNTING"

  * Accounting summaries for each booking (with system-calculated ones)
  * Interface with payment system allowing workspaces to get paid
  * Ability to send invoices
  * Ability to _store_ received invoices

  "ADVANCED MESSAGES AND TEMPLATES"

  * Ability to set "presence types" (dancer, security, paying guest) -- presentational only
  * Ability to send messages to different present types (all types in a booking)
  * Ability to set templates for messages of different types, with instant previews

[LATER]
  "LONGER TERM"
  * Add schema to static page, use schema for basic validation
  * Update JsonRestStores and querying so that "useRangeHeaders: true" and sortBy are no longer necessary
  * Use SOCKJS for instand messanging instead of polling (dealing with authentication and reconnection)
  * Replace any non-widget dojo with custom ones (mainly aspect, topic, signals)
  * Take out Dojo layout widget for straight/WebComponent/Polymer ones
  * Incorporate Mayhem for routing, stores, templates
  * (When it even exists) switch to a widget library based on Polymer/web components, use it via Mayhem

[LATER]
 LATER (hopefully other contributors)
  ------------------------------------
  * StoreSelect: add a way to go back to initial value even if it's no longer in select
  * StoreSelect: add network resiliance
  * Make sure that everything is blind-friendly
  * Allow country selection for phone number from a select box (straight, Dojo's?)


  DONE:
  * Password1 and password2, fields, make dependent on each other
  * Understand, fully, the whole "events" on widgets and Dge nodes http://livedocs.dojotoolkit.org/quickstart/events
  * Add a busybutton -- Look into dojox/widgets/standby and forms/busybutton
  * Check things with server, make sure server can respond with form setting error messages
  * Understand _fully_ the whole promise thing in Dojo
  * Write functions for server (sending errors) to keep things dry
  * Initial data saving with MongoDB
  * Write async code to save everything, MAYBE using Async library https://github.com/caolan/async#series (niiice!)
  * Actually create account/workspace with MongoDB
  * CLIENT: Fix forms, as it turns out we don't really geed labels (not possible, I was dreaming)
  * Validation/error manager framework:
  -- Change client so that it shows which fields had what problem from the server adding validators on the fly
  -- CLIENT: Add a xhr function for client (making request, writing a message) to keep things dry. Do it with promises and new Form
  -- CLIENT: Make sure that the busybutton itself cancels itself if the form doesn't validate _somehow_
  -- CLIENT: Finish the new warning bar!
  -- CLIENT: Make error printing MUCH nicer than a bloody alert() using the new great bar!
  -- CLIENT: Simplify IFs so that it only needs to cancel if it didn't validate, and do anything if it worked OK. Errors
             and messages handled by generic function 
  -- C/S   : Complete the validation server-side and client-size properly (use the same validators as client side!)
  --SERVER: Make up log library to log ANYTHING with Workspace as a key (not just errors). Log ALL activity
  --CLIENT: Enable logging of all activity with Console.log (to be turned on, so wrap console.log in function)
    +++ THE INTERACTION GALORE (2 days)
  --CLIENT: Create initial Models on the client side for Mongo's data ('workspace')
  --CLIENT: Write more Models for future use/reference (won't work until implemented on server)
    CLIENT: Change COMPLETELY the logic for forms. Make stores "NewWorkspaces" and "NewWorkspacesAsUser" 
  --SERVER: Write function part on server for workspace and username checking (store: "Workspaces" which only works with the
            right filter).
  --CLIENT: Actually check workspace names and user names using AJAX on the client side (don't allow submit if duplicate)
  * SERVER: Reinstall Express, work out what's in the "-s" field (see differences with and without) AND check that app still runs
  * SERVER: Have a look at the middleware used to refresh your memory a little
  * SERVER: Configure a store with Mongodb
  * SERVER: Get familiar with sessions
  * C/S   : Set "logged in variable" when login is successful (store password unencrypted for now)
  * CLIENT: Slim up the submit function, avoid ANY code repetition that is not 100% strictly necessary
  * CLIENT: Write a basic empty applicationwith a simple button to interact with server
  * C/S   : Restructure the whole directory tree so that it makes a lot more sense and can use Dojo 1.8 as a library
  * C/S   : Add logout button to the app and to the server and to the application (make widget), so that we can test things out
  * C/S   : Change app so that if a request is made and response is "unauthorised", asks for login 3 times and after that redirects to login
  * CLIENT: Make sure logging in will _actually_ direct to the app
  * CLIENT: Decide how to store the login name client-side, get client to re-send it
  * C/S   : Change app so that if you are not logged in it will send TO login screen (redirect straight from the jade page)
  * CLIENT: Change login form so that if the user is already set, it will not ask for it again (and option to change user)
  * SERVER: Put the login/logout/register pages (non-data ones) in a separate module
  * C/S   : Add a proper button that does something to test the "session expires" thing to test things properly
  * C/S   : Change the "register" page so that if you are logged in, it redirects to the login page
  * C/S   : Change register form so that if user is already logged in it only asks for the workspace name
- * C/S   : In case user already is logged in, register form should have an info box and explain that they are already logged in and
            the workspace will be registered under their username, providing a logout link too.
  * CLIENT: In case user is not logged in, warn users that if they already are customers, they should login so that
            the workspace will fall under their existing username (with link to a login page)
            * The app URL must always have /workspacename at the end
  * C/S     Do things so that the workspace ID is part of the URL, and not the workspace name, so that URLs stay forever even
            if workspace name changes
  * C/S     Make sure that the workspace name can be appended to the login screen, and that users are automatically redirected there if
            login has worked and user has access to it. To do this, get the login screen to be there with workspaceId set as a variable
            if present, and get the login routine to check if that is available.
  * C/S     Change login screen so that if you login and have only one workspace, redirects there; if you have several workspaces, don't
            redirect: pull out a list of workspaces instead, and let user pick (open them in a new window)
  * CLIENT: Make LoginForm functional, needs to find out the workspace to redirect to from the URL bar using a path
  * SERVER: Finish (write) the picker
  * CLIENT: Add roundForm classes to CSS so that notFound and "error" don't have the loginForm class (silly)
  * CLIENT: Make picker way prettier, 
  * SERVER: Fix problem where if user is logged in, and creates a workspace, he is not added to the permissions (DB changed)
  * SERVER: Change req.XXXX set by workspaceName and workspaceId tokens so that they are under "app", to keep namespace clean
            grep 'req\.[^sbqu]' `find .` Note: change workspaceId's parameter string into workspaceIdPages 
  * SERVER: Tidy up code for middleware, put it in a different file.
  * SERVER: Get TOKENS (rename "key" in db and code) actually created when a user is added.
  * SERVER: Set the token as a global variable in the ws page. The key is worked out by User (from Session) + Workspace id (from page)
  * CLIENT: Change JsonRest call in client so that it automatically appends, to call URL, the key from the global variable
  * C/S   : Revise all code, make sure that names of stores are consistent, place pages under /pages/login, pages/register etc,
            change the store names
  * C/S   : On the server side, a middleware will read the token from URL and set req.application.workspaceId and req.application.userId:
            If the middleware finds that the user is not logged in, needs to return the right 4xx error.
  * SERVER: Check that middleware tokenApi actually works (check by getting Javascript to provide the wrong API key).
  * CLIENT: Hide passwords
  * SERVER: Rename error objects so that make more sense, _and_ make sure that original error is kept in case of "Runtime error".
  * SERVER: Improve the Log() function so that IT does all the work (lookup etc.) and stores things right
  * C/S   : Since 403 is for "user is not logged in", return a different error in case the user IS logged in but has no access to
            the url requested. (It shouldn't happen, and it will only really happen when a permission change happens while the
            user is using the application).
  * SERVER: Find a _good_ way to keep the original error when throwing messages in db errors, maybe providing info to the user? Check
            logging too -- check that logging is happening properly (sent email to stack overflow)
  * SERVER: Uniform the way things are set, into req.application, regardless of what middleware is called
            
  * SERVER: Check logging, and Check that things haven't bombed after latest extensive changes, and that logging still happens OK.
  * C/S   : Revise "protocol", make it a lot better and nicer so that the response is always, always the same (and extra "things" can
            be sent to the app in terms of what to refresh, for example). MAKE SURE THAT IT'S ALWAYS THE SAME FORMAT FOR EVERY ERROR
  * CLIENT: Fix password so that it's not "mustChange" in login form (user might decide to change username and not password)
  * SERVER: Change the login scheme completely. The client mustn't send the token for each call, but simply "session" (as an option). On
            the server, the "session" needs to go by workspace. So, when token is "session", setting of variables will depend on
            the session rather than the passed token. (the "login" request makes sense)
  * SERVER: Make a middleware that requires the person to be logged in  (silly idea)
  * SERVER: Understand how the error management works, discovered that throw(err) is the very same as next(err) for the catch{} there
  * SERVER: Change page middleware so that it redirects automatically, without getting the actual routes methods to do it
  * SERVER: Write a middleware for the ID
  * SERVER: Implement logging in case of server problems when delivering pages (add logging calls manually where needed?)
  * SERVER: [NOT DONE] Write a function to check if a user has access to a specific workspace, use that instead of current find() in 3 spots
  * SERVER: Fixed IDIOTIC way I used to give access to workspaces, based on used name rather than ids.
  * SERVER: Major, major reorganisation of the code, errors are now in their own little files, etc.
  * Fixed order of things, so that it makes more sense. This framework is bigger than I expected, will I ever get to write
    the _actual_ booking system I wanted to write? I am amazed something like this didn't exist already
  * SERVER: Made sessions persistent using connect-mongod, fixed a silly bug in the creation of the stores client-side (left from testing)
  * SERVER: Added the first query call
  * CLIENT: Improved the code in _AjaxValidatorMixin.js so that it can work both if search is good or not, improved that code in the meantime
  * Write a module loader which will load all modules in a specific directory and run init(), as well as create a list of
    loaded modules
  * Move the existing calls into a module called "system"
  * Create system so that modules have a public directory
  * Make sure that the application runs some init() method javascript-side as well, so that modules can add their widgets to the app
  * Empty root directory completely (including errors.js etc.), turn it into a straight Express server with modules
  * Write a hook system, server and client side, where other modules can listen and "enrich" each other's objects, forms, etc.
  * Write a topic/publish system, server side, where things can happen
  * Add function to add fields that will be logged by the logger, defining them as "indexes" or not. (This will be used to
    make up the schema on the spot by the mongologger)
  * Add ability to register a module later (change the load function so that it calls register, and then
    make sure that the template is recalculated after the registration for that particular module so that
    JS and CSSes are added). Also, see if it's possible to make file loading work as well (!), this will require
    one middleware call per module). This way, people can use *any* module to integrate with hotplate -- the modules will
    just need to provide the right hooks
  * Put core modules into a "core" directory somehow (revise the way modules are loaded, allow two stage loading and THEN init() )
  * Write dependency system so that init() methods are called in the right order
  * Port "hotDojoError" so that it uses the new globalAlertBar
  * Make application work "as is" (making it use the new hotDojoError and stores etc. )
  * Make sure hooks are called asynchronously so that hooks can be used within callbacks
  * Add function to log to console if turned on (add it to logger), put log messages using that from now on
  * Add function invokeAllFlattened, which gets all results from an invokeAll and flattens them onto an array, to be used for thinks
    like roles etc.
  * Write a topic/publish system, client side, where clients can change other client's forms, templates etc. before they get
    sent to the client. For example, another mixin to _templatedMixin which calls hotplate's hooks?
  * C/S   : Make sure that workspace names are registered as lowercase, AND that searching them is case insensitive!
  * SERVER: Make sure that all servers calls don't BOMB if parameters are not passed (use custom function)
  * SERVER: Set an expiration time to the login, check that it can be "since last communication" (add flag?)
  * CLIENT: Fix problem where field with focus lose manually added tooltip straight away. It's making "wrong password" disappear.
  * C/S   : Encrypt passwords using strong encryption
  * Check for "styles" in templates, and "height", make sure that widgets don't have useless parameters
  * DECIDE IF dojoAppContainer SHOULD BE LEFT LIKE THIS, GENERIC, OR NOT (CONTAINER Vs. BOILERPLATE)
    In the end, it's a generic container publishing a topic with its object, so that others can piggyback
  * SERVER: Create generic function to parse the query launched by JsonRest queries (filter, range) use it for logs
  * CLIENT: Show a bunch of records (grid, etc.) using the data stores. Make sure there is proper error recovery with
            reload if there are network issues. 
  * SERVER: Write a "Dashboard" page for the "system" workspace, with a tab that displays logs (filter by time, user, workspace, gravity)
            Improve logging accordingly (now that you can see them...)
  * Write utility functions to copy data taken from a JsonRest query into a form -- UNNECESSARY!
  * Write an overlay widget which will be placed over a form if initialisation goes wrong. Allow user to click to try again
  * Make app look a little nicer (login button, small avatar, at the top, etc.)
  * Add the overlay widget to Dgrids as well, allowing users to re-load the dgrid if connection goes down. That was fun, discovering that
    dgrid isn't _actually_ a widget and adapting the hell out of _OvelayMixin...
  * Write basic "Workspace settings" (generic Workspace Settings table)
  * Write generic function to find one and save
  * Write basic "Workspace-User settings" (user's settings for that specific workspace). Make fields part of DojoAuth's tables? (Hooks for that)
  * Strenghten existing forms in bd.js (add parametersAreThere as general functions from hotDojoAuth), validate email
  * Write basic "User settings" (General user-wide settings) and show name of logged in user at the top
  * Change the protocol (sigh). Any get needs to return just the object or null. Maybe sendGetResponse, sendPostResponse? 
  * (Don't) Get rid of that stupid "self" in the user config. Use the proper user _id.
  * Make sure that changing a list in point A will also change the select box in point B immediately.
  * Change config so that it comes in a variable at load time. Somehow shove that into the store cache if possible
  * Make both cache and main store observable, shove things into cache at load time, and check that savings/updating works OK)
  * Make sure AppConfig creates a updated object usable straight from the application without running `get` on the store, make sure
    object is updated after `put`. Code to use config values right now is way too long
  * Use comet/messenging to make stores observable by remote. Check that changes apply if 1) They are made within the tab 2) They are
    made from another tab (through comet).
  * Change "self" in id, and write two layers: one for store changes in general, and another one which piggy backs and provides
    real-time configuration changes.
  * Add app-wide tabId, workspaceId, userId as they are just so often used. Maybe, I say maybe, make a namespace
  * Add an aspect to the store's put method to add tabId, and then take it out just before writing, so that the server always knows
    who to notify for config changes
  * Finalised, polished up, re-checked the whole Comet/messages infrastructure
  * Check permissions with permission module. Decide on whether to leave the session minimalistic as it is now ( best way ). Or maybe
    do load the user's config in the session (and refresh it if it gets modified).
  * Get the user form to appear at the top and not on the left
  * Add a link to the user profile in the workspace picker if a user logs in without ANY workspaces. Use Hotplate's Dojo mixin for this
  * Move login/userId from bd.js to hotDojo Auth, where it makes a lot more sense. Document which variables are provided for each page
  * Fix permission of get/post UserConfig (there is no :workspaceId anymore, as it shouldn't). Write a custom Auth function for it
  * Improve ID checking for mongoDB ids, make them one-liners as they are in every single call
  * Fixed mystery of ghost collections created by Mongoose when app started. It was old indexes. ALSO deleted Access as a global Model
  * !! Change the "configuration" form so that if things change (see: version is higher), then it blanks. Note that
    it cannot get registered as a tab, so it won't get the Comet signals etc. Good chance to check versions in general 
    (increment __v when editing etc.)
  * DEFINITELY switch away from Mongoose
  * Write a builder function that creates get() and put() callbacks based on information <--- !!!
  * GET RID OF THOSE GLOBAL VARIABLES in BookingDojo.js. They seemed a good idea at the time... No No No. Maybe make module that works them out
  * Created the SyncPublish widget to make sure that no call is lost
  * Changed the register form to include name and last name
  * Use schemas in postWorkspacesAnon and postWorkspacesUser, and call hooks to change those schemas
  * Use schema anywhere with post/soft validation in hotDojoAuth
  * Use schema hooks to add name and surname to workspace creation calls
  * Make a general widget to edit fields out of the ones currently used in Settings, so that most of the default stuff is done
    - Add alertBar manually to the widget so that users don't have to worry about it
    - See if I can use Jade as the template engine instead of ugly HTML.
    - Convert all forms to new system, make them a _loooot_ shorter!
  * Reorganise code so that all of the Dojo calls are in one spot, and hotDojoAuth is decoupled from Dojo.
  * Take out EVERY ServiceUnavailable errors, just throw the normal errors, and let the error manage deal with it
  * Change JsonRestStore so that it can pass through 'all', 'http', 'none'
  * Fine-tune the error manager so that it handles Json _and_ HTML the right way
  * Rename all core modules hotSomething -> hotCoreSomethig and put ALL modules under node_modules. Test that a clean install works 100%
  * Shared validators made available easily through SimpleSchema
  * Make a local, patched copy of cache.js
  * Take out that rubbish about partial update from Cache.js
  * Change update so that values in schema but NOT in update object are case/set (doesn't this already happen?!?)
  * Make a note: PUT is not partial, it is complete
  * See how dgrid works for rendering lists and provide a custom renderer widget
  * Fix issue where if entries get out of visible area and list is reloaded, it stops adding them to the grid when added! Geeee, I had to
    write my own JsonObserver for this.
  * See if it's OK to pass just the store to EditingWidget as a whole, rather than the two parameters, BOTH for EditingWidget and EditableList
  * Make the "add" form reset after adding in EditingList
  * Move widget to external file, into its own module (the same module that includes dgrid)
  * Take "ds" out of the equation for EditableList, emit a signal instead and display the global error thing in case of problems (not done)
  * Add option to add the *adding* widget (before, after, none)
  * Make a widget to ask for confirmation -- incredibly, Dojo didn't have one
  * Add option for deletion confirmation via alert (on by default)
  * Fix the "submit message" issue (change spot where it appears, or give the option of getting it to appear underneath so that 
    tiny inline forms will still work)
  * Fix the problem with EditingWidget if there is an error -- escape at EditableList must close all editing widgets
  * Make a widget that accepts one store, an editing widget, a displaying widget per item and a "style" (+button at the bottom, in-line
    editing, etc.), and make it render/edit a bunch of items.
  * Select box: create a widget that allows user to pick one amongst one of the allowed line-record -- PLUS the current one!
  * Use Use the dgrid widgets and the select widget as engines for the settings screen, finally finally use it!
  * Fix the veeeery broken system that adds tabId to each request. Now it adds it to the header, which makes it impossible to use for
    deletions. Use aspect.around() and make AppStoreNotify completely agnostic in terms of used store. Move the part about adding 
    tabId to the dojo messages module.
  * Make it possible to place the buttons underneath the widget, aligned to the top, or aligned to the bottom
  * Make it easier to notify multiple stores if a mongoDB table changes, as it's very possible that one different stores will use
    the same table (e.g. users seen by admins and by normal users). MOVE IT to a different hotplate module
  * Redo the function that loads modules in hotplate.js, it's a giant mess right now. Use it for hotCoreJsonRestStores.js
  * Get rid of the "error" variable in hotError, use allhttperrors instead (like you should)
  * Change that workspaceIdCall into workspaceId
  * Change jsonreststores-mongo so that it deals with sub-stores properly
  * YES, DONE (Login) Check if there is a better way to "login", right now it sets a bunch of server variables
  * YES, DONE (Login) Check if hotDojoAuth can be used for other systems (like passport, for example)
  * YES, DONE (Login/other) See if there is a better way to create "drivers" where "hooks" just don't cut it (see: authentication)
  * NO, NOT DONE Add function to add per-module routes to make it easier to add URLs
  * NO, NOT DONE Have a "settings" infrastructure, where modules can define settings widgets which then get added to settings
  * NO, NOT DONE Add functions to hotplate.use() routes allowing definition of stores at the same time (add stores use existing function)
  * REALLY decide on capital letters in collection names, in JsonRestStore docs and in actual code
  * Add a hook so that when a workspace is added, the creating user is also added immediately to that workspace
  * Rewrite "pick" (in hotCoreMultiHome) so that it allows user to pick an existing one and go there immediately
  * Get CONFIG stores to be marked automatically as such
  * Get hotplate to ONLY use hotCoreAuth by writing a new module to deliver a page (both multihome version, and "straight" one)
  * Make the application work again (!)
  * NO, DONE Check if there is a better way to include modules, now each function needs to (because of async inits() ). THere isn't
  * NO, DONE Move hotplate's defined stuff (`vars`, etc.) into its own namespace? Bad idea. using "vars" as a global will work fine
  * Make the application's ability to refresh itself work again (config and normal)
  * Check why login/password in manager (client side) no longer works
  * Add "resume" as an option (resume once logged in)
  * Fortify things a little (pages/ws/undefined works?!?, login widget mustnt come out if redirect vars isn't set, page mustn't be served if
    logged in user ID doesn't exist, pick mustn't work if userId doesn't exist, ...more? )
  * Finish RESUME properly (make widget to show resume buttons, write resume part in Facebook's strategy)
  * Complete missing bits (client/server) in the Local strategy (signin DONE, register DONE, recover )
  * Make resume appear if there is an auth error in the example app
  * Do something so that resuming using ANY method can give the application a visual cue that it happened
  * Fix problem where users cannot change just their password
  * Add password confirmation in management (it's only in register right now)
  * Make auth widgets independent of where they are used, put required variables in hotCoreAuth
  * Take "store" out of the constructor of Manager and Resume because it's silly
  * Implement recovery: for now just create a hash/expiry in login info for future use
  * Fixed JsonRestStores so that unset fields are deleted from the collections (otherwise old data would stay)
  * search for errorPage, change served pages so that they do next(err) rather than calling errorPage
  * sort out custom error page in case token is broken (not sure how to do it)
  * Add permission checks to auth stores, which are all completely open right now
  * Check the WHOLE authentication kaboodle to make sure it's all good
  * Add option so that if there is only one workspace for the user, Pick doesn't show a list but jumps STRAIGHT to the workspace.
  * Add a responseType to hotCoreAuth other than close, redirect etc. so that the window can stay open and actually show customisable contents
  * Convert Hotplate and any other module following the ritard "one singleton per module" pattern to a sane, simple Nodejs module.
  * Document hotplate.js properly, ask in StackOverflow what' a good way to create documentation from files. Needs to be EASY.
  * Fix serialize problem with JsonRestStores (2 ways... now?). Needs to return un-serialised data on GET
  * Chance client so that it uses new generic messages format
  * Finalise the tabIdHash function use -- is it really OK this way? I think so.
  * Finally, see comet actually work again in Hotplate -- it does, it does!
  * Make sure that a tab's lastSync time is updated every time there is a sync
  * Make sure that an expired tab leads to a new request for a new tab, and reset of all client-side stores.
  * Test things, see if everything still works
  * Move the buttonsConstructor somewhere where it makes more sense (fixed early as working on config menus)
  * Normalise all the topic.publish namespace, which is messy now. Watch out: comet events are echoed as well, put those in a different ns
  * Rewrite from scratch the whole "configuration parameters" thing
    * Rewrite the whole config stores so that they allow collections rather than just static values
    * Check that _all_ settings work properly with the new system
    * ATTACK PLAN:
      * [DONE] Make the stores first, the way they should be (6 stores, 3 single-ones, three collection-ones)
      * [DONE] Make the UI to manage those stores.
      * [DONE] Work out the whole storeTarget mess *properly*, see what it is, document it clearly
      * [DONE] Change messages so that storeTarget is out of the equation, with store(storeName) returning all stores in cache
      * [DONE] Rewrite backend so that it figures out, based on IDs, if a store is a list of is a 1-record gig
      * [DONE] Rewrite Dojo-side so that it places things into the cache accordingly
  * make sure that user has permissions to access the workspace when returning WS configuration after reset
  * In hotCoreStoreConfig, make sure that pageElementsPerPage uses workspaceId only if multiHome is enabled
  * MONGO: Add range fields (from schema?)
  * MONGO: Add mass deletion in API
  * COMET: Mass Deletion of tab messages when tab gets deleted
  * COMET: Mass Deletion of tab messages when tab expires (cron job too?)
  * Restructured the whole Comet architecture so that it's all neat and nice to look at.
  * Checked permissions for   hotCoreCometMessages/lib/hotCoreCometMessages.js
  * Made Comet messenging work again 100% using JsonRestStores API only
  * MONGO: Add cursor (with delete option) in API
  * COMET:  See if/when using cursors makes sense
  * Add "remove on fetch" for cursor-based queries (mongoDriver)
  * Add extrapolateAndPrepare in _makeQuery (JsonRestStores)
  * Make sure self.post**** are always the very last step in the chain, it's been "pushed up"
  * See if MassUpdate makes sense, it might well be as it would complete the API. Will need to allow partial updates though
  * Rewrite Hotplate, so that it doesn't have dependencies anymore, it uses enhanced EventEmitter
  * Use "cachable" function for cachable hooks
  * Write a totally custom class rather than extending eventEmitter. Write it so that registering a function requires the module's name,
   and invokeAll groups by moduleName. 
  * In new Invoke, write the aggregating functions and allow invoking for a specific module! 
  * Simplify the return of moduleName in events, change hook.stores() so that it can return an object
  * Change everywhere with hotHooks and any invokation with grep -i invokeAll `find . -type f`
  * Check that everything actually works
  * Get rid of all the registration functions in hotplate, which are now obsolete
  * Move AsyncCollectEvents to its own github module
  * Rewrite hotplate.get to make it object/save to get rid of a few (a lot of) typeof() === undefined, put defaults into modules
  * Check that all the hooks that should be cached are actually cached grep -i hotEvents.on `find . -type f`
  * Make sure that it all works with "use strict";
  * Made _getTabId() more robust in case the header is not there
  * Fixed registration with username/password, which was broken
  * Simplified the flow of all functions in JsonRestStores. More verbose, but clearer
  * Made sure that default error page sends the right HTTP error code
  * Added forgotten error check, minor formatting issues and small issues fixed, indentations
  * Now using Put instead of Post to create predefined user records (current system broken) fix "Put" which doesn't work
  * Finally using debug, and added tracer, so that logging is much much saner
  * Rewrite the Dojo side, so that it loads module in a much more dojo-style way
  * Made the driver mixin as a POSSIBLE mixin, configure it via Hotplate.
  * Made sure things actually DO work even if no db driver is used
  * Understood the strange 404 error, came up when tabs expire <--- this one was horrible
  * For JsonRestStores, MAYBE force the query to do a normal castAndParams (rather than deleting search)
  * Major rewriting of SimpleSchema and JsonRestStores, changing hotplate too
  * Change _checkParamIds in JsonRestStores so that it uses a much saner approach
  * Add body preprocessing to methods other than POST in JsonRestStores
  * Add generic, schema-less driver
  * Decide on the unit test library I will stick with for the next week
  * Finish writing tests for SimpleDbLayer
  * Change way in which totals are returned for noncursor queries, use third parameter. UPDATE DOCUMENTATION
  * Change queries so that they work as documented
  * Understand seriously when/how errors are silent
  * Check versions in packages.js for all recent modules
  * Write mongoDb-specific tests, plug them in somehow
  * Find way to allow case-insensitive searches, add "indexes" hash and query those instead
  * Add case insensitive searches to TingoDb
  * Split SimpleSchema into two, document SimpleSchema, write tests for SimpleSchema and for SimpleSchemaMongo, decide with serialize
  * Finish documenting and Write tests for SimpleDeclare (document async version of inherited)
  * Document and write tests for DeepObject and add class methods to work on a specific object
  * Document and write tests for EventEmitterCollector
  * Write tests for JsonRestStores (which will be buggy as hell). Test it by using API and checking internal param functions
  * Change hotplate so that it works with new DbLayer/JsonRestStores/SimpleSchema
  * Implement TODOs in hotCoreComet (mainly mass delete)
  * Make handleXXXX option FALSE by default, check that things still work
  * Last fix to JsonRestStores -- the paramId issue for updates
  * Change all "_id" into "id", final detachment from MongoDb...
  * Check all hotplate schemas in general, check for `searchable`, take 'required' out of paramId fields
  * Change UserStrategies into UsersStrategy & others
  * Change storeName to capital letters
  * Make things work (again)
  * Finish rewriting hotCorePage 
  * Make bookingdojo "simply work", publish it online
  * Set example application's store names to new standards
  * Make sure that Hotplate AND sample application has security checks when reading/writing records, check ALL of hotplate in general for sanity
  * Change example application to new naming standards, test permission checks just implemented
  * Decide on path standards: prefix for stores, module file paths, all other urls
  * Change config stores so that important parameters CAN be required, maybe use DbLayer to add them
  * See what to do w/ shared code/validators: possibly create another global "Validators" array with just the Validators func (what about dups?)
  * Check escaping of special characters in hotCorePage, if a variable has [[BODY]] what happens?
  * Make sure that tab messages are broadcast when workspaceId not in field (implement TODO in hotCoreJsonRestStores)
  * Make sure that indexes are created/set automatically by simpleSchema library (or DB layer library?)
  * Update docs about indexing for dbLayer, JsonRestStores
  * Check hotDojoCometMessages/client/messages.js and hotDojoStores/client/AppStoreNotify.js: "add" needs to check if it's not within
    "add" like it happens in Observer.js (check if the Observer.js way is indeed sane)
    http://dojo-toolkit.33424.n3.nabble.com/Problem-with-aspect-around-store-methods-td3999790.html
  * Turn Jade into a proper module, with enriching Dojo mixin
  * Fixup existing BD application: 
   - DONE only require() actually used modules in files
   - DONE modularise tab registration
   - DONE modularise password re-ask
   - DONE check that there is nothing else to modulalise
   - DONE check overlay logic, maybe make sure overlay is automatic
   - DONE Check that code uses new notation for widgets, with '/' instead of '.' for paths
   - DONE Fix & standardise ID names in forms
   - DONE Make sure that ALL widgets are baseless
   - DONE Delete old code, examples, tests, alternatives, etc. General tidying up of code
   - DONE Fix & standardise file names with right plurals, they are an anomaly right now
   - DONE Make sure client-side widgets requiring other widgets have a require in server-side module
   - DONE Decide on baseless in-file widgets
   - DONE Fix indentation in all files (client side), decide on strict standards
   * Search for 'domReady', take it out when it doesn't make sense
    ./node_modules/hotDojoAdd/lib/hotDojoAdd.js
    ./node_modules/hotDojoStores/client/AppStoreNotify.js
    ./node_modules/hotDojoStores/client/stores.js
    ./node_modules/hotDojoGlobalAlertBar/client/mainAlertBar.js
    ./node_modules/hotDojoStoreConfig/client/ConfigVars.js
  * Fix simpleDeclare, as this.inherited is very very broken
  * Fix problem with Jade, decide what to do (drop it?)
  * Change clientPaths hook to clientPath, only one "public" path per module
  * Select items need to be ALL preloaded beforehand, overlay goes away once dgrid is ready.
  * Fix StoreSelect and EditableList so that they are overlayed properly. Also:
    * With "refreshData", change "refresh" to clickable overlay 
    * catch dgrid errors with overlay if necessary
  * Improve overlay: "Loading", "ClickToReload" (with icons accordingly), make the dgrid widgets use it
  * DONE Write a detailed email to the Dojo guys, explaining exactly what I did:
     - Add options.relocation to options in put() in case it's just a relocation
     - Change JsonRestStores (adding headers X-hotplate-relocation and X-hotplate-before)
     - Change Observable.js so that it doesn't use a queryEngine (requires adding adding methodParams to notify() )
     - Tell them about insanities such as http://stackoverflow.com/questions/14796968/how-to-implement-row-reordering-with-dnd-in-dgrid
  * Finish JsonRestStores with proper reordering
    - DONE Finish fixing JsonRest.js so that placement is changed if necessary
    - DONE Finish Observable.js properly, so that it extends notify() and actually works 100%
    - DONE Change storeNotify.js so that notify is called with the new parameter (or a new message altogether?)
    - DONE Change the after header, if after is null, send an empty header and not lame string 'null'
    - DONE Change JsonRestStores so that it has a "order" field that gets set according to the passed options.before
    - DONE Change dojo/store/Memory.js so that it keeps into consideration "before" and "relocation" (AAAAAAAAHHHHHHHHHH!!!!!!!)
    - DONE Fix MongoDb so that it uses an easier way of doing the counting
    - DONE (Not done, useless burden on Dgrid) Change DnD.js so that it sends a FAKE EMPTY field when `reposition` is true
    - DONE Change JsonRestStores so that it broadcasts 'before' and 'relocation', chose how to do it
    - DONE Fix strange issue where delete grays records, dgrid doesn't refresh (doesn't get notified?)
    - DONE Deploy onto live server on nodejitsu (change dgrid reference in repo)
    - DONE Complete email with links
  * Make timeouts longer for tab expiry (change client/server)
  * Move everything to Dojo 1.9.x
  * Implement artificial delay in JsonRestStores
  * Give visual cue of DnD in hotplate
  * Rewrite _OverlayMixin so that it keeps a counter of how many reload overlays there are, rewrite code so that is uses the new Overlay
  * Fix bug with dialog editing that doesn't work in EditingWidget
  * Give visual cue of adding element in EditingWidget
  * Improve code in dgrid's event emission, avoid repeating code, merge it onto the patch
  * Check bug where select list doesn't get updated
  * Check bug where dispatcher calls fail strangely
  * !!! Understand how to make un-invasive CSSes, "get" CSSes, fix CSS in all widgets
     - http://dojo-toolkit.33424.n3.nabble.com/Question-on-CSS-with-widgets-td3995316.html
     - http://stackoverflow.com/questions/21175377/css-classes-and-widgets-three-questions
  * Improve the look of the app and widgets: welcome and pick to look nicer without abbruzzese
  * Fix busy buttons when login/create accounts, overlay on redirect when creating workspace
  * Change JsoNRestStores so that it's much much more DRY: get paramIds from URL if possible, set the ids in schema from paramIds
    if not in schema
  * IMPORTANT: Check that hotCoreMultiHome still makes sense (check stores.UsersWorkspaces)
  * Reorganise WHOLE application, so that all select boxes and editable lists actually have a point
    - Fix CSS (no inline stuff, make space) in all forms
    - Fix overflow
    - Add "god" tab
    - Move EditableList's css from bdMain to EditableList
    - Add app-wide selectable options for workspace and for user in "god" section
    - Move login info into user config
    - Check that I covered all cases:
      - List no wid nor uid
      - Save/list with only wid
      - Save/list with only uid
      - Save/list with both uid and wid
    - Missing: list with both uid and wid (list of something in userConfig)
    - Add config stores with no wid/uid (loads the lot at startup)
    - Check that Multihome permissions work with only userId, and both in queries and fetching
    - Take out queryParams from postCreate around the code since it's useless
    - Check why buttons don't work in users dialog box (focus issue). Solution: add dijitPopup class to them, focus issue with dialog
    - Automatically focus on first focusable node on startup of EditingWidget
    - Fix conflict between inline editing and DnD. Can't believe I fixed this myself, I think I am getting the whole DOM thing
    - !! Check why horizontal scrollbars appear when editing an inline textbox
    - Add to EditableList the ability to define an extra widget, and display the new Widget in a dialog without repeating code
    - Have "preset" text that disappeares in textbox (Dojo should have it)
  * Document JsonRestStores, paramIds is now optional, publicURL is what counts, id fields are assigned automatically
  - Check why adding an entry doesn't automatically position it at the end (reload after adding to see)
    DECIDED: only accept to add as "last" for ordered and unsorted ones. Later we can add in specific spots easily
             but for unspecified it needs to be last 
  * Fix stupid bug in JsonRestStores
  * Check why JsonRestStores sends double headers if on line 1048, _relocation is passed null rather than 'null', bad symptom
  * Test if comet does what it's meant to do when broadcasting all store cases
  * Fix the way parameters are passed in EditableList/editingWidget: not storeName and store, but storeName+storeParameters+storeExtraParameters
  * Test that I can nest however many times without losing URL parameters <-- Geeeeeeeeeeeesus
  * Make it possible to pass ONE widget, for editing and adding, since they are (nearly) always the same 
  * Fix successfulsubmit, make it bubble from the editing widgets, and kill the bubbling from the main form. WAY: add "store"
  * Check what you are meant to do when you have a prop you can pass a widget that is also defined in the prototype,
    check that the prop-copying is in the right spot
  * Find a way to have stores where you just add things, and it takes more space as it grows
  * Improve interface for email addresses, make it come out after adding a new email address automatically
  * Improve the UI for email addresses so that it's actually clear what it is
  * Make sure non-children (placed) widgets are destroyed (including buttons!) when EditableList is destroyes
  * Make sure the second half of the contact form is its own widget, that will appear all at once when adding has happened
  * Decide if editable-list needs to be relative (it has an overlay!)
  * Understand strange extra refresh in email dgrid after first email address added -- Dgrid does it, cannot fix it!
  * Resolve issue where dgrid is calling refresh at the same time as bd.js, and in the end there are two overlays as
    dgrid-refresh-complete is only called once. Find/make flag to see if a refresh is happening
  * Check why email is not checked server-side (disable client-side check to see)
  * Do not allow entering same email address twice (only server side!)
  * Make DnD actually work for email addresses
  * Fix JsonRestStore's "positioning", dbLayer needs to be passed a table AND a filter, or it will reorder the WHOLE TABLE!!!
  * Document JsonRestStores with new hook, afterValidate(), which is always useful. Consider changing the signatures of others as well
  * Document skipHardLimitOnQueries for select
  * Update tests for JsonRestStores, add TODO for new hook and fix existing hook
  * Update TingoDb with latest code
  * Fix ENORMOUS bug where if a contact is saved twice, there is a post rather than a put (!!!)
  * Make sure that after a new adding, form is reset for email
  * If application is down and a contact is open, reload button missing from email overlay (needs to preload the image)
    http://stackoverflow.com/questions/21449635/pre-loading-images-in-a-one-page-application
    (In the end, resolved creating TWO overlays and only displaying the right one)
  * Check *ALL* issues regarding editing widget that must reset, writing in the field beforehand, widths, etc.
  * Prettify email widget (adding side)
  * Add birthday, with near date picker. Ths one was easy. Dealing with dates *regardless* of their timezone, however... meh.
  * Implement postal addresses, with a neat interface like emails
  * Make positioning of addresses actually work
  * Check buttons positioning issue ('bottom' is not working)
  * Render somehow an empty address so that there is at least a node
  * Check why dialog doesn't close when adding a new address
  * Check why focus goes to top after adding an address
  * Give more max height to email/addresses widgets (needs to match)
  * Make date selector default to something saner
  * Have a better separator for addresses
  * Add Company Name or "type flag" to contacts (companies don't have middlename, lastname or DOB, so hide them)
  * Deal with textboxes, add hooks to EditableList to deal with form submitting and widget assigning so that checkboxes work
  * Fix horrible resize problem with the contact form
  * Implement phone numbers, with a neat interface like emails and ability to pick the country from a list of country codes
  * Add data about allowed countries somewhere both for client and for server side (shared function!)
  * Check country code and phone number client/server side
  * Add fields "favourite contact" (virtual?), "syncModule" (string, will make it read-only), "syncId" (foreign ID), syncDate, isStarred, notes
  * Make contact "starrable"
  * Add option to offset buttons to the right
  * Fix alignment of loading overlay with star
  * Change widget so that it's about being ticked/unticked, move it to hotplate
  * Make sure extra info is fetched when a contact is fetched (addresses, ph numbers, starred, emails)
  * Make the contact list look better, adding columns like Google Contacts.
  * IMPORTANT: Find a way to find "starred" users only, or "category X" users only
  * REWRITE SimpleDbLayer COMPLETELY TO IMPLEMENT AUTOMATIC LOOKUP AND ADVANCED SEARCHING
  * X Pass Schema to db layer, make it use it to cast/validate data when fetching and inserting
    X Pass ref: to constructor, store it
    X Make a refRegistry variable to hold what changes, put it in the prototype
    X Write recursive function to create the contents of _autoLoad  for a specific child table
    X Populate parents' _autoLoadCache if a child has records added/modified
    X See if it's best to use self rather than repeated first parameter, test carefully
    X Add _searchData as well as _children, have all text fields in capital letters. This is the same as the other one,
      except that fields are in capital letters and go into _searchData!
    X Make up easy way to pass _children, it's a special case since it will only be loaded if autoload is set
    X Add a function to populate all _children for a table  that doesn't have autoload
    X Implement single-lookup autoload (for 1:1 relationships)
    X Improve code and documentation on recursive code 
    X Add a function to redo _searchData and _children for every child table of a record, just calls _completeRecord
    X Add recursive code to updates and deletes, write helper functions for that
    X Fix huge issue where there can be N lookup fields for the same table in a record, turn hashes into arrays and correct _getChildren
    X Fix constructor for tables, take out recursion as it's 100% useless and silly
    X Check output of tests to see that it does exactly what's needed, seems slow
    X Fix last standing bug with configR apppearing
    X Improve tests' code so that it's not as repetitive and it's actually usable
    X Add mechanism to avoid infinite recursion in case of circular referencing
    X Add method to get a model from the registry once it's defined
    X Implement joins (!)
    \ Change recursion check:
      X Add path AND root table (or path lists?) to the call
      X Explicitely list what will be added to _children  as a list of paths in the root

      X Complete rewrite of _updateParentsRecords
      X Add conditions for _searchData, doing uppercasing of data
      X Reinstate checks for autoLoad and searchable to see what to add
      X Re-add  record information in _searchData in update or insert

      X Finish _updateSelfWithSelfUppercase()
      X Make "delete" work (cases 5 and 6)
      
      *
    - Implement searching in simpleDBLayer
      X Populate the searchable hash with all searchable array (plus the ones defined by hand), take TODO comment out
      X (Nearly done, only missing adding foreign keys for joins)
      X Take _searchData out of hash in constructor, make sure it's added by the search itself
      X Make sure that selectors are created by hand, rather than with makeMongoParameters (the check on searchable fields will fail)
      X Find out why updateSelfWithLookup doesn't work
      X When searching in select(), search in _searchData at all times, all existing tests should then pass
      X Fix problem when updating something ends up screwing up _searchData for all records
      X Write tests for simpleDbSchema with better data
      X HEAVILY optimise queries in the module now that the logic is there, merge all update calls so that they only happen once

      *
      X Check answer: http://stackoverflow.com/questions/22212834/positional-working-on-different-parts-of-the-same-document
      X Assign one row at a time, plus use unsetObject, in cases #3 and #4
      X Make "delete" work (cases #5 and #6)

      X Finish off cases #3, #4, #5 and #6 in updateParents with completely new data structure, will simply mirror updates

      *
      X Fix but with parentTablesArray pointing to the prototype
      X Made sure that eachSeries is called when deleting to make logging clearer
      X Check that indexes for joins are actually correct in SimpleDbLayer (look for TODO)
      X Implement indexes with existing system (field names are just longer), taking code from JsonRestStores

      *
      X Implement indexes for single fields
      X Fix sortable with its own hash and its own check
      X Declare positionField, make positioning work in SimpleSchema

      X Place JOIN mongo-specific parts in separate functions, general code/variables tidy up

      *
      X Make idProperty mandatory in SimpleDbSchema and tests (for tests, just make name the idProperty)
      X Create position key properly http://stackoverflow.com/questions/22291038/clarification-on-sorting-subsets-in-mongodb
      X Create function that creates indexes for _all_ layers
      X Change select: validation needs to allow the _children fields through
      X Make sure select cleans up __uc__ fields from children, so that testing is even possible and results are correct
      X Actually run tests after operations, passing a "test" function for each op
      X Check that required fields cannot be set to undefined with an update with the deleteUnsetFields flag, decide with extra fields
      X Add test for indexes
  * Update JsonRestStores so that it uses the new db infrastructure and new search abilities
    X Change JsonRestStores so that you first define layers, and then associate them to a JsonRest store
    X Rewrite the way search works, a JsonRestStore field activates a query on SimpleDbLayer on multiple fields with conditions
    X Write tests for JsonRestStores with new infrastructure

  * Change hotplate so that it uses new JsonRest Stores
    X ./node_modules/hotCoreMultiHome/lib/hotCoreMultiHome.js <- searchSchema!
    X ./node_modules/hotCoreComet/lib/hotCoreComet.js <- searchSchema
    X ./node_modules/hotCoreAuth/lib/hotCoreAuth.js <- searchSchema

    X ./node_modules/hotCoreStoreConfig/lib/hotCoreStoreConfig.js
    X ./node_modules/hotCoreStoreLogger/lib/hotCoreStoreLogger.js
    X ./node_modules/hotCoreJsonRestStores/lib/hotCoreJsonRestStores.js
  * Whatever this meant: Make sure that JsonRestStores in Hotplate does the broadcast based on the table name. Schema is the same
  * Make sure that, when called by API, GetQuery allows searching for anything in either the searchSchema or the main schema
  * Document simpledbschema and JsonRestStores
  * FIxup problem where adding a new contact doesn't trigger a refresh
  * Check that reordering _actually_ works
  * Change all "relocation" into "reposition"
  * Check and document that 'null' in `reposition`
  * Changed all searchSchema entries into onlineSearchSchema which makes a lot more sense
  * Add "data" or "blob" type to SimpleSchema, so that I can store data without uppercasing it (strings are)
  * Fix huge problem when userId is null in MultiHome
  * RUN THE APP, test positioning, play around (is authManager fixed?)
  * Go through all API calls, make sure that killComet is on when necessary
  * Understand why authentication manager doesn't show the tick anymore. This one was ridiculous. How did the CSS change?!?
  * Check ALL existing onlineSearchSchemas, make them work with new architecture, check sanity
  * Make sure that all small custom-created stores have logError set so that they log hotpate errors
  * Convert existing code to new "nested" architecture. 
  * Re-Deploy app to NodeJitsu

  "PEDONE"

  * 
    X Get existing application ready
    X Write initial form and stores
    X Plan work and TODO
    X Pick modules and headless chrome (CHOICE: phantomJS + node-phantomjs-simple)


  *
    X Move UTCDate from ./WorkspacesContacts/WorkspacesContactsInfo.js to hotplate
    X Draft a form that sends date/time to the server (UTC) mixing the two
    X Finish off form: validation, and setting time in form calculating time from date
    X Add codes as a list of codes/labels
    X Finish off initial interface

  *
    X Add a button to synchronise time offset based on server's UTC time
    X Add interface with time when crawling starts, and "status" (can be waiting, requesting, submiting)


  *
    X Change form so that it works on browser's local time
    X Work on interface, adding iFrame for manual submit and initial log browser
    X Test manual interface on Marco's form

  *
    X Only set fields that are empty
    X Add buttons to iframe interface: "force reload", "stop refreshing", "close"
    X Make interface collapse when sending requests
    X Make it less "bliky" (overlay, or two frames)
    X Enable/disable buttons depending on the automaton's state
    X Have indicator of reload counts
    X Display code at the top of the frame
    X Fix frame height so that iframe is as big as it needs to be
    X Check for ways to see if just "body" has loaded

  * 
    X Ability to log from client side
    X Ability to see logs

  *
    X Fix "time offset" procedure
    X Make logs downloadable as text files

  *
    X Rewrite server-side request scheduler

    X Add fields to the contacts: when saving, make sure that main contact, main address and email are stored
    X Check _broadcast in hotCoreJsonRestStores, after HUGE refactoring, reordering eats records on different tab
    X Make sure that local app gets notified of change in record if an email is changed/repositioned (!)
    X Fix ordering in main screen, seems off, contacts added at the end (fingers crossed it's nothing serious)
    X Change hotCoreMultiHome.js so that workspaceName is handled by layer
    X Make sure that what I did for email also happens for addresses and phone numbers, do it the right way
    X Avoid (all?) refreshes to the dgrid, make it look for the cell, and if there, change it. It turned out to be
      a problem with successfulsubmit (local event) triggering a refresh (which would only work locally)

   X Change EditableList so that it's a container, placing list in centre and widgets where required
   X Check existing CSS for sanity
  * 
    Make sure the following sets CLASSES and not styles:
    N ./hotDojoWidgets/client/AlertBar.js
    N ./hotCorePage/lib/Csses.js
    N ./hotDojoAdd/lib/hotDojoAdd.js
    N ./hotDojoDgridWidgets/lib/hotDojoDgridWidgets.js
    
    X ./hotDojoWidgets/client/_StackFadingMixin.js [ html.style ]
    X ./hotDojoWidgets/client/_OverlayMixin.js (easy)
    N ./hotDojoDgridWidgets/client/EditableList.js
    N ./hotDojoDgridWidgets/client/StoreSelect.js
    N ./hotDojoAuth/client/auth/local.js
  * Make sure that widget classes are declared within widgets themselves, probably in postcreate in non-template ones
  * Make sure heights/sizes are defined for each BorderContainer-based widgets, or they won't show up at all
  * Redo CSS for the whole app
  * Phone numbers, unlike emails, don't get updated (set?) when setting them as first
  * Check double-refresh issue with lists and contacts
  * Editing an address adding lines to the first field stuffs up the form
  * Turn EditableList back to a templated widget, since it's not a layout defining widget
  * Fix heights for all editable lists
  * Fix bug where a delete doesn't trigger refresh of contact in list
  * Make sure app works well, general basic QA
  * Find better names for existing select boxes and config options, finalise them
  * Make dummy widget to prevent singleChild resizing
  * When a user is added to a workspace, create an empty contact linked to it and add nested: to workspacesUsersInfo
  * Check the 74 (!) errors in tests in simpledbschema
  * Change how I develop, start using some kind of GUI, this is becoming silly. Really. Not good. At all.
  * Put contacts editing widget in config options as own information
  * Have small 2px space for tabs, make email address a select from contacts' email addresses
  * Fix problem where after workspace creation config options do not include _children
  * Show a "tell us about you" and jump to userConfig (or embed widget in dialog box?) for new workspaces
  * Make sure "tell us about you" stays on till a name and an email address is entered  
  * Redesign SimpleDbLayer/JsonRestStores so that they allow one-field stores implement isStarred with new way
  * Make "contact type" not appear for companies 
  * Make isStarred a generic class in JsonRestStores 
  * Make sure linkedUserId is properly protected and it all works (no longer gets overwritten)  
  * Make any contact form update itself based on linkedUserId being there (contact category will disappear)
  * Understand how the hell mainAddressId (and other mainS) did NOT get overwritten without "protected"
    (Answer: SimpleDbLayer-Mongo was broken and wasn't unsetting _children, so they DID get overwritten...)
  * Improve way in which "Tell us about us" handles an email address being there, no error message
  * Have a select box for email address in user config, taken from contacts' email addresses
  * Show main email address in user WorkspacesUsersInfo
  * In contact list, make sure contacts are not DnD-able (meaningless)
  * In contact list, mark contacts connected to users
  * In contact list, take the buttons out for linked contacts
  * Add permissions so that a user cannot change a linked contact unless it's their own (or it's God)    
    MultiHomePermsMixin will do this automatically if field is called userId!
  * Fix issue with same-layer store, where cache needs to be updated in all of them and notifcations
  * Add "enabled" flag to stores that can have fields deleted
  * change queries for stores
  * Add DnD recipient that, when it receives a record, will submit it with enable=false and refresh list
  * Fix bug in EditingWidget where first added element will take recordId
  * See if there is an easy way to get store to give visual cue of reload after moving to rubbish bin
  * (dstore) Add dgrid events in store operations to get visual feedback back
  * Make sure there is a refresh every time there is any operation
  * Make 'cached' option for stores, export it, construct the right one   
  * Fix messages, right now returning the same message over and over again, and avoid using __proto__
  * Turn Caching off altogether in app waiting for dstore to be fixed
  * Fix deletion, dnd source with dstore 0.4 must have changed
  * Make sure StoreSelect uses get() to get current element, rather than grid (L165)
  * Make sort work again    
  * Add tracking code to _ManagerButton.js (it's now commented out)
  * Improve look of rubbish bin
  * Implement new dstores:
      [X] Add option defaultNewToStart at reposition()
      [X] Change reposition(), make it so that
        - it decides whether to do repositioning basd on positionField
        - if beforeId is specified, positions based on beforeId (null for the end, or spot)
        - if beforeId isn't specified, position at end by default, unless defaultNewToStart is set
      [X] Party!
      [X] DO: Update hotplate to latest dstore/dgrid, keeping changes files (DnD.js in dgrid, nothing in dstore)
      [X] PATCH: dgrid, emit events and make sure things are not deleted
      [X] UNDERSTAND: code of dstores, all of it (esp. memory queries)
      [X] PATCH: repositionOnly (dgrid needs to set it), defaultIndex (add option in event with Brandon's "if")
      [X] PATCH: support header put-default-position (this.defaultNewToStart)
      [X] PATCH: add defaultNewToStart an option in page variables so that cache memory stores behave correctly
      [X] FIX: Check how to place things in last spot, `null` currently doesn't work

      [X] DO: Run the application, make it work again 

      [X] DO: Clone latest dgrid and latest dstore
      [X] FIX: Work out why in Observable, #243, you need `if ( object && store.getIdentity(object) == targetId) {`
      [X] FIX: Code that observes auth buttons, now that I have the object on delete
      [X] DO: Add memory cache back to application (injecting values will now work)
      [X] CHECK: make sure the right message is broadcast, `put` can create or update, make sure it's right one
      [X] FIX: AppStoreNotify to use store's events rather than aspects to get events, which will fix TODO in it too
      [X] FIX: Make sure that Rest.js emits right event, create/update depending on HTTP response
      [X] FIX: Reposition mustn't be called on putExisting unless beforeId is specified
      [X] DO: Rewrite code to only force refresh when actually needed (maybe patch dstore with shouldRefresh)
      [X] FIX: headers in Rest.js and JsonRestStores.js and hotCoreJsonRestStores.js (work out what is sent first)
      [X] CHECK: Application making sure that everything happens as it should, reordering/moving/editing etc.
      [X] CHECK: If user is booted out, it still asks for password to let them back in, Resume.js line 62 
      
      [X] Create own repository for dstore, send pull request for status 201, commit with own stores properly
      [X] DO: Rewrite AppStoreNotify and change any topic.subscribe('storeRecordUpdate') to listening to store
      [X] DO: Write page with all query options, https://github.com/SitePen/dstore/pull/29#issuecomment-46746382
      [X] Check why email addresses don't get refreshed, Suppress reload for local changes after a put
      [X] Re-implement suppressRefresh, Check user registration screen
      [X] Make sure message attributes are copied onto events, with minimal manipulation through message life
    Add configuration option to decide sorting of contacts, 
    Make "sorting of contact" setting the default in contact list at startup
    In workspace config, add option to have a default country code for SMSes and contact data entry
    Put the "name" back at the top of the app, taken from the contact, and check that it changes when changed

    In contact list, add a second view on contacts with all "starred" ones. Use body preprocessing.
    Add filter box on top of contacts
    Check refreshes when there is filtering in contact box and an item is changed   
    Make up filters for contacts, allow to search for them.
    Make refreshing on filter more intellingent, check for onChange and then issue refresh with scheduleRefresh
    Fix problem with special characters in search like @
    Fix CSS around the app, make configs look OK
    Write "contact lookup" field form that auto-completes contacts (make it configurable)
    Cannge contact pick so that it searches in email store rather than contacts
    Change remote messages so that they are the right way
    Re-enable 'remote' messages for whole stores
    Make the contact lookup refresh changes (especially since you can edit things with it)
    Polish up contact picker
      [X] order by contactId.id 
      [X] If possible, do not repeat details if ids match
      [X] Highlight primary email address, or (better) make it come up first (__positioning not working?)
      [X] Develop "default sorting" in JsonRestStores.
      [X] Use default sorting for main contacts screen too
      [X] Focus on search box when opening window
      [X] Edit icon to edit
    Write "Phone number pick", take it from email addresses (or )
     X Rename WorkspacesContactsEmailsPicker back to WorkspacesContactsPicker
     X Take out "Picker" from WorkspacesContactsEmailsPicker onto its own file
     X Make sure output is different if type is "PhoneNumber"
     X Test it
    X Change interface to allow editing, opening of contacts
    X Turn contats screen into a multi-tab screen
    X Make a new tab open reliably when contact is selected (handle multiple openings)
    X Create screen to show a contact
    X Write basic database fields for the 5 messages table (3 core, 2 app)

    - Add ability to add a message under a contact, no cc: (SMS/email)
       X Body needs to reset after send
       X Widget spacing
       X Message is "sent" not "saved"
       X SMS characters count
       X SMS don't validate over X
    - Add ability to cc other contacts, with ability to delete added contacts
       X Add in right spot
       X Put CC in same div so that it doesn't get separated
       X Format names right
       X Format PLUS properly, turn it into a button
       X Do not repeat already inserted IDs
       X To: added as one of the recipients, as first, not mandatory
       X Make names look better
       X Add X to names, delete div when pressed
       X Delete all EXTRA To: after sending
       X Fix breaking when selected by keyboard
       X Improve keyboard selection, get picker to come up when typing
       X Send the right data to the server (list of IDs)
      X Fix rendering issue in list, always refresh flag in stores
      X Rewrite the API for JsonRestStores so that it's uniform and it's easier to add messages
      X Write hooks to workspaceMessage store to actually add messages to the right spots using API
    X Render messages well enough in list
    X Add way to set 'from' via API rather than session
   SERVER. STORES/FIELDS FOR:
    X Add ability to configure twilio (God): add shared phone numbers, API key, API token
    X Add ability to configure email (ws): 
      - Email address
       - SMTP (server, account, pw, port)
       - IMAP (server, account, user, pw, port, interval) 
    X Add "system message from" (ws)
    GUI
    X Add ability to configure twilio (God): API key, API token
    X Add ability to configure email (ws):
      X SMTP (email, name, server, account, pw, port)
      X  IMAP (server, user, pw, port, interval) 
    - Add ability to configure twilio's numbers:
      X (God) Add shared phone number/subsystem pair as "shared", "available", "private" (to specific ws)
      X (God) Render numbers better, make it work with 
      X (God) Make it generic, not just for Twilio, adding a "provider" field.
    X (God) Validate so that workspaceId is only allowed for 'private', validate type and provider
      X (ws) Ability to pick a public number, or a private one with matching workspaceId
      X (ws) Make a store called WorkspacesSmsConfig, configure it via GUI 
    X (ws) Add "from" to GUI to see who the message will be from (only name, not phone/email address)
    - Add program-side export of "from" set in GUI, use it
**
    SERVER
    X Add program-side export of configuration based on type/recipient in BD
    X Write interface to pick senders of SMSes as well (right now only email actually works)
    X Write cron job to go through message queue
    X As it goes through message queue, actually attempt to re-send with right layer changing status
    X Run run() of each working layer; SMTP will start a cron job, SMS will activate URLS (incoming, statuses)

* Library modules (simpledblayer, simpledblayer-mongo, etc.) do debugging wit hthe "debug" module.
  No log levels, no specific handling, just debug info that can be switched on and off

* For debugging messages, each module does require('debug')('hotplate:hotModuleName') and then does
  debugging by issuing debug('...')
  
[X] Study node-imap module to see how it all works
[X] Write first rough function to fetch messages via IMAP
[X] Patch IMAP module so that it handles socket timeouts properly
[X] Rewrite lot so that it's two different functions
[X] Add a counter to see if the imap connection can actually be closed
[X] Rewrite logging/status functions as two separate ones, change code that use them
[X] Rework naming of some variables to be consistent in terms of text/body

[X] Close/kill connection RANDOMLY too early, and see if errors are shown properly

"LOGGING"
[X] Emit events when logging, decide what to do about events that are not message-specific
[X] Change logLine so that it only adds to messagesDeliveryLog if there is messageTo
[X] Add 'config' to message logging

"REVERSE-ADDING"
[X] Add the messages/messagesTo to the database, checking that the unique ID is not duplicated.
[X] Serialise attachment data onto the database in ad-hoc field
[X] Emit events so that app can update their shit too
[X] Make bookingDojo add messages with those signals
[X] Only when EVERYTHING is OK, mark messages as read on server
[X] Change config name of "smtpSystemEmail" to something more generic
[X] Add function to delete records in messages, messagesTo, messagesAttachments (not logs) if error
[X] If message was already in database, try to mark it as read while giving up on fetch
[X] Place full IMAP fetched headers in foreignData
[X] Chech flow of hell-ish imap-fetching function
[X] Check why socket timeout is triggered regardless of data going through, probably change to keepAlive

[Sunday]
* Fix logging before it's too late, in the WHOLE of hotplate, MongoMixin, and hotCoreTransport
  [X] Finish off hotCoreError, making sure that _all_ JSON rest stores calls it
  [X] Finish off hotCoreStoreLogger
  [X] Finish off description document
  [X] Add log entries here and there in the program, when user logs in, for example
  [X] Move out some of the functions, decide if it's OK to pass stores as arguments
  [X] Allow the system to return a stream rather than the part directly with different function
  [X] Figure out how the API should work -- forward thinking required. Stores? Module calls?

[Wednesday]
  [X] Make sure changeMessageStatus is emitted every time a message changes its status
  [X] Implement attachmentOnStoreSave and attachmentOnStoreDelete (Add MD5 on configID for attachments)
  [X] Make sure attachments are downloaded on the spot
  [X] Do not download large attachments, giving a warning

[Thursday/Friday]
  [X] Check individual intervals for IMAP
  [X] Fully reorganise code for hotCoreTransport
  [X] Decide on logLine, does the err parameter make sense? Fully undertand difference bw logLine and debug
  [X] Full code audit, especially in terms of what to do in case of errors (logging/debug)
  [ ] Test that fetching/sending emails actually works, final testing, simulate errors, check timeouts

X Configure router so that incoming requests work for testing
X Get an example text and print req
X Check request signature, signature code (do not use Plivo's module, copy code)
X - If signature is wrong, log level 3 and exit
X Add email to database
X Emit signal about message received
X Fix huge config mistake: config entry needs to match, first one is not good enough
X Add URL for message status update (add URL to sms request)
X MAYBE make 2 URLs (incoming, status) configurable via GUI (check first)

X When a message is sent, it needs to be set as "delivering", and it NEEDS to have its foreignId set when the
  processor actually has it for delivery. The status will then be updated by the processor
X Add some kind of semaphone to the update of status. Or, BETTER, never change the status from "delivered"


X Check sendMessage for email, maybe it's worth getting the message ID upon sending like I do with SMSes
X Check the story with status response when sending multple SMSes in one go, be clear about it in doc
X CHeck all setMessageStatus, that they have FALSE to attemptTried
X implement attemptAfter, enforce delay in hotCoreTransport
X See if the whole thing still actually works (which at this point would be a bit of a miracle)
X In SimpleSchema, attempt as 0 pukes -- check why, and set attempts to 0 so that it works
        // X Add appData as object to messageTo, to store the contactId the message is meant for
        // X Emit an event that allows modules to manipulate an email before sending
        // X On way out, add something to the subject "Hello there [C:323123]"
        // X Match ID in subject with ID in WorkspacesContacts and set messagesToContactId
        // X Make sure subject is stored to the DB *without* trailing [C:3131321]
        // X Match email address with email in WorkspacesContacts and set messagesFromContactId
          [X] Structure API for all layers, define all functions and their exact signatures
[X] Write email layer to actually send/receive emails
[X] Write plivo layer to actually send/receive the SMSes
[X] Make sure BookingDojo adds to workspacesMessages and workspacesMessagesTo for incoming messages (email)
[X] Make sure BookingDojo adds to workspacesMessages and workspacesMessagesTo for incoming messages (sms)
X Improve debugging messages in workspacesMessages    
X Send TEXT version of email as well, taken by taking out tags from interface
X Figure out how to send SANE, CLIENT-SAFE html from the email contents
X Validate `to` in workspacesMessages (comma separated list) 'abc123,def456,ghi789'.match(/\w+(?=,|$)/g);
X Changed ownedByWorkspaceId into workspaceId
